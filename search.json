[{"title":"我的个人项目","url":"/article/projectInfo/","content":"欢迎参观我的小项目\n1. 钻山打字通\n这是在github上fork的一个基础项目，在此基础上新增了音乐播放功能,修复了已知的一些bug且,重构了一些项目代码。\nJava编写的一款简易的打字练习软件\n软件截图：\n\n代码仓库地址\n2. 数字图书馆\n系统截图：\n\nSSM+MySQL+JQuery\n代码仓库地址\n","tags":["个人项目"]},{"title":"贷款核心业务知识","url":"/article/BankCoreSystem-%E8%B4%B7%E6%AC%BE%E6%A0%B8%E5%BF%83%E4%B8%9A%E5%8A%A1%E7%9F%A5%E8%AF%86/","content":"1.贷款模块的特点\n贷款的基本要素：金额，利率，时间，用户\n\n\n1）由于贷款业务的产品有很多，所以贷款系统必须可以进行灵活的产品设置，多样的利率变更方式，灵活的期限调整，多种还款方式，灵活的还款计划，灵活的利率设置，以及组合产品。\n\n\n2）贷款到期后是要回收的，但由于可能数据量巨大，所以也应提供自动批量贷款回收功能。\n\n\n3）由于贷款交易的特殊性，所以需要关键交易的复核或授权。\n\n\n问题：贷款操作会计无关性 是什么意思？\n答：在业务处理时不考虑会计核算要求，这就是业务走的会计无关性。\n2.贷款的生命周期\n\n一、贷款申请\n\n借款人向当地银行提出借款申请。除申请农村小额贷款外，申请其他种类的贷款须提供有关资料。\n\n二、信用等级评估\n\n银行对借款人的信用等级进行评估。\n\n三、贷款调查。\n\n银行对借款人的合法性、安全性、盈利性等情况进行调查。\n\n四、贷款审批。\n\n银行按审贷分离、分级审批的贷款管理制度进行贷款审批。\n\n五、签订合同。\n\n银行与借款人签订借款合同。\n\n六、贷款发放。\n\n银行按借款合同规定按期发放贷款。\n\n七、贷后检查。\n\n银行对借款人执行借款合同情况及借款人经营情况进行追踪调查和检查。\n\n八、贷款归还。\n\n贷款到期后，借款人按时足额归还贷款本息，如要展期应在借款到期日之前，向银行提出贷款展期申请，是否展期由银行决定。\n所以贷款一次完整的生命周期可分为八步，分别是：\n贷款的申请–&gt;信用等级评估–&gt;贷款调查–&gt;贷款审批–&gt;签订合同–&gt;贷款发放–&gt;贷后检查–&gt;贷款归还\n3 时间上贷款维度\n从时间的维度上划分，一次贷款的完整交易可分为：贷前，贷中，贷后。\n1）贷前\n第一步：客户申请\n第二步：线下审批流程及纸质合同签订（这一步是否可以确定贷款结果？） 答：可以\n2）贷中\n第一步：建立客户信息\n第二步：贷款承诺处理（这里是否是处理客户贷前签订的合同？） 答：是的\n第三步：贷款开立，同步合同\n第四步：贷款放款\n第五步：贷款提款，受托支付（受托支付的方式有？）答：受托支付是贷款资金的一种支付方式，指贷款人（依法设立的银行业金融机构）根据借款人的提款申请和支付委托，将贷款资金支付给符合合同约定用途的借款人交易对象，目的是为了减小贷款被挪用的风险。受托支付适用的情况是：贷款资金单笔金额超过项目总投资5%或超过500万元人民币。\n3）贷后\n第一步：利息处理\n第二步：费用处理（这个费用是啥费用？）答：一般是手续费\n第三步：贷款变更\n第四步：还款处理\n第五步：核销，终止，关闭（核销？）答：贷款核销是“呆账贷款核销” 的简称，银行按规定将呆账贷款或贷款损失予以核销的一种制度。\n4.利率的基本维度\n1）利率形式\n\n\n浮动利率：浮动利率是在借贷期内可定期调整的利率。常常采用基本利率加成计算。\n通常将市场上信誉最好企业的借款利率或商业票据利率定为基本利率，并在此基础上加0.5至2个百分点作为浮动利率。到期按面值还本，平时按规定的付息期的浮动利率付息。\n\n\n固定利率：固定利率由国家规定，是在一定时期内不受社会平均利润率和资金供求变化所影响的一种利息率。\n\n\n最大利率：银行在设置利率时不能过高，必须在合法范围内，所以有限制\n\n\n最小利率：银行在设置利率时也不能过低，太低将无法正常盈利，所以也有限制\n\n\n2）利率形态\n\n\n正常利率：按照合同签订的利率。新核心系统叫分户级执行利率，老核心叫执行利率\n\n\n罚息利率：罚息是借款人在规定的日期未还款造成的逾期而交纳的罚金(也有个利率进行计算)。\n\n\n复利利率：是指在计算利息时，某一计息周期的利息是由本金加上先前周期所积累利息总额来计算的计息方式，也即通常所说的 利滚利。\n\n\n罚息的复利：将罚息作为利息计算的本金进行利滚利。\n\n\n复利的复利：利滚利滚利\n\n\n3）利率启用方式\n\n固定不变：与客户约定好不随人行浮动而浮动，这样利率称为固定利率\n立即生效：根据人行浮动立即生效，它只对浮动利率有效\n按指定周期自动生效：人行浮动后不马上生效，按照指定的周期自动生效，只对浮动利率有效\n下一计息周期生效：人行浮动后的下一周期生效，只对浮动利率有效\n\n4）计息天数\n基本月天数30天\n基本年天数可分：360，365，366\n4.多样的还款方式设置\n1）等额本金\n在还款期内把贷款数总额等分，每月偿还同等数额的本金和剩余贷款在该月所产生的利息，这样由于每月的还款本金额固定，而利息越来越少，借款人起初还款压力较大，但是随时间的推移每月还款数也越来越少。一般针对于个人贷款\n计算公式：\n每月还本付息金额 =（本金/还款月数）+（本金-累计已还本金）×月利率\n每月本金=总本金/还款月数\n每月利息=（本金-累计已还本金）×月利率\n还款总利息=（还款月数+1）×贷款额×月利率/2\n还款总额=（还款月数+1）×贷款额×月利率/2+ 贷款额\n注意：在等额本金法中，人们每月归还的本金额始终不变，利息随剩余本金的减少而减少，因而其每月还款额逐渐减少。\n2）等额本息（每月偿还相同数额）\n等额本息是指一种贷款的还款方式，指在还款期内，每月偿还同等数额的贷款(本金和利息)。\n等额本息和等额本金是不一样的概念，虽然刚开始还款时每月还款额可能会低于等额本金还款方式的额度，但是最终所还利息会高于等额本金还款方式，该方式经常被银行使用。\n计算公式：\n等额本息每月还款额=[贷款本金×月利率×（1+月利率）^还款月数]÷[（1+月利率）^还款月数－1]\n等额本息单期利息计算方法：（贷款金额月利率-每月还款额）（1+月利率）^(第n个月-1)+每月还款额\n1）等额本金和等额本息的差别\n练习题：计算贷款10万，年利率4.9，10年还清下的还款计划\n经验：在进行贷款利息计算的时候一定要注意精度问题，因为这往往决定着我们最后的帐正确与否。\nimport java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;public class WordText &#123;    /**     *等额本金还款计划算法，注意：计算公式中浮点数的精度一定要一致     * @param money 贷款本金     * @param l 贷款年利率     * @param time 贷款时长     * @param startTime 贷款开始时间     */    public static void averageCapital(double money, float l, int time, String startTime) throws ParseException &#123;//定义还款月数        int backNum = time * 12;//定义每期还款金额        double backMoney = 0;//定义已还本金        double backedMoney = 0;//定义月利率        double monthL = l / 12;//利息总额        double LSumMoney = 0;        System.out.println(&quot;还款期数\\t还款日期\\t\\t期初余额\\t还款\\t本金\\t利息\\t期末余额（剩余本金）\\t&quot;);        for (int i = 0; i &lt; backNum; i++) &#123;            //单期利息额            double lMoney = (money - backedMoney) * monthL;            LSumMoney += lMoney;            backMoney = (money / backNum) + lMoney;            //期初余额            double startMoney = money - backedMoney;            backedMoney += money / backNum;            startTime = subMonth(startTime);            System.out.println(i + 1 + &quot;\\t&quot; + startTime + &quot;\\t\\t&quot; + String.format(&quot;%.2f&quot;, startMoney) + &quot;\\t&quot; + String.format(&quot;%.2f&quot;, backMoney) + &quot;\\t&quot; +                    String.format(&quot;%.2f&quot;, money / backNum) + &quot;\\t&quot; + String.format(&quot;%.2f&quot;, lMoney) + &quot;\\t&quot; + String.format(&quot;%.2f&quot;, (money - backedMoney)));        &#125;        System.out.println(String.format(&quot;%.2f&quot;, LSumMoney));    &#125;    /**     *等额本息还款计划算法，注意：计算公式中浮点数的精度一定要一致     * @param money 贷款本金     * @param l 贷款年利率     * @param time 贷款时长     * @param startTime 贷款开始时间     */    public static void averageCapitalPlusInterest(double money, float l, int time, String startTime) throws ParseException &#123;//定义还款月数        int backNum = time * 12;//定义每期还款金额        double backMoney;//定义已还本金        double backedMoney = 0;//定义月利率        double monthL = l / 12;//利息总额        double LSumMoney = 0;        backMoney = (money * monthL) * Math.pow(1 + monthL, backNum) / (Math.pow(1 + monthL, backNum) - 1);//每期应还本里总额        System.out.println(backMoney);        System.out.println(&quot;还款期数\\t还款日期\\t\\t期初余额\\t还款\\t本金\\t利息\\t期末余额（剩余本金）\\t&quot;);        for (int i = 0; i &lt; backNum; i++) &#123;            //期初余额            double startMoney = money - backedMoney;            startTime = subMonth(startTime);            //单期利息            double liXi = (money * monthL - backMoney) * Math.pow(1 + monthL, i) + backMoney;            LSumMoney += liXi;            backedMoney += (backMoney - liXi);            System.out.println(i + 1 + &quot;\\t&quot; + startTime + &quot;\\t\\t&quot; + String.format(&quot;%.2f&quot;, startMoney) + &quot;\\t&quot; + String.format(&quot;%.2f&quot;, backMoney) + &quot;\\t&quot; +                    String.format(&quot;%.2f&quot;, backMoney - liXi) + &quot;\\t&quot; + String.format(&quot;%.2f&quot;, liXi) + &quot;\\t&quot; + String.format(&quot;%.2f&quot;, (money - backedMoney)));        &#125;        System.out.println(String.format(&quot;%.2f&quot;, LSumMoney));    &#125;    /****     * 传入具体日期 ，返回具体日期增加一个月。     * @param date 日期(2017-04-13)     * @return 2017-05-13     * @throws ParseException     */    public static String subMonth(String date) throws ParseException &#123;        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);        Date dt = sdf.parse(date);        Calendar rightNow = Calendar.getInstance();        rightNow.setTime(dt);        rightNow.add(Calendar.MONTH, 1);        Date dt1 = rightNow.getTime();        String reStr = sdf.format(dt1);        return reStr;    &#125;    /**     测试方法     **/    public static void main(String[] args) throws ParseException &#123;        averageCapital(1000000, (float) 0.049, 30, &quot;2021-7-19&quot;);        averageCapitalPlusInterest(1000000, (float) 0.049, 30, &quot;2021-7-19&quot;);    &#125;&#125;\n3）按频率付息，任意本金计划\n就是按照约定的还款时间每次只还利息就好了，如果经济宽裕的话可以还本金，支付宝蚂蚁借呗目前就有这种还款方式，说白了，意思就是先还利息，再还本金，你也可以提前归还本金，系统会自动计算出需要归还的利息和所有本金，因为是按时间计息，所以，提前还款只收取之前的利息，再不会收取任何费用，只要是利率不高的话，是很划算的一种还款方式！\n4）一次还本付息\n一次还本付息法是指借款人在贷款期内不是按月偿还本息，而是贷款到期后一次性归还本金和利息，又称为到期一次还本付息法。一次还本付息这种方式适合短期借款。这个还款方式个人和对公都可。\n5）按频率付息，一次还本\n这个还款方式个人和对公都可。\n6）组合还款\n这个对公办理。\n5.灵活的还款顺序设置\n小本小息，大本大息的还款方式不同。\n先横后竖小本小息，先竖后横大本大息。\n6.贷款状态\n贷款账户状态：N新建 , A活动 , C关闭, P到期未结清\n贷款核算状态：ZHC正常, YUQ逾期, FYJ/FY应计非应计, WRN核销 , TEN终止\n贷款核销是“呆账贷款核销”\n的简称，银行按规定将呆账贷款或贷款损失予以核销的一种制度。根据财政部《关于国家专业银行建立贷款呆账准备金的暂行规定》有关规定：呆账贷款额每笔5万元以下的，由地方级银行会同同级中央财政机构进行审批，呆账贷款额每笔5万元以上，10万元以下的，由省级银行会同同级中央财政机构进行审批;\n呆账贷款额每笔10万元以上的，由各专业银行总行根据下级行和省级中央财政机构的意见审批，报财政部备案。在具体执行中，审批金额有所调整。各银行和中央财政机构在贷款核销审批过程中要严格执行国家贷款核销有关规定，不得越权审批或违反有关规定进行审批，违者将追究其相应责任。\n7.核心系统贷款处理流程\n贷款开立到修改事项之后是什么操作？\n视具体情况而定\n还款计划是在贷款发放之后制订的吗？为什么？\n在系统中是这样的，还款计划在贷款发放后才可以生效。\n8.贷款模块业务功能概述\n1）贷款发放交易\n要想发放贷款，必须先进行贷款账户开立，然后根据贷款开立时选择的贷款产品从产品参数中继承大多数贷款属性，根据贷款特性增加个别属性。\n当产品属性支持单笔发放时，贷款账户开立的同时进行贷款的发放处理。此时贷款合同和借据的关系为一对一的关系，贷款账户与贷款借据的属性相同。\n当贷款合同与借据为一对多的关系时，系统支持贷款账户开立后可针对每一次贷款借据的发放在贷款发放交易处理，贷款借据的属性通过贷款账户的继承和柜员在贷款发放时的输入确定，贷款的核算以贷款借据为准。\n2）贷款变更\n3）贷款核销\n4）贷款报表\n5）银团贷款\n6）贷款回收\n7）贷款查询\n9.贷款业务功能\n1）线下贷款处理流程\n贷款开立后可以进行相应的变更。\n2）网贷处理流程\n10.贷款功能涉及的表\n账户协议信息表\n贷款合同附加信息表\n账户信息表\n账户附加信息表\n账户余额表\n贷款结算信息表\n账户利息信息表\n账户还款计划表\n账户还款计划明细表\n账户组合还款计划表\n交易流水表\n贷款发放表\n贴现表\n单据表\n收据表\n收据信息明细表\n计提流水表\n结息流水表\n","tags":["银行核心系统"]},{"title":"Docker安装以及验证","url":"/article/LinuxServer-docker-1-Docker%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E9%AA%8C%E8%AF%81/","content":"1.CentOS 8.0 安装docker\n1.1 执行安装命令\ncurl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun\n1.2.安装完成后，启动docker\n$ sudo systemctl start docker\n1.3.启动完成后进行验证\n$ sudo docker run hello-world\n1.4.添加镜像加速器\nsudo vim /etc/docker/daemon.json&#123;&quot;registry-mirrors&quot;: [&quot;https://n6syp70m.mirror.aliyuncs.com&quot;]&#125;\n1.5 重新启动docker\nsudo service docker restart\n2.卸载docker\n删除安装包\nyum remove docker-ce\n删除镜像，容器，配置文件\nrm -rf /var/lib/docker\n3.docker 常用命令\n查看docker中已经存在的镜像\ndocker image ls\n拉取镜像\n//pull后面的参数规则是软件名称:版本号docker image pull ubuntu:18.04\n从镜像仓库中查找镜像\ndocker search 镜像名称\n设置镜像标签\ndocker tag 860c279d2fec runoob/centos:dev\n删除镜像（删除镜像前确保该镜像的所有容器以及删除）\ndocker rmi 镜像名称\n从镜像来启动并进入容器\ndocker container run -it ubuntu:18.04 /bin/bash\n启动已经停止的容器\ndocker start id\n重启容器\ndocker restart 容器id\n启动容器后台运行\ndocker run -itd --name 容器名称 镜像名称 /bin/bash\n退出容器\nexit 停止容器并退出Ctrl + PQ 保持容器运行状态并退出\n查看正在运行的容器\ndocker container lsdocker ps\n查看所有容器\ndocker container ls -adocker ps -a\n停止并杀死容器\ndocker container stop ID //杀死容器docker container rm -f ID //删除容器\n进入容器\ndocker exec -it 容器id /bin/bash\n导入和导出容器\n导出容器到指定文件\ndocker export 容器id &gt; ubuntu.tar\n导入容器快照\ncat docker/name.tar | docker import - test/ubuntu:v1\n也可以通过指定URL或者某个目录导入\ndocker import http://example.com/examplimage.tgz example/imagerepo\n导出指定容器的日志\ndocker logs --since=&#x27;2023-06-08T17:00:00&#x27; --until=&#x27;2023-06-08T17:20:00&#x27; containerName &gt;&gt; db/0421.log\n","tags":["Docker"]},{"title":"docker日志清理","url":"/article/LinuxServer-docker-3-docker%E6%97%A5%E5%BF%97%E6%B8%85%E7%90%86/","content":"我们可能遇到服务器上磁盘发生占满的情况\n这时,我们可以执行：\ndu -h | sort -h\n我们会看到：\n88M     ./freeswtich/qwfreeswitch/sounds/old_test104M    ./freeswtich/qwfreeswitch/sounds138M    ./freeswtich/qwfreeswitch/docker/package/freeswitch/.git/objects138M    ./freeswtich/qwfreeswitch/docker/package/freeswitch/.git/objects/pack139M    ./freeswtich/qwfreeswitch/docker/package/freeswitch/.git152M    ./MRCPServer/asrbaidumrcp/.git/objects/d7153M    ./MRCPServer/asrbaidumrcp/.git153M    ./MRCPServer/asrbaidumrcp/.git/objects153M    ./MRCPServer/asrbaidumrcp/docker281M    ./freeswtich/qwfreeswitch/docker/package281M    ./freeswtich/qwfreeswitch/docker/package/freeswitch282M    ./freeswtich/qwfreeswitch/docker316M    ./MRCPServer/asrbaidumrcp394M    ./freeswtich/qwfreeswitch580M    ./glibc-2.28/build624M    ./freeswtich828M    ./glibc-2.28965M    ./MRCPServer3.0G    .[root@ecs-235046 ~]# \n然后可能会分析出是docker的日志占用的大部分空间,我们需要释放这些空间,但是又不能停止docker\n这时候,我们则需要这个命令：\ncat /dev/null &gt; 指定的日志文件-json.log\n这个命令有效,但是,每次都要手动的做,不免有些麻烦。\n于是，我们可以使用shell+cron来定时的清理那些占用空间的日志：\n我们先来学习下这个脚本：\n#!/bin/shecho &quot;======== docker containers logs file size ========&quot;  logs=$(find /var/lib/docker/containers/ -name *-json.log)  for log in $logs          do               ls -lh $log           done  \n这个脚本打印出所有容器每个日志占用的空间。\n下面学习下面脚本：\n我们可以使用下面的脚本来清理七天前的日志：\n新建脚本docker_log_clean.sh\n,内容如下：\n#!/bin/bash# 限定作用目录DOCKER_LOG_DIR=&quot;/var/lib/docker/containers&quot;# 时间限定DAYS_TO_KEEP=7# 限定文件后缀LOG_PREFIX=&quot;-json.log.*&quot;# 查找出最后修改时间超过7天的文件列表logs=$(find $DOCKER_LOG_DIR -name &quot;*$LOG_PREFIX&quot; -type f -mtime +$DAYS_TO_KEEP)for log in $logs          do            ls -lh $log             cat /dev/null &gt; $log          echo &quot;deleted $log&quot;        done  \n然后：\ncrontab -e\n在里面添加下面一行：\n0 0 * * * /bin/bash /path/to/docker-log-cleanup.sh\n这里的的 /path/to/docker-log-cleanup.sh 指的是脚本的绝对路径。\n也可以使用下面的脚本只保留5个日志文件：\n#!/bin/sh echo &quot;======== start clean docker containers logs ========&quot;  logs=$(find /var/lib/docker/containers/ -name *-json.log*)  for log in $logs  \t        do  \t\t\t\t\t\t        num=$&#123;log##*.&#125;\t\t\t\t\t\tif echo &quot;$num&quot; | grep -qE &#x27;^[0-9]+$&#x27; &amp;&amp; [ &quot;$num&quot; -gt 5 ]; then\t\t\t\t                 cat /dev/null &gt; $log \t\t\t\t\t        echo &quot;clean logs : $log&quot;\t\t\t\t\t\t\t\t\t\telse echo echo &quot;not clean&quot;\t\t\t\t\tfi\t\t\tdone  echo &quot;======== end clean docker containers logs ========&quot;\n","tags":["docker容器"]},{"title":"1.Linux入门命令和快捷键","url":"/article/LinuxServer-linux-1-Linux%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4-%E5%BF%AB%E6%8D%B7%E9%94%AE/","content":"1.常用命令\n1.1 创建一个名为file的文件\ntouch file\n1.2 cd 命令 进入指定文件夹\ncd /root\n1.3 pwd 命令 输出当前文件夹路径\npwd\n1.4 ls命令 输出当前文件夹中所有的文件列别奥\nls\n1.5 ll 命令 输出当前文件夹中所有文件详细信息\nll\n2.快捷键\nTab 命令补全快捷键\n这个快捷键可以让我们快速的输入指定文件名,命令等\nCloudResetPwdUpdateAgent  CloudrResetPwdAgent  bin  boot  dev  etc  home  lib  lib64  [root@ecs-235046 /]# cd ho// 这时按下Tab键, 会自动补全[root@ecs-235046 /]# cd home/\nCtrl+c 强制终止当前进程\n[root@ecs-235046 ~]# tail^C[root@ecs-235046 ~]# \nCtrl+d 退出连接终端\n[root@ecs-235046 ~]# logout连接断开\nCtrl+z 将当前程序放到后台执行，不结束进行退出，回到控制台\nfg 恢复到前台应用程序继续执行\n....../usr/share/cmake3/Help/variable/PROJECT_DESCRIPTION.rst/usr/share/cmake3/Help/variable/CMAKE_LANG_LINKER_PREFERENCE_PROPAGATES.rst^Z[1]+  Stopped                 find /[root@ecs-235046 ~]# \nCtrl+a 将光标移到输入行头部\nCtrl+e  将光标移到输入行尾部\nCtrl+k 删除从光标位置到行末的字符\n常用通配符(执行查找,删除等命令的时候有用)\n匹配0个或多个字符： *\n匹配任意一个字符： ？\n匹配列表中任意一个单一字符： [list]\n匹配列表之外的任意一个字符：[^list]\n匹配一个字符范围或数字范围：[c1-c2]\n匹配列表中范围的全部字符： {c1…c3}\n匹配列表中其中一个字符串：{string1,string2,…}\nmongodb常用命令：\n// 后台启动mongod,带账户验证mongod --fork -dbpath &#x27;/var/lib/mongodb&#x27; -logpath=/var/lib/mongodb/mongodb.log --auth\n","tags":["docker容器"]},{"title":"2.Linux用户及文件权限","url":"/article/LinuxServer-linux-2-Linux%E7%94%A8%E6%88%B7%E5%8F%8A%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/","content":"1.Linux用户权限管理\n在Linux系统中，多个用户可以登录一个主机进行使用，但是不同用户都有着自己的用户空间，\n他们在没有对方的允许的情况下不能访问对方的文件。\n1.1 用户权限常用命令\n\n\n\n命令格式\n描述\n\n\n\n\nwhoami\n查看当前用户名\n\n\nwho -d\n打印死掉的进程\n\n\nwho -q\n打印当前登录用户数及用户名\n\n\nwho -u\n打印当前登录用户登录信息\n\n\nsudo adduser muzhi\n新建用户muzhi\n\n\nsu -l muzhi\n切换到muzhi用户登录\n\n\ngroups muzhi\n查询用户所在用户组\n\n\nsudo usermod -G sudo muzhi\n将其他用户加入sudo用户组\n\n\nsudo deluser muzhi --remove-home\n删除用户\n\n\n\n2.Linux文件权限\n\n文件权限就是文件的访问控制权限，包括文件的类型，文件的可操作用户。\n2.1 常用命令\n\n\n\n命令格式\n描述\n\n\n\n\nls -s(简写 ll)\n列出本目录下文件的详细信息\n\n\nchmod xxx (0–无  1–可执行  2–可写  4–可读)\n修改文件权限\n\n\nls -a\n列出本目录下所有文件(包括隐藏文件)\n\n\nls -dl 目录名\n查看某一个目录的完整属性\n\n\nls -asSh\n显示当前目录下所有文件大小\n\n\nsudo chown 用户名称 目标文件名称\n变更文件所有者\n\n\nsudo chgrp 用户组名称 目标文件名称\n变更文件所属组\n\n\n\n[root@ecs-235046 study]# chown muzhi fiel [root@ecs-235046 study]# lltotal 0-rw-r--r-- 1 muzhi root 0 Jun  9 15:01 fiel[root@ecs-235046 study]# \n","tags":["docker容器"]},{"title":"3.Linux目录结构和文件操作","url":"/article/LinuxServer-linux-3-Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","content":"1.Linux系统中的文件组织目录结构\nLinux系统的文件组织遵循FHS标准：\nFHS定义了两层规范，\n第一层是，/ 下面的各个目录应该要放什么数据，例如/etc 应该放置设置文件，/bin与/sbin则应该放置可执行文件等。\n第二层是针对/usr及/var这两个目录的子目录来定义。例如/var/log放置系统日志文件，/usr/share放置共享数据文件等等。\nfhs-3.0.pdf (linuxfoundation.org)\n2.Linux中的绝对路径和相对路径\ncd 命令用来切换路径\n当前目录  .\n上一级目录 …\nhome目录 ~\n相对路径 cd …/\n绝对路径 cd /home/shiyanlou\n3.Linux系统中对文件的移动，复制，重命名,查阅\n新建空白文件 touch file\n新建空白目录 mkdir testdir\n创建多级目录 mkdir -p father/son\n复制文件到相同目录下且改名  cp filename filename1\n复制文件到指定文件夹下 cp filename dirname\n复制目录 cp -r filedir newdiername\n删除文件 rm test\n强制删除文件 rm -f test\n删除目录  rm -r dir\n强制删除目录 rm -rf dir\n移动文件到指定目录  mv file dir\n文件重命名 mv file newfile\n正序显示查看文件 cat file\n倒序显示查看文件内容  tac  file\n打印行号显示文件内容  nl file\n查阅文件 less file  (翻页查阅)\n只查看文件开始n行 head -n 100 file\n动态只查看文件最后几行  tail -n 10 -f file\n查看文件类型 file filename\n4.Linux文件编辑\n文件编辑命令 vim file\nI 插入  esc 退出插入模式  :wq 保存并退出\n这个需要学习的话，可以使用vimtutor命令进入学习界面\nvimtutor\n","tags":["docker容器"]},{"title":"1.Java进阶之文件操作入门","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-1-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%85%A5%E9%97%A8/","content":"1.我们为何要操作文件？\n首先,我们思考一个问题，在没学习JDBC之前，我们怎么将程序产生的数据持久化(存储)到硬盘/磁盘中呢？\n并且我们如何去读取硬盘中的文件呢？\n答案就是Java的文件操作机制和输入输出流机制，Java提供了丰富的API让我们能对文件进行操作，其中最基础的类就是File类。\n2.File类能干啥？\nFile类主要用来获取文件本身的一些信息，例如文件所在的目录、文件的大小(也可称为长度)或文件读写权限等，\n但不涉及对文件的读写操作，但是一些对文件读写操作是基于文件的。\n3.File类中的方法\n3.1构造方法\nFile(String filename);\n根据文件名构造File对象,其中，filename是文件名字，\n使用File(String filename)创建文件时，该文件被认为与当前应用程序在同一目录中。\nFile(String directoryPath,String filename);\n根据路径名称和文件名构造File对象，其中，filename是文件名字，directoryPath是文件的路径\nFile(File dir,String filename);\ndir为一个目录File对象，filename是文件名\n当我们顺利获取一个File对象时，我们可以调用其中的方法获取文件的相关信息。\n用法：\npublic static void fileStudy()&#123;    File file  = new File(&quot;麻子.txt&quot;);    File file1 = new File(&quot;E:/Personal/MyRepository/study&quot;,&quot;麻子.txt&quot;);    File dir = new File(&quot;E:/Personal/MyRepository/study&quot;);    File file2 = new File(dir,&quot;麻子.txt&quot;);    //获取文件的绝对路径    System.out.println(file.getAbsolutePath());    System.out.println(file1.getAbsolutePath());    System.out.println(dir.getAbsolutePath());    System.out.println(file2.getAbsolutePath());&#125;\n运行结果：\nfile 文件路径：E:\\Personal\\MyRepository\\study\\麻子.txtfile1 文件路径： E:\\Personal\\MyRepository\\study\\麻子.txtdir 文件路径： E:\\Personal\\MyRepository\\studyfile2 文件路径： E:\\Personal\\MyRepository\\study\\麻子.txtProcess finished with exit code 0\n3.2 其他方法\npublic boolean exists();\n判断文件是否存在,存在返回true, 不存在返回false\npublic static void existsStudy()&#123;    File file = new File(&quot;麻子.txt&quot;);    System.out.println(&quot;麻子.txt 文件是否存在： &quot;+file.exists());    File file1 = new File(&quot;四郎.txt&quot;);    System.out.println(&quot;四郎.txt 是否存在： &quot;+file1.exists());&#125;\n运行结果：\n麻子.txt 文件是否存在： true四郎.txt 是否存在： falseProcess finished with exit code 0\npublic String getName();\n获取文件的名称.\npublic static void getNameStudy()&#123;    File file = new File(&quot;麻子.txt&quot;);    System.out.println(&quot;麻子.txt文件名称： &quot;+file.getName());    File file1 = new File(&quot;四郎.txt&quot;);    System.out.println(&quot;四郎.txt 文件名称： &quot;+file1.getName());&#125;\npublic boolean canRead();\n判断文件是否可读,可读返回true,不可读返回false\npublic static void canReadStudy() &#123;    File file = new File(&quot;麻子.txt&quot;);    System.out.println(&quot;麻子.txt文件是否可读： &quot;+file.canRead());    File file1 = new File(&quot;四郎.txt&quot;);    System.out.println(&quot;四郎.txt是否可读： &quot;+file1.canRead());&#125;\npublic boolean canWrite();\n判断文件是否可被写入,可写入返回true,不可写入返回false\npublic static void canWriteStudy() &#123;    File file = new File(&quot;麻子.txt&quot;);    System.out.println(&quot;麻子.txt是否可写： &quot;+file.canWrite());    File file1 = new File(&quot;四郎.txt&quot;);    System.out.println(&quot;四郎.txt是否可写： &quot;+file1.canWrite());&#125;\npublic long length();\n获取文件长度（大小）\npublic static void lengthStudy() &#123;    File file = new File(&quot;麻子.txt&quot;);    System.out.println(&quot;麻子.txt文件大小： &quot;+file.length());    File file1 = new File(&quot;四郎.txt&quot;);    System.out.println(&quot;四郎.txt文件大小： &quot;+file1.length());&#125;\npublic String getAbsolutePath();\n获取文件的绝对路径。\npublic static void absolutePathStudy() &#123;    File file = new File(&quot;麻子.txt&quot;);    System.out.println(&quot;麻子.txt 文件绝对路径： &quot;+file.getAbsolutePath());    File file1 = new File(&quot;四郎.txt&quot;);    System.out.println(&quot;四郎.txt 文件绝对路径： &quot;+file1.getAbsolutePath());&#125;\npublic String getParent();\n获取文件的父目录字符串描述。\npublic static void parentStudy()&#123;    File file = new File(&quot;麻子.txt&quot;);    System.out.println(&quot;麻子.txt 文件父目录： &quot;+file.getParent());    File file1 = new File(&quot;四郎.txt&quot;);    System.out.println(&quot;四郎.txt 文件父目录： &quot;+file1.getParent());&#125;\npublic boolean isFile();\n判断文件是否是一个普通文件而非目录。\npublic static void isFileStudy()&#123;    File file = new File(&quot;麻子.txt&quot;);    System.out.println(&quot;麻子.txt 是否是文件： &quot;+file.isFile());    File file1 = new File(&quot;四郎.txt&quot;);    System.out.println(&quot;四郎.txt 是否是文件： &quot;+file1.isFile());&#125;\npublic boolean isDirectory();\n判断文件是否是一个目录。\npublic static void isDirectory()&#123;    File file = new File(&quot;麻子.txt&quot;);    System.out.println(&quot;麻子.txt是否是目录: &quot;+file.isDirectory());    File file1 = new File(&quot;四郎.txt&quot;);    System.out.println(&quot;四郎.txt是否是目录： &quot;+file1.isDirectory());&#125;\npublic boolean isHidden();\n判断文件是否是隐藏文件。\npublic static void isHidden()&#123;    File file = new File(&quot;麻子.txt&quot;);    System.out.println(&quot;麻子.txt是否是隐藏文件： &quot;+file.isHidden());    File file1 = new File(&quot;四郎.txt&quot;);    System.out.println(&quot;四郎.txt 是否是隐藏文件： &quot;+file1.isHidden());&#125;\npublic long lastModified();\n获取文件最后修改的时间戳。(时间是从1970年午夜至文件最后修改时刻的毫秒数）。\npublic static void lastModifiedStudy()&#123;    File file = new File(&quot;麻子.txt&quot;);    System.out.println(&quot;麻子.txt最后修改时间： &quot;+file.lastModified());    File file1 = new File(&quot;四郎.txt&quot;);    System.out.println(&quot;四郎.txt 件最后修改时间： &quot;+file1.lastModified());&#125;\n运行结果：\n麻子.txt最后修改时间： 1667878191306四郎.txt 件最后修改时间： 0Process finished with exit code 0\npublic boolean mkdir();\nFile对象可以调用此方法创建一个目录，创建成功返回true。\npublic static void mkdirStudy()&#123;    File file1 = new File(&quot;FileStudy&quot;);    if(!file1.exists())&#123;        boolean sus = file1.mkdir();        if(sus)&#123;            System.out.println(&quot;FileStudy 目录创建成功&quot;);        &#125;    &#125;&#125;\npublic String[] list();\n如果File对象是一个目录，那么此对象可以调用该方法以字符串的形式返回目录下的文件和子目录描述。\npublic static void listStudy()&#123;    File file = new File(&quot;Java基础学习&quot;);    String[] dir = file.list();    assert dir != null;    for(String d:dir)&#123;        System.out.println(&quot;Java基础学习子目录： &quot;+d);    &#125;    String[] dir1 = file.list(new FilenameFilter() &#123;        @Override        public boolean accept(File dir, String name) &#123;            if(name.contains(&quot;tar&quot;))               return true;            return false;        &#125;    &#125;);    assert dir1 != null;    for(String d2:dir1)&#123;        System.out.println(&quot;Java基础学习子目录中名称包含 tar 的目录：&quot;+d2);    &#125;&#125;\n运行结果：\nJava基础学习子目录： Java基础学习.imlJava基础学习子目录： pom.xmlJava基础学习子目录： resourceJava基础学习子目录： srcJava基础学习子目录： targetJava基础学习子目录中名称包含 tar 的目录：targetProcess finished with exit code 0\npublic File[] listFiles();\n如果File对象关联的文件是一个目录，那么此对象可以调用该方法以File对象的形式返回目录下的文件和子目录。\npublic static void listFilesStudy()&#123;    File file = new File(&quot;Java基础学习&quot;);    File[] files = file.listFiles();    assert files != null;    for(File file1:files)&#123;        System.out.println(&quot;Java基础学习子目录： &quot;+file1.getName());    &#125;    File[] dir1 = file.listFiles(new FilenameFilter() &#123;        @Override        public boolean accept(File dir, String name) &#123;            if(name.contains(&quot;tar&quot;))                return true;            return false;        &#125;    &#125;);    assert dir1 != null;    for(File d2:dir1)&#123;        System.out.println(&quot;Java基础学习子目录中名称包含 tar 的目录：&quot;+d2.getName());    &#125;&#125;\n运行结果：\nJava基础学习子目录： Java基础学习.imlJava基础学习子目录： pom.xmlJava基础学习子目录： resourceJava基础学习子目录： srcJava基础学习子目录： targetJava基础学习子目录中名称包含 tar 的目录：targetProcess finished with exit code 0\npublic String[] list(FilenameFilter obj);\n该方法用字符串的形式返回目录下的指定类型的所有文件。\n参数FilenameFilter是一个接口，该接口有一个方法：\npublic boolean accept(File dir,String name);\n当这个方法返回true时，list方法就将name文件存放到返回的数组中。\npublic static void listStudy()&#123;    File file = new File(&quot;Java基础学习&quot;);    String[] dir = file.list();    assert dir != null;    for(String d:dir)&#123;        System.out.println(&quot;Java基础学习子目录： &quot;+d);    &#125;    String[] dir1 = file.list(new FilenameFilter() &#123;        @Override        public boolean accept(File dir, String name) &#123;            if(name.contains(&quot;tar&quot;))               return true;            return false;        &#125;    &#125;);    assert dir1 != null;    for(String d2:dir1)&#123;        System.out.println(&quot;Java基础学习子目录中名称包含 tar 的目录：&quot;+d2);    &#125;&#125;\npublic File[] listFiles(FilenameFilter obj);\n此方法用File对象返回目录下指定类型的所有文件。\npublic static void listFilesStudy()&#123;    File file = new File(&quot;Java基础学习&quot;);    File[] files = file.listFiles();    assert files != null;    for(File file1:files)&#123;        System.out.println(&quot;Java基础学习子目录： &quot;+file1.getName());    &#125;    File[] dir1 = file.listFiles(new FilenameFilter() &#123;        @Override        public boolean accept(File dir, String name) &#123;            if(name.contains(&quot;tar&quot;))                return true;            return false;        &#125;    &#125;);    assert dir1 != null;    for(File d2:dir1)&#123;        System.out.println(&quot;Java基础学习子目录中名称包含 tar 的目录：&quot;+d2.getName());    &#125;&#125;\npublic boolean createNewFile();\n此方法可以创建一个文件。\npublic static void createNewFileStudy() throws IOException &#123;    File file = new File(&quot;四郎.txt&quot;);    if(!file.exists())&#123;        boolean sus = file.createNewFile();        if(sus) System.out.println(&quot;四郎.txt 文件创建完成！！&quot;);    &#125;&#125;\npublic boolean detele();\n此方法为删除一个文件的方法。\npublic static void deleteStudy()&#123;    File file = new File(&quot;四郎.txt&quot;);    boolean sus = file.delete();    if(sus) System.out.println(&quot;四郎.txt 文件删除完成！！&quot;);&#125;\n完整代码地址：\nJava基础学习/src/main/java/Progress/exa01 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n如果想动手做点东西，可以参考Java动手做一做之文件编程专栏：\nJava动手做一做之文件编程\n","tags":["Java进阶"]},{"title":"2.1 Java读文件之InputStream学习","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-2-1-Java%E8%AF%BB%E6%96%87%E4%BB%B6%E4%B9%8BInputStream%E5%AD%A6%E4%B9%A0/","content":"1.什么是InputStream（输入流）？\n在JavaAPI中，可以从字节序列来源地读入一个字节序列的对象称为输入流。\n字节序列的来源地可以是文件，也可以是网络，还可以是内存块等等。\n输入流根据每次读取的字节数量的不同被分为字节输入流和字符输入流。\n字节输入流每次都是读取一个字节的，而字符输入流每次读入都是根据基于两字节的字符为单位读取的。\n2.JDK中对InputStream的定义\n在JDK中，InputStream是一个抽象类，其主要方法定义如下：\n\n\n\n方法定义\n返回值描述\n方法描述\n\n\n\n\nabstract int read()\n返回的是读入的字节asc码（-1~225）\n当读取完毕时，返回-1\n\n\nint read(byte b[])\n将源中的字节信息填充到b中\n当填充完毕时，返回实际填充数\n\n\nint read(byte b[],int off,int len)\n将b中指定位置填充源中的字节\n当填充完毕时，返回实际填充数\n\n\n\n这个类的主要能力定义就是从文件或网络或某处读取数据到程序中。\n这个某处我们称之为源，而根据这个源的不同,JDK实现出了不同的具体的实现类来让我们方便使用。\n2.1 使用FileInputStream读取文件\n下面使用它的一个实现类FileInputStream读取文件\nFileInputStream顾名思义，它是源为文件的字节输入流。\n2.1.1 read() 使用实例\n麻子.txt 内容如下：\n姓名: 张麻子性别： 男年龄: 28自我评价： 好好啊好好好哈大学成绩：A A A毕业院校: 黄埔军校获得证书：教师资格证, 教官证人生格言: 公平，公平，还是tm的公平专业：打劫专业\n下面使用FileInputStream的read方法读取该文件\n/** * FileInputStream实例 * @throws IOException */public static void fileInputStreamStudy() throws IOException &#123;    InputStream inputStream = new FileInputStream(&quot;麻子.txt&quot;);    int n;    while ((n=inputStream.read())!=-1)&#123;        System.out.print((char)n);    &#125;&#125;\n运行结果：\nå§å: å¼ éº»å­æ§å«ï¼ ç·å¹´é¾: 28èªæè¯ä»·ï¼ å¥½å¥½åå¥½å¥½å¥½åå¤§å­¦æç»©ï¼A A Aæ¯ä¸é¢æ ¡: é»ååæ ¡è·å¾è¯ä¹¦ï¼æå¸èµæ ¼è¯, æå®è¯äººçæ ¼è¨: å¬å¹³ï¼å¬å¹³ï¼è¿æ¯tmçå¬å¹³ä¸ä¸ï¼æå«ä¸ä¸Process finished with exit code 0\n上面的测试，每次读取都是读取的一个字节，所以后面的中文是可能无法正确显示的，因为中文为两个字节一组.\n2.1.2 read(byte[] b)使用实例\n此方法可以一次性读取指定数量(b的大小)的字节数据填充到参数b中。\npublic static void readByteStudy() throws IOException &#123;    InputStream inputStream = new FileInputStream(&quot;麻子.txt&quot;);    byte[] a = new byte[1000];    System.out.println(inputStream.read(a));    for (byte n:a)&#123;        System.out.print((char)n);    &#125;&#125;\n运行结果：\n250￥ﾧﾓ￥ﾐﾍ: ￥ﾼﾠ￩ﾺﾻ￥ﾭﾐ￦ﾀﾧ￥ﾈﾫ￯ﾼﾚ ￧ﾔﾷ￥ﾹﾴ￩ﾾﾄ: 28￨ﾇﾪ￦ﾈﾑ￨ﾯﾄ￤ﾻﾷ￯ﾼﾚ ￥ﾥﾽ￥ﾥﾽ￥ﾕﾊ￥ﾥﾽ￥ﾥﾽ￥ﾥﾽ￥ﾓﾈ￥ﾤﾧ￥ﾭﾦ￦ﾈﾐ￧ﾻﾩ￯ﾼﾚA A A￦ﾯﾕ￤ﾸﾚ￩ﾙﾢ￦ﾠﾡ: ￩ﾻﾄ￥ﾟﾔ￥ﾆﾛ￦ﾠﾡ￨ﾎﾷ￥ﾾﾗ￨ﾯﾁ￤ﾹﾦ￯ﾼﾚ￦ﾕﾙ￥ﾸﾈ￨ﾵﾄ￦ﾠﾼ￨ﾯﾁ, ￦ﾕﾙ￥ﾮﾘ￨ﾯﾁ￤ﾺﾺ￧ﾔﾟ￦ﾠﾼ￨ﾨﾀ: ￥ﾅﾬ￥ﾹﾳ￯ﾼﾌ￥ﾅﾬ￥ﾹﾳ￯ﾼﾌ￨﾿ﾘ￦ﾘﾯtm￧ﾚﾄ￥ﾅﾬ￥ﾹﾳ￤ﾸﾓ￤ﾸﾚ￯ﾼﾚ￦ﾉﾓ￥ﾊﾫ￤ﾸﾓ￤ﾸﾚ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Process finished with exit code 0\n2.1.3 read(byte[] b , int off,int len)\n此方法可以一次性读取指定数量(len)的字节数据填充到参数b中,且b的开始索引位置是off\npublic static void readByteLengthStudy() throws IOException &#123;    InputStream inputStream = new FileInputStream(&quot;麻子.txt&quot;);    byte[] a = new byte[1000];    System.out.println(inputStream.read(a,100,100));    for (byte n:a)&#123;        System.out.print((char)n);    &#125;&#125;\n运行结果\n100                                                                                                    ￥ﾧﾓ￥ﾐﾍ: ￥ﾼﾠ￩ﾺﾻ￥ﾭﾐ￦ﾀﾧ￥ﾈﾫ￯ﾼﾚ ￧ﾔﾷ￥ﾹﾴ￩ﾾﾄ: 28￨ﾇﾪ￦ﾈﾑ￨ﾯﾄ￤ﾻﾷ￯ﾼﾚ ￥ﾥﾽ￥ﾥﾽ￥ﾕﾊ￥ﾥﾽ￥ﾥﾽ￥ﾥﾽ￥ﾓﾈ￥ﾤﾧ￥ﾭﾦ￦ﾈﾐ￧ﾻﾩ￯ﾼﾚ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Process finished with exit code 0\n2.2 其他方法学习\n2.2.1 skip(long n) 跳过源中指定字节数进行读取\n/** * skip可以跳过源中一定数量的字节 * @throws IOException */public static void skipStudy() throws IOException &#123;        InputStream inputStream = new FileInputStream(&quot;麻子.txt&quot;);        System.out.println(&quot;跳过前100个字节： &quot;+inputStream.skip(100));        int n;        while ((n=inputStream.read())!=-1)&#123;        System.out.print((char)n);        &#125;&#125;\n运行结果：\n跳过前100个字节： 100A A Aæ¯ä¸é¢æ ¡: é»ååæ ¡è·å¾è¯ä¹¦ï¼æå¸èµæ ¼è¯, æå®è¯äººçæ ¼è¨: å¬å¹³ï¼å¬å¹³ï¼è¿æ¯tmçå¬å¹³ä¸ä¸ï¼æå«ä¸ä¸Process finished with exit code 0\n2.2.2 available() 预估剩余未读取的字节数量\n/** * available可以预估剩余未读取的字节估计数 * @throws IOException */public static void availableStudy() throws IOException &#123;        InputStream inputStream = new FileInputStream(&quot;麻子.txt&quot;);        int n = 100;        int ch;        while ((ch=inputStream.read())!=-1&amp;&amp;n&gt;0)&#123;        n--;        System.out.print((char)ch);        &#125;        System.out.println(&quot;还剩的未读的字节数：&quot;+ inputStream.available());&#125;\n运行结果：\nå§å: å¼ éº»å­æ§å«ï¼ ç·å¹´é¾: 28èªæè¯ä»·ï¼ å¥½å¥½åå¥½å¥½å¥½åå¤§å­¦æç»©ï¼还剩的未读的字节数：149Process finished with exit code 0\n2.2.3 mark(int readlimit) 标记重读点，并设置重读点范围（和缓冲区相关）\n其中readlimit是在标记位置失效之前可以读取的最大字节限制,设置了它后,\n只能在读取标记点后readlimit的过程中调用reset方法进行重置,如果超过了这个范围,reset就会调用失败。\n2.2.4 reset() 将流的游标重置为重读点\nclass Test &#123;    /**     * mark在JAVA中的实现是和缓冲区相关的。只要缓冲区够大，mark后读取的数据没有超出缓冲区的大小，mark标记就不会失效。     * 如果不够大，mark后又读取了大量的数据，导致缓冲区更新，原来标记的位置自然找不到了。     * 因此，mark后读取多少字节才失效，并不完全由readlimit参数确定，也和BufferedInputStream类的缓冲区大小有关。     * 如果BufferedInputStream类的缓冲区大小大于readlimit，在mark以后只有读取超过缓冲区大小的数据，mark标记才会失效。     * @throws IOException     */    public static void markStudy() throws IOException &#123;        InputStream inputStream = new BufferedInputStream(new FileInputStream(&quot;麻子.txt&quot;),100);        int n;        // 这里100可以重置, 101却重置失败        int num = 100;        //这里的readLimit和实际情况相关，        // 如果BufferedInputStream类的缓冲区大小大于readlimit，在mark以后只有读取超过缓冲区大小的数据，mark标记才会失效。        inputStream.mark(10);        while ((n=inputStream.read())!=-1&amp;&amp;num&gt;1)&#123;            num--;            System.out.print((char) n);        &#125;        inputStream.reset();        System.out.println();        System.out.println(&quot;调用reset 重新读取&quot;);        while ((n=inputStream.read())!=-1)&#123;            System.out.print((char)n);        &#125;    &#125;&#125;\n运行结果：\nå§å: å¼ éº»å­æ§å«ï¼ ç·å¹´é¾: 28èªæè¯ä»·ï¼ å¥½å¥½åå¥½å¥½å¥½åå¤§å­¦æç»©ï¼调用reset 重新读取å§å: å¼ éº»å­æ§å«ï¼ ç·å¹´é¾: 28èªæè¯ä»·ï¼ å¥½å¥½åå¥½å¥½å¥½åå¤§å­¦æç»©ï¼A A Aæ¯ä¸é¢æ ¡: é»ååæ ¡è·å¾è¯ä¹¦ï¼æå¸èµæ ¼è¯, æå®è¯äººçæ ¼è¨: å¬å¹³ï¼å¬å¹³ï¼è¿æ¯tmçå¬å¹³ä¸ä¸ï¼æå«ä¸ä¸Process finished with exit code 0\n2.2.5 markSupported() 钩子方法，供实现类使用，如果实现类支持mark,reset将其实现返回true\nInputStream默认为false\npublic boolean markSupported() &#123;    return false;&#125;\nJava基础学习/src/main/java/Progress/exa20 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"2.2 Java写文件之OutputStream学习","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-2-2-Java%E5%86%99%E6%96%87%E4%BB%B6%E4%B9%8BOutputStream%E5%AD%A6%E4%B9%A0/","content":"1.什么是OutputStream？（输出流）\n在JavaAPI中，将可以向目的地写入一个字节序列的对象称为输出流对象。\n字节序列的来源地可以是文件，也可以是网络，还可以是内存块等等。\n输出流根据每次写出的字节数量的不同分为字节输出流和字符输出流。\n字节输出流每次都是写出一个字节的，而字符输出流每次写出都是根据基于两字节的字符为单位写出的。\n2.使用FileOutputStream写出文件\n在outputStream中的关键常用的方法是：write方法。\n2.1 void write(int b) 向目的地写入一个字节\n使用示例：\nclass Test&#123;    /**     * 每次写入单个字节     * @throws IOException     */    public static void writeStudy() throws IOException &#123;        OutputStream outputStream = new FileOutputStream(&quot;四郎.txt&quot;);        String str = &quot;我是四郎&quot;;        byte[] bytes = str.getBytes(StandardCharsets.UTF_8);        //这里循环调用write进行写出操作        for (byte b:bytes)&#123;            outputStream.write(b);        &#125;        System.out.println(&quot;成功写入,请检查是否生成了文件： 四郎.txt &quot;);    &#125;&#125;\n运行结果：\n成功写入,请检查是否生成了文件： 四郎.txt Process finished with exit code 0\n2.2 void write(byte b[]) 向目的地写入多个字节\n这个方法一次向目的地写入多个字节。\nclass Test &#123;    /**     * 一次写入多个字节     * @throws IOException     */    public static void writeBytesStudy() throws IOException &#123;        OutputStream outputStream = new FileOutputStream(&quot;四郎.txt&quot;);        String str = &quot;我是四郎&quot;;        byte[] bytes = str.getBytes(StandardCharsets.UTF_8);        outputStream.write(bytes);        System.out.println(&quot;成功写入,请检查是否生成了文件： 四郎.txt &quot;);    &#125;&#125;\n运行结果：\n成功写入,请检查是否生成了文件： 四郎.txt Process finished with exit code 0\n2.3 void write(byte b[], int off, int len) 向目的地写入指定的多个字节\n一次性写入字节数组b中指定范围的数据到目的地\nclass Test &#123;    /**     * 从指定字节数组中选一部分进行写入     * @throws IOException     */    public static void writeBytesLenStudy() throws IOException &#123;        OutputStream outputStream = new FileOutputStream(&quot;四郎.txt&quot;);        String str = &quot;我是四郎&quot;;        byte[] bytes = str.getBytes(StandardCharsets.UTF_8);        outputStream.write(bytes,2,2);        System.out.println(&quot;成功写入,请检查是否生成了文件： 四郎.txt &quot;);    &#125;&#125;\n运行结果：\n成功写入,请检查是否生成了文件： 四郎.txt Process finished with exit code 0\n生成的文件内容如下：\n��\n2.4 void flush() 如果使用的是缓冲流，需要调用这个方法一次写出\n对于缓冲输出流，它的write方法并不会立即向磁盘中写入数据，而需要缓存满了或者调用flush方法立即写入\nclass Test &#123;    /**     * 对于缓冲输出流，它的write方法并不会立即向磁盘中写入数据，     * 而需要缓存满了或者调用flush方法立即写入     * @throws IOException     */    public static void flushStudy() throws IOException &#123;        OutputStream outputStream = new BufferedOutputStream(new FileOutputStream(&quot;四郎.txt&quot;));        String str = &quot;我是四郎&quot;;        byte[] bytes = str.getBytes(StandardCharsets.UTF_8);        outputStream.write(bytes);        outputStream.flush();        System.out.println(&quot;成功写入,请检查是否生成了文件： 四郎.txt &quot;);    &#125;&#125;\n运行结果：\n成功写入,请检查是否生成了文件： 四郎.txt Process finished with exit code 0\n生成的文件内容如下：\n我是四郎\n代码地址：Java基础学习/src/main/java/Progress/exa20 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"3.文件读写：使用IO流的步骤","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-3-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%EF%BC%9A%E4%BD%BF%E7%94%A8IO%E6%B5%81%E7%9A%84%E6%AD%A5%E9%AA%A4/","content":"1.使用输入流的步骤\n1.1.使用输入流的4个基本步骤\n\n步骤1：设定输入流的源。(创建File对象或路径)\n步骤2：创建指向源的输入流。（创建指向 File对象|文件路径 的流对象(InputStream)）\n步骤3：让输入流读取源中的数据。（调用InputStream的read方法）\n步骤4：关闭输入流。（调用InputStream的close方法）\n\n1.2.具体编码（以FileInputStream为例）\n第一,二步的实现\nFileInputStream(String name);\n使用给定的文件名name创建一个FileInputStream流。其中name指向的文件与源代码文件所在的目录是并列关系\nFileInputStream(File file);\n使用File对象创建一个输入流。\n说明：上述两种方法中的参数name和file指定的文件称为输入流的源，输入流的作用是打开了一个到达文件的通道\n用法如下：\ntry&#123; FileInputStream in = new FileInputStream(&quot;hello.txt&quot;); &#125;catch(IOException e)&#123; System.out.println(&quot;File read error:&quot;+e);&#125;\n(第二种构造方法类似于上述)\ntry&#123;    File file=new File(&quot;hello.txt&quot;);    FileInputStream in=new FileInputStream(file);&#125;catch(IOException e)&#123;    System.out.println(&quot;File read error:&quot;+e);&#125;\n第三步：让输入流读取源中的数据：通过使用read方法实现\nint read();\n该方法从源中读取单个字节的数据，返回0~225之间的一个整数，如果未读出字节就返回-1，每调用一次，读取游标向后移动一位。\nint read(byte b[]);\n该方法从源中试图读取b.length个字节到字节数组b中，返回实际的读取字节数目。如果到达文件的末尾则返回-1.\nint read(byte b[] ,int off,int len);\n该方法从源中试图读取len个字节到字节数组b中，并返回实际读取的字节数目。参数off指定从字节数组的某个位置开始存放读取的数据。如果到达文件的末尾，则返回-1.\n第四步：关闭流\nclose();\n此方法为关闭流的方法。\n注意：FileInputStream按顺序地读取文件，只要不关闭流，每次调用read方法就顺序地读取源中其余的内容直到源的末尾或被关闭。\n1.3具体实例\n/** * 学习使用文件字节输入流的步骤 */public static void useDemo() throws IOException &#123;    //1.创建文件源对象    File file = new File(&quot;麻子.txt&quot;);    //2.创建文件字节输入流对象并指向文件源对象    InputStream fileStream = new FileInputStream(file);    //3.让输入流读取源中的数据    int n;    while ((n=fileStream.read())!=-1)&#123;        System.out.print((char)n);    &#125;    //4.读取完毕，调用close方法关闭流，释放系统资源    fileStream.close();&#125;\n运行结果：(回想下这里为什么会出现乱码？)\nå§å: å¼ éº»å­æ§å«ï¼ ç·å¹´é¾: 28èªæè¯ä»·ï¼ å¥½å¥½åå¥½å¥½å¥½åå¤§å­¦æç»©ï¼A A Aæ¯ä¸é¢æ ¡: é»ååæ ¡è·å¾è¯ä¹¦ï¼æå¸èµæ ¼è¯, æå®è¯äººçæ ¼è¨: å¬å¹³ï¼å¬å¹³ï¼è¿æ¯tmçå¬å¹³ä¸ä¸ï¼æå«ä¸ä¸Process finished with exit code 0\n2.输出流使用步骤\n2.1.使用输出流的基本步骤\n\n步骤1：给出输出流的目的地。（创建file对象）\n步骤2：创建指向目的地的输出流。（创建输出流的对象指向file对象）\n步骤3：让输出流把数据写入到目的地。（调用write方法）\n步骤4：关闭输出流。（调用close方法）\n\n2.2.具体编码（以FileOutputStream为例）\n1.给出输出流的目的地\n一般目的地为File对象或String对象指定路径的文件。\n2.创建指向目的地的输出流\n我们可以使用FileOutputStream类具有刷新功能的构造方法创建指向文件的输出流：\nFileOutputStream(String name);\n此方法使用给定的文件名name创建FileOutputStream流。其中name指向的文件与源代码文件所在的目录是并列关系\nFileOutputStream(File file);\n此方法使用File对象创建FileOutputStream流。\n说明：上述两种方法中的参数name和file指定的文件称为输出流的目的地，输出流的作用是打开了一个到达文件的通道\n3.使用输出流写字节\n需要使用的方法：\nvoid write(int n);\n该方法向目的地写入单个字节。\nvoid write(byte b[]);\n该方法向目的地写入一个字节数组。\nvoid write(byte b[],int off,int len);\n该方法给定字节数组中起始于偏移量off处取len个字节写到目的地。\n4.关闭输出流。\nvoid close();\n注意：FileOutputStream流顺序地写入文件，只要不关闭流，每次调用write方法就顺序地向目的地写入内容，直到流被关闭\n2.3 具体实例\npublic static void useDemo() throws IOException &#123;    //创建目的地    File file = new File(&quot;四郎.txt&quot;);    //创建指向目的地的输出流    OutputStream outputStream = new FileOutputStream(file);    //准备要写的数据    String str = &quot;大家好，我是四郎，我喜欢麻子&quot;;    //调用write方法进行写入    outputStream.write(str.getBytes(StandardCharsets.UTF_8));    //调用close方法关闭流    outputStream.close();&#125;\n生成的文件 四郎.txt的内容\n大家好，我是四郎，我喜欢麻子\n代码地址：\nJava基础学习/src/main/java/Progress/exa21 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"4.文件读写-字节流","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-4-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%EF%BC%9A%E5%AD%97%E8%8A%82%E6%B5%81/","content":"1.什么是字节流\n字节流最大的特点是，每次调用read或write读入或写出的数据是以字节为单位的，而有的字符需要两个字节去存储，\n所以字节流读取数据会发生读到的数据不准确的情况。(就会看到乱码的效果)\n在Java中的字节流的类命名一般是以Stream结尾的,比如FileInputStream.\n1.1 字节数组流\n输入输出流的源 和 目的地除了可以是“文件”（硬盘）外，还可以是计算机内存，我们也可以使用数组流来将数据输入输出到内存。\n字节数组流就是用来将内存中的数据输入到程序中,或者将程序的数据输出到内存中去的字节流。\n1.1.1 ByteArrayInputStream 字节数组输入流\nByteArrayInputStream是输入流InputStream的一种实现，它的源只能是字节数组byte[]，它支持mark。\n构造方法\nByteArrayInputStream(byte[]  buf);\n此构造方法的字节数组流的源是参数buf指定的数组的全部字节单元。\nByteArrayInputStream(byte[]  buf ,int offset,int length);\n此方法构造的字节数组流的源是buf指定的数组从offset处按顺序取length个字节单元。\n常用方法\npublic int read();\n该方法可以顺序地从源中读取一个字节，返回读出的字节值。\npublic int read(byte[] b,int off,int len);\n该方法可以顺序地从源中读出参数len指定的字节数，并将读出的字节存放在参数b指定的数组中，参数off指定数组b读出字节的起始位置，返回实际读出的字节个数，若未读出字节read方法返回-1.\n使用示例：\npublic static void readStudy()&#123;    //定义字节数组输入流的源    byte[] bytes = &quot;我是四郎&quot;.getBytes(StandardCharsets.UTF_8);    //根据源创建字节数组输入流    ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);    //读取源bytes中的数据    int n;    while ((n=inputStream.read())!=-1)&#123;        System.out.print((char)n);    &#125;&#125;\n运行结果：\nææ¯åéProcess finished with exit code 0\n1.1.2 ByteArrayOutputStream 字节数组输出流\nByteArrayOutputStream是输出流的一种实现，它的目的地只能是字节数组byte[]，它支持mark。\n构造方法\nByteArrayOutputStream();\n该方法构造的字节数组输出空间指向一个默认大小为32字节的缓冲区，若输出流向缓冲区写入的字节个数大于缓冲区时，缓冲区的容量会自动增加。\nByteArrayOutputStream(int size);\n此方法构造的字节数组输出流指向的缓冲区的初始大小由参数size指定，若输出流向缓冲区写入的字节个数大于缓冲区时，缓冲区的容量会自动的增加。\n常用方法\npublic void write(int b);\n字节数组输出流可调用该方法顺序地向缓冲区写入一个字节。\npublic void write(byte[] b, int off, int len);\n该方法可以将参数b中指定的len个字节顺序地写入缓冲区，参数off指定从b中写出的字节的起始位置。\npublic byte[] toByteArray();\n该方法可以返回输出流写入到缓冲区的全部字节，通过它我们可以获取写出的数据。\n使用示例\npublic static void toByteArrayStudy() throws IOException &#123;    byte[] result;    byte[] bytes = &quot;我是四郎&quot;.getBytes(StandardCharsets.UTF_8);    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();    outputStream.write(bytes);    result = outputStream.toByteArray();    for (byte a:bytes)&#123;        System.out.print(a);    &#125;    System.out.println();    for (byte b:result)&#123;        System.out.print(b);    &#125;&#125;\n运行结果：\n-26-120-111-26-104-81-27-101-101-23-125-114-26-120-111-26-104-81-27-101-101-23-125-114Process finished with exit code 0\n1.2 字节数据流\n数据流能让我们读取或写出指定类型的数据，它是普通字节流的一种增强。\n它可以有其他类型的输入流作为构造函数的参数进行构造。\n1.2.1 DataInputStream 数据输入流\n由DataInputStream类创建的对象称为数据输入流。\n它们允许程序按着机器无关的风格读取java原始数据，也就是说，当读取一个数值时，不必再关心这个数值应当是多少字节。\n它算是对其他字节输入流的一种增强，但是也有一定的局限，比如用它读取readChar只能读取编码为UTF-16的文件，\n读取其他文件将会乱码。\n构造方法\nDataInputStream(InputStream in);\n此构造方法创建的数据输入流指向一个由参数in指定的底层输入流。\n常用方法\nclose();关闭流。\nreadBoolean();读取一个布尔值。\nreadByte();读取一个字节。\nreadChar();读取一个字符。\nreadDouble();读取一个双精度浮点值。\nreadFloat();读取一个单精度浮点值。\nreadInt();读取一个整型值。\nreadLong();读取一个长整型值。\nreadShort();读取一个短整型值。\nreadUnsignedByte();读取一个无符号字节。\nreadUnsignedShort();读取一个无符号短整型值。\nreadUTF();读取一个UTF字符串。\n使用实例：\npublic static void main(String[] args) throws IOException &#123;    // 将文件输入流作为参数构造数据输入流    DataInputStream inputStream = new DataInputStream(new FileInputStream(&quot;麻子.txt&quot;));    StringBuilder builder = new StringBuilder();    // 从文件读数据    while(true)&#123;        try&#123;           builder.append(new Character(inputStream.readChar()));        &#125;catch (Exception e)&#123;            inputStream.close();            break;        &#125;    &#125;    System.out.println(builder.toString());&#125;\n运行结果：\n鏥邍㨠ꃩ못逍૦肧꯯벚⃧钷ഊ듩뺄㨠㈸ഊꫦ袑蓤뮷騠뷥ꖽ諥ꖽ뷥ꖽ蠍૥꒧ꛦ袐ꧯ벚䄠䄠䄍૦꾕髩馢ꄺ⃩뮄铥蚛ꄍ૨躷韨꾁ꛯ벚駥뢈蓦ꂼ脬⃦閙飨꾁ഊ뫧钟볨ꢀ㨠곥릳賥薬돯벌飦颯瑭蓥薬댍૤뢓髯벚鏥誫鏤뢚Process finished with exit code 0\n1.2.2 DataOutputStream 数据输出流\n用法和输入流大同小异，它是字节输出流的一种增强。\n1.2.2.1 关键方法\nwriteDouble(double v)\nwriteInt(int v)\nwriteUTF(String v)等。\n实例：\npublic static void main(String[] args) throws IOException &#123;    DataOutputStream outputStream = new DataOutputStream(new FileOutputStream(&quot;四郎.txt&quot;));    String str = &quot;我是四郎，我爱死麻子了！！&quot;;    outputStream.writeUTF(str);&#125;\n运行结果：\n生成了 四郎.txt文件\n&#x27;我是四郎，我爱死麻子了！！\n1.3 字节对象流(比较重要)\n用ObjectInputStream和ObjectOutputStream类创建的对象称为对象输入（出）流。\n对象输入（出）流可以将一个对象写入到一个文件中（或从文件读取一个对象到内存中）。\n这个对象IO流比较常用，它可以将对象状态保存到磁盘中或通过网络发送出去，\n接收方只需要用相同的机制在需要的时候重新加载， 相当于深拷贝了。\n1.3.1 ObjectInputStream 对象输入流\nObjectInputStream(InputStream in);\n此方法是对象输入流的构造方法。\nreadObject();\n此方法读取一个对象到程序中。\n1.3.2 ObjectOutputStream 对象输出流\nObjectOutputStream(OutputStream out);\n此方法是对象输出流的构造方法。\nwriteObject(object obj);\n此方法可以将obj写入到目的地。\n实例：\n首先使用对象输出流将对象写入磁盘中：\npublic static void main(String[] args) throws IOException &#123;    ObjectOutputStream outputStream = new ObjectOutputStream    (new FileOutputStream(&quot;四郎&quot;));    List&lt;String&gt; a = new ArrayList&lt;&gt;();    a.add(&quot;我是四郎，我爱死麻子了&quot;);    outputStream.writeObject(a);&#125;\n运行结果：\n生成了 四郎  文件\n�� \u0005sr \u0013java.util.ArrayListx��\u001d��a�\u0003 \u0001I \u0004sizexp   \u0001w\u0004   \u0001t !我是四郎，我爱死麻子了x\n然后使用对象输入流重新加载：\npublic static void main(String[] args) throws IOException, ClassNotFoundException &#123;    ObjectInputStream inputStream = new ObjectInputStream    (new FileInputStream(&quot;四郎&quot;));    List&lt;String&gt; a  = (List&lt;String&gt;) inputStream.readObject();    System.out.println(a);&#125;\n运行结果：\n[我是四郎，我爱死麻子了]Process finished with exit code 0\n1.3 RandomAccessFile 随机IO流\n在java中，我们也可以只建立一个流，通过该流既能读文件，也能写文件。\n那就是RandomAccessFile类创建的随机流。\nRandomAccessFile类创建的流的指向既可以作为流的源，也可以作为流的目的地。\n随机IO流读取字符是以字节为单位的。\n1.3.1 使用方法\n构造方法\nRandomAccessFile(String name,String mode);\nRandomAccessFile(File file ,String mode);\n参数name用来确定一个文件名，给出创建的流的源（也是目的地）。\n参数mode取r（只读）或rw（可读写），决定创建流对文件的访问权利。\n注意：随机流指向文件，不刷新文件。\n1.3.1.2 常用方法\nclose();关闭文件getFilePointer();获取当前读写的位置。length();获取文件的长度。read();从文件中读取一个字节的数据。readBoolean();从文件中读取一个布尔值，0代表false，其他代表true。readByte();从文件中读取一个字节。readChar();从文件中读取一个字符。（两个字节）readDouble(); 从文件读取一个双精度浮点值（8个字节）readFloat(); 从文件读取一个单精度浮点值（4个字节）readFully(byte b[]); 读b.length字节放入数组b，完全填满该数组readInt();从文件中读取一个int值（4个字节）readLine();从文件中读取一个文本行readLong();从文件中读取一个长整型值（8个字节）readShort();从文件中读取一个短型值（2个字节）readUnsignedByte();从文件读取一个无符号字节（1个字节）readUnsignedShort();从文件读取一个无符号短型值（2个字节）readUTF();从文件中读取一个UTF字符串seek(long position);定位读写位置setLength(long newlength);设置文件的长度。skipBytes(int n);在文件中跳过给定数量的字节。write(byte b[]);写b.length个字节到文件writeBoolean(boolean v);把一个布尔值作为单字节值写入文件writeByte(int v);向文件写入一个字节writeByte(String s);向文件写入一个字符串writeChar(char c);向文件写入一个字符writeChars(String s);向文件写入一个作为字符数据的字符串writeDouble(double v);向文件写入一个双精度浮点值writeFloat(float v);向文件写入一个单精度浮点值writeInt(int v);向文件写入一个int值writeLong(long v);向文件写入一个长整型值writeShort(int v);向文件写入一个短整型值writeUTF(String s);向文件写入一个UTF字符串\n1.3.1.3 使用实例\npublic class RandomAccessFileStudy &#123;    public static void main(String[] args) throws IOException &#123;        RandomAccessFile randomAccessFile = new RandomAccessFile(&quot;麻子.txt&quot;,&quot;rw&quot;);        while (true)&#123;               String s = randomAccessFile.readLine();               if(s==null) break;               System.out.println(s);        &#125;        randomAccessFile.write(&quot;\\n你好，我是四郎&quot;.getBytes(StandardCharsets.UTF_8));    &#125;&#125;\n运行结果：\nå§å: å¼ éº»å­æ§å«ï¼ ç·å¹´é¾: 28èªæè¯ä»·ï¼ å¥½å¥½åå¥½å¥½å¥½åå¤§å­¦æç»©ï¼A A Aæ¯ä¸é¢æ ¡: é»ååæ ¡è·å¾è¯ä¹¦ï¼æå¸èµæ ¼è¯, æå®è¯äººçæ ¼è¨: å¬å¹³ï¼å¬å¹³ï¼è¿æ¯tmçå¬å¹³ä¸ä¸ï¼æå«ä¸ä¸Process finished with exit code 0并且成功向麻子.txt写入下面的内容： 你好，我是四郎\n代码地址：\nJava基础学习/src/main/java/Progress/exa22 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"5.文件读写-字符流","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-5-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%EF%BC%9A%E5%AD%97%E7%AC%A6%E6%B5%81/","content":"\n因为字节流不能很好地操作本身容量单位较大的数据（一个字符有时等于多个字节）,所以需要字符流。\n如果存在那种由多个字节组成的字符，那么用字节输入流读取，则会乱码！！！\n但是，如果用字符输入流读取，就不会出现乱码！！ 所以为了保险起见，对于文本文件,尽量少用字节流,多用字符流\n\n1.文件字符IO流\n文件字符IO流和文件字节IO流对应，它读入和写出的数据是以字符为单位的。\n1.1 FileReader 文件字符输入流\n1.1.1 构造方法\nFileReader(String filename);\nFileReader(File filename);\n1.1.2 其他方法\nint read(); 以字符为单位读取输入流源的数据\n1.1.3 使用示例\n/** * 文件字符输入流 */public class FileReaderStudy &#123;    public static void main(String[] args) throws IOException &#123;        FileReader reader = new FileReader(new File(&quot;麻子.txt&quot;));        int n;        while ((n=reader.read())!=-1)&#123;            System.out.print((char)n);        &#125;    &#125;&#125;\n运行结果：\n姓名: 张麻子性别： 男年龄: 28自我评价： 好好啊好好好哈大学成绩：A A A毕业院校: 黄埔军校获得证书：教师资格证, 教官证人生格言: 公平，公平，还是tm的公平专业：打劫专业你好，我是四郎Process finished with exit code 0\n1.2 FileWriter 文件字符输出流\n1.2.1 构造方法\nFileWriter(String filename);\nFileWriter(File filename);\nFileWriter(String filename,boolean append);\nFileWriter(File filename,boolean append);\n如果append为true，则将字节写入文件末尾处，相当于追加信息，反之则写在开头。\n1.2.2 其他方法\nwrite(String str); 将str的内容写出到目的地。\n1.2.3 使用实例\n/** * 文件字符输出流 */public class FileWriterStudy &#123;    public static void main(String[] args) throws IOException &#123;        FileWriter writer = new FileWriter(new File(&quot;四郎.txt&quot;));        writer.write(&quot;我爱麻子。。&quot;);        writer.flush();    &#125;&#125;\n2.缓冲字符IO流\n缓冲流增强了读写文件的能力。\n它的好处在于我们可以用它来有效率的读写文件。\nBufferedReader和BufferedWriter类创建的对象称为缓冲输入流，缓冲输出流，缓冲流支持mark，它是普通字符输入流的一种增强。\n2.1. BufferedReader 缓冲字符输入流\n2.1.1 构造方法\nBufferedReader(Reader in);\n2.1.2 其他方法\nBufferReader流能够通过调用readLine();读取文本行。\n2.1.3 使用实例\n我们可以通过向BufferedReader传递一个Reader子类的对象来创建一个BufferReader对象，如：\n缓冲输入流使用方法：\npublic class BufferedReaderStudy &#123;    public static void main(String[] args) throws IOException &#123;        FileReader fileReader = new FileReader(&quot;麻子.txt&quot;);        BufferedReader bufferedReader = new BufferedReader(fileReader);        while (true)&#123;            String str = bufferedReader.readLine();            if(str==null)&#123;                break;            &#125;            System.out.println(str);        &#125;    &#125;&#125;\n运行结果：\n姓名: 张麻子性别： 男年龄: 28自我评价： 好好啊好好好哈大学成绩：A A A毕业院校: 黄埔军校获得证书：教师资格证, 教官证人生格言: 公平，公平，还是tm的公平专业：打劫专业你好，我是四郎Process finished with exit code 0\n2.2 BufferedWriter 缓存字符输出流\n2.1.1 构造方法\nBufferedWriter(Writer in);\n2.1.2 其他方法\nBufferedWriter流能够通过调用write(String str);写入文本行\n注意: 记得调用flush写入磁盘\n2.1.3 使用实例\npublic class BufferedWriterStudy &#123;    public static void main(String[] args) throws IOException &#123;        BufferedWriter writer = new BufferedWriter(new FileWriter(&quot;四郎.txt&quot;));        writer.write(&quot;我是四郎，我爱麻子&quot;);        writer.flush();    &#125;&#125;\n注意： 在缓存流中的write方法不一定是写出到磁盘中,它是先存入缓存中,当调用flush()(或者缓存满了),输出流才会真正把数据写出。\n代码地址：\nJava基础学习/src/main/java/Progress/exa23 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"6.序列化对象克隆以及文件锁","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-6-%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%E5%8F%8A%E6%96%87%E4%BB%B6%E9%94%81%E5%AD%A6%E4%B9%A0/","content":"1.序列化对象克隆\n我们也许学习过如何clone一个对象，就是通过Object中的clone方法实现，\n但是我们必须知道，Object中的clone方法实现的是浅clone。\n如果我们想要clone一个完整的对象，我们需要学习如何去实现，\n序列化对象就是一种比较简单的完全clone方式。\n1.1 什么是序列化与对象克隆？\n有时想得到对象的一个“复制品”，使得复制品的变化不会引起原对象实体变化，反之亦然。\n我们称这样的复制品为原对象的一个克隆对象（简称克隆）。\n1.2 如何实现？\n使用对象流(例如ObjectOutputStream)很容易获取一个序列化对象的克隆，只需将该对象输出流指向目的地，然后将该目的地作为一个对象输入流的源，\n那么该对象输入流从源中读回的对象一定是原对象的一个克隆。简言之： 就是对象输入流通过对象的序列化信息得到当前对象的一个克隆。\n当程序想以较快的速度得到一个对象克隆时，可以用对象流将对象的序列化信息写入内存,然后从内存中读取对象\n1.3 实例展示\n下面是对象克隆的例子\nimport java.io.*;public class SerializableStudy &#123;    public static void main(String[] args) &#123;        TV changhong = new TV();        changhong.setName(&quot;长虹电视&quot;);        changhong.setPrice(5678);        File file = new File(&quot;television.txt&quot;);        try&#123;            //定义文件字节输出流，源为television.txt            FileOutputStream fileOut = new FileOutputStream(file);            //定义对象字节输出流            ObjectOutputStream objectOut = new ObjectOutputStream(fileOut);            //将对象序列化信息写入源中            objectOut.writeObject(changhong);            //关闭对象输出流            objectOut.close();            //定义文件输入流，源为television.txt            FileInputStream fileIn = new FileInputStream(file);            //定义对象字节输入流            ObjectInputStream objectIn = new ObjectInputStream(fileIn);            //将源中的对象读出得到changhong的克隆            TV xinfei = (TV)objectIn.readObject();            objectIn.close();//关闭对象输入流            System.out.println(&quot;changhong的名字：&quot;+changhong.getName());            System.out.println(&quot;changhong的价格：&quot;+changhong.getPrice());            System.out.println(&quot;changhong clone 的名字：&quot;+xinfei.getName());            System.out.println(&quot;changhong clone 的价格&quot;+xinfei.getPrice());        &#125;catch(ClassNotFoundException event)&#123;            System.out.println(&quot;不能读出对象&quot;);        &#125;catch(IOException event)&#123;           event.printStackTrace();        &#125;    &#125;&#125;/** * 被克隆的对象必须实现标记接口Serializable * 否则进行序列化的时候（就是调用writeObject）会报错误： * java.io.NotSerializableException: Progress.exa24.TV at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184) at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348) at Progress.exa24.SerializableStudy.main(SerializableStudy.java:19) */class TV implements Serializable &#123;    String name;    int price;    public void setName(String s)&#123;        name =s;    &#125;    public void setPrice(int n)&#123;        price = n;    &#125;    public String getName()&#123;        return name;    &#125;    public int getPrice()&#123;        return price;    &#125;&#125;\n运行结果：\nchanghong的名字：长虹电视changhong的价格：5678changhong clone 的名字：长虹电视changhong clone 的价格5678Process finished with exit code 0\n2.文件锁\n在实际的应用中，经常会出现几个程序处理同一个文件的情况发生，比如同时更新或读取文件。\n这种情况下，在多线程的情况中可能会造成冲突(出现数据不一致的情况)，Java提供了文件锁功能，可以帮助解决这样的问题。\n2.1.FileLock和FileChannel类\n这两个类分别在java.nio和java.nio.channels包中。\n输入，输出流读写文件时可以使用文件锁，以下结合RandomAccessFile类来说明文件锁的使用方法。\nRandomAccessFile创建的流在读写文件时可以使用文件锁。\n只要不解除该锁，其他程序无法操作被锁定的文件。\n2.2 使用文件锁的步骤\n先使用RandomAccessFile流建立指向文件的流对象，该对象的读写属性必须是rw,\n例如：\nRandomAccessFile input=new RandomAccessFile(&quot;Example.java&quot;,&quot;rw&quot;);\n然后input流调用方法getChannel();获得一个连接到底层文件的FileChannel对象（信道），例如：\nFileChannel channel = input.getChannel();\n信道调用tryLock();或lock();方法获得一个FileLock(文件锁）对象，这一过程称作对文件加锁。\n例如：\nFileLock lock = channel.tryLock();\n这一 过程有两个结果，要么成功，要么失败，如果失败了，我们需要进行重试获取锁，如果成功了，我们就可以对文件进行操作了。\n对文件加锁之后，如果想读，写文件必须让FileLock对象调用release();释放文件锁。\n例如：\nlock.release();\n2.3编程实例\nimport java.io.File;import java.io.IOException;import java.io.RandomAccessFile;import java.nio.channels.FileChannel;import java.nio.channels.FileLock;import java.nio.charset.StandardCharsets;public class LockWriteFile extends Thread&#123;    public void run()&#123;        long start = System.currentTimeMillis();        //创建文件对象        File file = new File(&quot;test.txt&quot;);        try &#123;            //如果文件不存在，创建之            if(!file.exists())&#123;                if(file.createNewFile())&#123;                    System.out.println(&quot;创建成功！！&quot;);                &#125;else &#123;                    System.out.println(&quot;创建失败！！&quot;);                &#125;            &#125;            //对该文件加锁            RandomAccessFile randomAccessFile = new RandomAccessFile(file, &quot;rw&quot;);            FileChannel fileChannel=randomAccessFile.getChannel();            FileLock fileLock=null;            while(true)&#123;                try &#123;                    // 这一步就是尝试获取锁                    fileLock = fileChannel.tryLock();                    sleep(10000);                    break;                &#125; catch (Exception e) &#123;                    System.out.println(&quot;有其他线程正在操作该文件，当前线程&quot;+Thread.currentThread().getName()+&quot;休眠1000毫秒&quot;);                    sleep(1000);                &#125;            &#125;            for(int i=1;i&lt;=1000;i++)&#123;                sleep(10);                StringBuffer sb=new StringBuffer();                sb.append(&quot;这是第&quot;+i+&quot;行对应的数据&quot;);                sb.append(&quot;\\n&quot;);                randomAccessFile.write(sb.toString().getBytes(StandardCharsets.UTF_8));            &#125;            //释放锁            fileLock.release();            //关闭信道            fileChannel.close();            //关闭流            randomAccessFile.close();        &#125; catch (IOException | InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(&quot;线程:&quot;+Thread.currentThread().getName()+&quot;,写文件耗时： &quot;+(System.currentTimeMillis()-start)+&quot;毫秒&quot;);    &#125;&#125;\n测试程序：\npublic class LockWriteTest &#123;    public static void main(String[] args) &#123;        LockWriteFile writeFileThread = new LockWriteFile();        writeFileThread.setName(&quot;writeThread&quot;);        LockWriteFile writeFileThread2 = new LockWriteFile();        writeFileThread2.setName(&quot;writeThread2&quot;);        writeFileThread.start();        writeFileThread2.start();    &#125;&#125;\n运行结果：\n有其他线程正在操作该文件，当前线程readFileThread休眠1000毫秒有其他线程正在操作该文件，当前线程readFileThread休眠1000毫秒有其他线程正在操作该文件，当前线程readFileThread休眠1000毫秒有其他线程正在操作该文件，当前线程readFileThread休眠1000毫秒有其他线程正在操作该文件，当前线程readFileThread休眠1000毫秒有其他线程正在操作该文件，当前线程readFileThread休眠1000毫秒有其他线程正在操作该文件，当前线程readFileThread休眠1000毫秒有其他线程正在操作该文件，当前线程readFileThread休眠1000毫秒有其他线程正在操作该文件，当前线程readFileThread休眠1000毫秒有其他线程正在操作该文件，当前线程readFileThread休眠1000毫秒当前线程:readFileThread2,读文件共花了15035毫秒当前线程:readFileThread,读文件共花了25123毫秒Process finished with exit code 0\n代码地址：\nJava基础学习/src/main/java/Progress/exa24 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"7.Java操作MySQL的步骤(JDBC)","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-7-Java%E6%93%8D%E4%BD%9Cmysql%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4%EF%BC%88JDBC%EF%BC%89/","content":"1.基本步骤\n\n首先在电脑上安装mysql，创建相应的数据库和表\n然后在开发项目中导入相应的jar包\n最后在代码中调用相应类进行调用。\n\n2.实例演示\n2.1.事先在mysql中创建名为jdbc的数据库\n建立user的表：\nmysql&gt; create database jdbc;Query OK, 1 row affected (0.05 sec)mysql&gt; use jdbcDatabase changedmysql&gt; create table users(    -&gt; id int primary key auto_increment,    -&gt; name varchar(40),    -&gt; password varchar(40),    -&gt; email varchar(60),    -&gt; birthday date)character set utf8 collate utf8_general_ci;Query OK, 0 rows affected, 1 warning (0.11 sec)mysql&gt; insert into users(name,password,email,birthday)    -&gt; values(&#x27;zs&#x27;,&#x27;123456&#x27;,&#x27;zs@sina.com&#x27;,&#x27;1980-12-03&#x27;);Query OK, 1 row affected (0.09 sec)mysql&gt; select * from users;+----+------+----------+-------------+------------+| id | name | password | email       | birthday   |+----+------+----------+-------------+------------+|  1 | zs   | 123456   | zs@sina.com | 1980-12-03 |+----+------+----------+-------------+------------+\n或者可以使用mysql自带的数据库world（无需自己新建）进行查询，本例选择后者。\n2.2.然后程序中连接mysql\n首先，java的mysql驱动jar包导入项目中。\nmaven项目可以直接添加配置：\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;8.0.12&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n普通项目可以通过这种方式添加：\n首先在\nhttps://mvnrepository.com/artifact/mysql/mysql-connector-java/8.0.30\n下载jar包，然后将jar包导入自己的项目依赖中即可。\n然后写入下列代码：\npackage Progress.exa25;import java.sql.*;public class JdbcStudy &#123;    public static void main(String[] args) &#123;        Statement stmt=null;        ResultSet rs=null;        Connection conn=null;        try&#123;            //加载驱动程序            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);            String url=&quot;jdbc:mysql://localhost:3306/world?&amp;useSSL=false&amp;serverTimezone=UTC&quot;;            String username=&quot;root&quot;;            String password=&quot;root&quot;;            //建立连接            conn = DriverManager.getConnection(url,username,password);            //操作数据            stmt= conn.createStatement();            String sql = &quot;select * from city&quot;;            rs = stmt.executeQuery(sql);            System.out.println(&quot;id|name|countryCode|&quot;);            while(rs.next()) &#123;                int id = rs.getInt(&quot;id&quot;);                String name = rs.getString(&quot;name&quot;);                String countryCode = rs.getString(&quot;countryCode&quot;);                System.out.println(id +&quot; | &quot;+name+&quot; | &quot;+countryCode);            &#125;        &#125;catch(ClassNotFoundException | SQLException e) &#123;            e.printStackTrace();        &#125;finally&#123;            //释放资源            if(rs!=null)&#123;                try&#123;                    rs.close();                &#125;catch(SQLException e)&#123;                    e.printStackTrace();                &#125;                rs=null;            &#125;            if(stmt!=null)&#123;                try&#123;                    stmt.close();                &#125; catch(SQLException e) &#123;                    e.printStackTrace();                &#125;                stmt=null;            &#125;if(conn!=null)&#123;                try&#123;                   conn.close();               &#125;catch(SQLException e)&#123;                   e.printStackTrace();                &#125;                conn=null;            &#125;        &#125;    &#125;&#125;\n运行结果：\nid|name|countryCode|1 | Kabul | AFG2 | Qandahar | AFG3 | Herat | AFG4 | Mazar-e-Sharif | AFG5 | Amsterdam | NLD6 | Rotterdam | NLD7 | Haag | NLD8 | Utrecht | NLD9 | Eindhoven | NLD......//后面的就不展示了\n运行之，成功访问。\n代码地址：Java基础学习/src/main/java/Progress/exa25 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"8.Java泛型,通配泛型,消除泛型和泛型的限制","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-8-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%B3%9B%E5%9E%8B%EF%BC%8C%E9%80%9A%E9%85%8D%E6%B3%9B%E5%9E%8B%EF%BC%8C%E6%B6%88%E9%99%A4%E6%B3%9B%E5%9E%8B%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%9A%84%E9%99%90%E5%88%B6/","content":"1.什么是泛型？\n在我看来，可以将泛型编程机制看作一个工具，通过这个工具我们可以在代码编译时检测出某些运行错误，\n并写出更为通用（抽象）， 可复用的代码。\n从JDK1.5开始，Java允许定义泛型类，泛型接口，泛型方法。这样我们就可以在Java中使用泛型机制写出更为通用的程序。\n1.1. 如何定义泛型类，接口，方法\n1.1.1.泛型类\n泛型相当于一些类型数据的抽象，泛型程序设计意味着编写的泛型代码可以对多种不同类型的对象复用。（体现代码的复用原则）\n首先我们要注意泛型类型必须是引用类型（不能是int double …的基本类型)\n泛型类的示例\n下面编写了一个泛型类, 意味着可以向这个类中存入任意类型的对象。\nclass GenericStack&lt;E&gt; &#123;    //定义一个链表，链表中存储的元素设定为E    private ArrayList&lt;E&gt; list=new ArrayList&lt;&gt;();    public int getSize() &#123;        return list.size();    &#125;    //泛型方法peek    public E peek()&#123;        return list.get(getSize()-1);    &#125;    public void push(E o) &#123;        list.add(o);    &#125;    //泛型方法pop    public E pop()&#123;        E o = list.get(getSize()-1);        list.remove(getSize()-1);        return o;    &#125;    public boolean isEmpty()&#123;        return list.isEmpty();    &#125;&#125;\n对于上面的类，我们就可以称之为泛型类了，因为它的定义使用了泛型机制。\n在定义类的时候在类名后面添加 类似于  的代码：\nclass GenericStack &lt; E &gt;\n时，我们就为这个类定义了泛型E,在类中，我们可以将E当作一个类进行使用，这个类是在使用GenericStack时定义的。\n例如：\npublic static void main(String[] args) &#123;    GenericStack&lt;String&gt; stack = new GenericStack&lt;&gt;();    stack.push(&quot;number1&quot;);    stack.push(&quot;number2&quot;);    System.out.println(stack.pop());&#125;\n运行结果：\nnumber2Process finished with exit code 1\n当我们尝试弹入非String的数据时，在编译期就会报错:\nE:\\Personal\\MyRepository\\study\\Java基础学习\\src\\main\\java\\Progress\\exa26\\GenericClass.java:11:20java: 不兼容的类型: int无法转换为java.lang.String\n如果没有使用泛型，在程序运行到这一段时才会报错。\n比如我们把上面的泛型删掉用Object类型来编写一个相同作用的类，再看看：\nclass GenericStack1&#123;    //定义一个链表，链表中存储的元素设定为E    private ArrayList list=new ArrayList();    public int getSize() &#123;        return list.size();    &#125;    public Object peek()&#123;        return list.get(getSize()-1);    &#125;    public void push(Object o) &#123;        list.add(o);    &#125;    public Object pop()&#123;        Object o = list.get(getSize()-1);        list.remove(getSize()-1);        return o;    &#125;    public boolean isEmpty()&#123;        return list.isEmpty();    &#125;&#125;\n测试之：\npublic static void main(String[] args) &#123;    GenericStack1 stack1 = new GenericStack1();    stack1.push(11);    System.out.println((String)stack1.pop());&#125;\n编译没有报错，下面运行的时候报错了：\nException in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String\tat Progress.exa26.GenericClass.main(GenericClass.java:15)Process finished with exit code 1\n结论：使用泛型可以有效避免强转所造成的运行时错误(RuntimeException)。\n1.1.2 泛型接口\n泛型接口的定义和泛型类一样，在合适的位置加上E即可。\n例如：\npublic interface Maximum&lt;T&gt; &#123;    T getMax(T[] array);&#125;\n操作实例：\npublic class GenericInterface &#123;    public static void main(String[] args) &#123;        MaximumImp maximumImp = new MaximumImp();        System.out.println(maximumImp.getMax(null));    &#125;&#125; interface Maximum&lt;T&gt; &#123;    T getMax(T[] array);&#125;class MaximumImp implements Maximum&lt;String&gt;&#123;    @Override    public String getMax(String[] array) &#123;        return &quot;null&quot;;    &#125;&#125;\n运行结果：\nnullProcess finished with exit code 0\n1.1.3 泛型方法\n泛型方法除了在泛型类中定义，也可以在普通类中定义\n例子\nclass ArrayAlg&#123;  public static &lt;T&gt; T getMiddle(T... a)&#123;    return a[a.length/2];  &#125;  &#125;\n注意：类型变量放在修饰符后，返回类型的前面。\n当我们调用一个泛型方法时，我们可以把具体类型包围在尖括号中，放在方法名前面，例如:\npublic class GenericMethod &#123;    public static void main(String[] args) &#123;        String middle =GenericMethod.&lt;String&gt;getMiddle(&quot;join&quot;,&quot;R&quot;,&quot;fasd&quot;);        System.out.println(middle);    &#125;    public static &lt;T&gt; T getMiddle(T... a)&#123;        return a[a.length/2];    &#125;&#125;\n其实在实际的编程中我们可以省略掉&lt; String &gt;而不对结果产生影响，原因是编译器会根据已有信息来对泛型类型进行推导，\n这也是一种编程技巧。\n2.使用泛型编程的好处\n前面学习了一些泛型的基础，我们知道了如何使用泛型机制进行编程，那么问题来了，泛型编程适合编写什么样的程序？\n泛型比较适合编写一些通用的程序出来，用来提高编程效率，简化编程工作。\n使代码具有更好的可读性和安全性，复用性，通用性，提高工作效率。\n3.谁想成为合格的泛型程序员？\n3.1 作为一个泛型程序员，我们的任务就是要预计到我们的泛型类所有可能的用法。\n这个任务会有多难呢？\n我们可以看一个典型的问题：ArrayList类中有一个方法addAll用来添加另一个集合的全部元素。\n现在：Manager extends Emplyee\n一个程序员可能想要将一个ArrayList&lt; Manager &gt;中的所有元素添加到一个ArrayList&lt; Emplyee &gt;中去，这是可以的，但是反过来就不行了\nArrayList&lt;Manager&gt; list = new ArrayList();ArrayList&lt;Emplyee&gt; list1 = new ArrayLsit();list1.addAll(list);//这个是可以的，因为Manager继承了Emplyeelist.add(list1);//这个就不行了\n但是目前我们所学的知识，泛型编程也无法避免这个问题：\npublic class GenericWildcard &#123;    public static void main(String[] args) &#123;        ArrayList&lt;Manager&gt; list = new ArrayList();        list.add(new Manager());        ArrayList&lt;Emplyee&gt; list1 = new ArrayList();        list1.add(new Emplyee());        //list1.addAll(list);//这个是可以的，因为Manager继承了Emplyee        list.addAll(list1);//这个就不行了        list.value[0].sysoutI();//这个就不行了    &#125;&#125;class ArrayList&lt;E&gt;&#123;    E[] value;    int size;    public ArrayList()&#123;        value = (E[]) new Object[10];    &#125;    public void add(E e)&#123;        value[size++] = e;    &#125;    public ArrayList&lt;E&gt; addAll(ArrayList&lt;?&gt; list)&#123;        for(int i=0;i&lt;size;i++)&#123;            value[i] = (E)list.value[i];        &#125;        return this;    &#125;&#125;class Emplyee&#123;    private final int i = 100;    public void sysoutI()&#123;        System.out.println(i);    &#125;&#125;class Manager extends Emplyee&#123;&#125;\n运行结果：\nException in thread &quot;main&quot; java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [LProgress.exa26.Manager;\tat Progress.exa26.GenericWildcard.main(GenericWildcard.java:11)Process finished with exit code 1\n那么，如何在编译期间允许前一个调用，而不允许后一个调用方式呢？也就是如何让编译器在程序运行前发现这个错误？\njava语言的设计者发明了一个具有独创性的概念来解决这个问题： 通配符类型（通配泛型）\n通过通配泛型符，Java代码可以在编译期间发现本来可以避免的错误，并让程序员及时修复。\n下面的4,5,6节将对这一机制进行详细学习。\n3.2 泛型程序设计的三个水平\n基本水平就是仅仅使用泛型类，而不考虑它们如何工作以及为什么这样做。\n中等水平就是可以在混合使用不同的泛型类时能系统的解决各种问题，而不是胡乱猜测。\n高等水平就是能自己设计出能够应用于多种场景的泛型类。\n注意：Java库中使用变量E表示集合的元素类型，K和V表示键和值的类型。 T（必要时还可以用U,S）表示其他任意类型。\n4.原始类型和向后兼容\n4.1.我们也可以使用泛型类而无需指定具体类型：（这时泛型默认为Object）\nGenericStack stack = new GenericStack();\n上面语句等价于：\nGenericStack&lt;Object&gt; stack = new GenericStack&lt;Object&gt;();\n像这样的不带参数的泛型类称为原始类型，使用原始类型可以向后兼容Java的早期版本的代码。\n示例：\npublic static void main(String[] args) &#123;    List list = new LinkedList&lt;&gt;();    list.add(new Object());    list.add(new Integer(100));    System.out.println(list.get(0));    System.out.println(list.get(1));&#125;\n4.2.类型擦除\n在java虚拟机中，对于泛型程序其实会做一个类型消除的操作的，例如下面泛型接口：\npublic interface Maximum&lt;T extends Comparable&lt;T&gt;&gt; &#123;    T getMax(T[] array);&#125;\n在虚拟机中的class字节码为：\npublic interface Maximum&#123;    Comparable getMax(Comparable[] array);&#125;\n上面进行类型擦除的接口我们称之为这个泛型类的原始类型，这点很重要，因为我们获取的泛型类的Class对象其实就是原始类型的Class。\n从这里我们大概可以知道泛型机制的实现原理，就是编译器通过解析泛型程序，根据泛型程序的定义将程序编译为具体类型的字节码JVM解释。\n5.通配泛型\n\n\n？称为非受限通配泛型，它和？extends Object是一样的。\n\n\n？extends T称为受限通配泛型，表示T或T的一个子类型。\n\n\n？super T称为下限通配泛型，它表示T或T的一个父类型。\n通过通配泛型，我们便可以在编译期发现3.1节出现的错误。\n如下图所示：\n\n\npublic void wildcard()&#123;    List&lt;Emplyee&gt; list = new LinkedList&lt;&gt;();    List&lt;Manager&gt; list1 = new LinkedList&lt;&gt;();    list1.addAll(list);&#125;\n这个方法在编译期就会抛出异常.\n通配泛型符可以让我们在定义泛型类时限制泛型的使用场景，将错误的场景排除在外，避免在运行时出现事故。\n6.消除泛型和对泛型的限制\n泛型是使用类型消除机制的方法来实现的。\n编译器使用泛型类型信息来编译代码，但是随后会消除它。\n因此泛型信息在运行时是不可用的，这种方法可以使泛型代码向后兼容使用原始类型的遗留代码。\n在这过程中 注意：\n\n如果一个泛型类型是受限的，那么编译器就用该受限类型替换它。\n不管实际的具体类型是什么，泛型类是被它的所有实例所共享的。\n\n由于泛型类型在运行时被消除，因此对如何使用泛型类型有如下限制：\n\n不能使用 new E()；不能使用泛型类型参数创建实例。\n不能使用new E[];不能使用泛型类型参数创建数组\n在静态上下文中不允许类的参数是泛型类型。\n异常类不能是泛型的。\n\n代码地址：\nJava基础学习/src/main/java/Progress/exa26 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n如果通过上面的学习，你了解了如何使用泛型，不妨学习一下下面的泛型编程Demo专栏巩固一下：\nJava动手做一做之泛型编程\n","tags":["Java进阶"]},{"title":"9.1 Java集合接口学习","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-9-1-Java%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0/","content":"1.集合(即数据结构)概述\n首先我们要知道，Java合集框架中定义的所有接口和类都在java.util包中。\n其次我们需要知道Java提供了那些数据结构供我们使用？\nJava中的算法结构可分为下面几大种类：\n\nSet 用于存储一组不重复的元素。（它的重要特性是不重复）\nList 链表（它的重要特性是顺序存储）\nStack 栈（它的重要特性是：先进后出，后进先出）\nQueue 队列（它的重要特性是：先进先出，后进后出）\nPriority Queue 优先队列（特性的重要特性是优先级）\nMap 映射（特性是键值对存储）\n\n集合框架部分结构图\n图一：\ngraph LR\n\nAbstractCollection--impl--&gt;Collection\n\nSet--extend--&gt;Collection\n\nList--extend--&gt;Collection\n\nQueue--extend--&gt;Collection\n\nAbstractSet--impl--&gt;Set\n\nAbstractList--extend--&gt;AbstractCollection\n\nAbstractList--impl--&gt;List\n\nDeque--extend--&gt;Queue\n\nListedList --impl--&gt;Deque\n\nAbstractSet--extend--&gt;AbstractCollection\n\n\nSortedSet--impl--&gt;Set\n\nHashSet--extend--&gt;AbstractSet\n\nVector--extend--&gt;AbstractList\n\nArrayList--extend--&gt;AbstractList\n\nAbstractSequentialList--extend--&gt;AbstractList\n图二：\ngraph LR\n\nNavigableSet--extend--&gt;SortedSet\n\nLinkedHashSet--extend--&gt;HashSet\n\nStack--extend--&gt;Vector\n\nTreeSet--extend--&gt;AbstractSet\n\nTreeSet--impl--&gt;NavigableSet\n\nLinkedList--extend--&gt;AbstractSequentialList\n\nPriorityQueue--extend--&gt;AbstractQueue\n\nAbstractQueue--impl--&gt;Deque\n我们先关注Set,List,Queue都继承了一个共同的接口Collection.\n在Java中基本的数据结构类都继承了Collection接口，所有在Collection接口中定义了一个基本数据结构应该有的操作。\n1.1.我们先看下Collection接口定义（了解即可）\n1.1.1 接口声明定义\npublic interface Collection&lt; E &gt; extends Iterable&lt; E &gt;\n我们可以看到Collection接口的声明还继承了Iterable接口，这个我们后面再来介绍,先来学习下Collection中定义的方法。\n1.1.2  Collection接口方法定义\n\n\n\n方法定义\n方法描述\n\n\n\n\nint size();\n返回此集合中的元素个数。\n\n\nboolean isEmpty();\n如果集合为空，返回true\n\n\nboolean contains(Object o);\n如果此集合包含指定的元素，则返回true。\n\n\nIterator iterator();\n返回此集合中元素的迭代器。\n\n\nObject[] toArray();\n返回一个包含此集合中所有元素的数组。\n\n\n T[] toArray(T[] a);\n返回指定泛型的类型数组\n\n\nboolean add(E e);\n添加元素\n\n\nboolean remove(Object o);\n删除元素\n\n\nboolean containsAll(Collection&lt;?&gt; c);\n如果此集合包含指定集合的所有元素，则返回true。\n\n\nboolean addAll(Collection&lt;? extends E&gt; c);\n将指定集合中的所有元素添加到此集合\n\n\nboolean removeAll(Collection&lt;?&gt; c);\n将指定集合中的所有元素移出此集合\n\n\nboolean retainAll(Collection&lt;?&gt; c);\n仅保留此集合中包含在指定集合中的元素(可选操作)。\n\n\nvoid clear();\n删除集合所有元素\n\n\nboolean equals(Object o);\n将指定的对象与此集合进行相等性比较。\n\n\nint hashCode();\n返回此集合的哈希码值。\n\n\nboolean removeIf(Predicate&lt;? super E&gt;  filter)\n删除此集合中满足给定Predicate的所有元素。\n\n\n\n其中removeIf，Collection中给出了默认实现：\n/*  在学习此方法之前我们应先了解什么是default关键字：  https://blog.csdn.net/qq_35835624/article/details/80196932  删除此集合中满足给定Predicate的所有元素。  */   default boolean removeIf(Predicate&lt;? super E&gt; filter) {       Objects.requireNonNull(filter);       boolean removed = false;       final Iterator&lt;E&gt; each = iterator();       while (each.hasNext()) {           if (filter.test(each.next())) {               each.remove();               removed = true;           }       }       return removed;   }\n看完上面的Colletion的定义，我们大概知道了定义一个具体集合类需要赋予这个集合类的能力有哪些。\n1.2.Iterable接口\n下面我们看一下Iterable接口的定义\npublic interface Iterable&lt;T&gt; {   /*   组合Iterator接口，返回类型为T的元素的迭代器。   */    Iterator&lt;T&gt; iterator();    /*    为Iterable的每个元素执行给定的操作，直到处理完所有元素或者操作抛出异常。    */    default void forEach(Consumer&lt;? super T&gt; action) {        Objects.requireNonNull(action);//检查要遍历的对象是否为空        for (T t : this) {            action.accept(t);        }    }     /*    在这个Iterable描述的元素上创建一个Spliterator。   */    default Spliterator&lt;T&gt; spliterator() {        return Spliterators.spliteratorUnknownSize(iterator(), 0);    }}\n它的主要作用在于提供快速遍历集合的一个方式，我们可以看到，这个接口组合了Iterator接口。\n下面看一下Iterator接口的定义：\npublic interface Iterator&lt;E&gt; {    /**    * 判断集合是否拥有下一个元素    **/    boolean hasNext();    /**    * 获取下一个元素    **/    E next();    /**    * 删除当前元素    **/    default void remove() {        throw new UnsupportedOperationException(\"remove\");    }    /**    * 遍历元素    **/    default void forEachRemaining(Consumer&lt;? super E&gt; action) {        Objects.requireNonNull(action);        while (hasNext())            action.accept(next());    }}\n1.3.Collection的子接口\n1.3.1 List接口\nCollection的子接口除了继承Collection定义的方法外，还能根据自己的特性自己定义出自己的方法。\n比如说List接口中,新增了一些List结构的特性方法定义：\n例如：\n\n\n\n方法定义\n描述\n\n\n\n\nE get(int index)\n获取第index个位置上的元素\n\n\nint indexOf(E object)\n获取元素object再List中的位置\n\n\n\n等方法.\n1.3.2 AbstractList实现List接口\nAbstractList抽象类提供了List接口的部分实现,它的作用是代码复用，减少具体的List实现类的开发难度。\n比如：\ngraph LR\n\nArrayList--extend--&gt;AbstractList\n\nArrayQueue--extend--&gt;AbstractList\n等等,一些面向开发者的具体集合类都通过继承抽象实现类来减少开发工作量.\n通过上面的学习我们知道了Java中合集数据结构大概的实现流程，我们可以带着这个思路去学习其他的java合集。\n1.4 JDK定义一个具体集合的步骤\n\n根据定义的集合特性新建一个接口并继承Collection接口\n新建一个AbstractionCollection抽象类实现定义的接口提供一个基础实现\n最后根据自己的需要继承AbstractionCollection抽象类得到最后的集合实现类\n\n1.5 Java自己动手做一个集合类\n通过上面的学习，下面我们来实现一个自己的集合SelfList\n1.5.1 定义接口SelfList\n首先定义出SelfList的接口,规范它的能力。\npackage Progress.exa27_1;import java.util.Collection;/** * SelfList接口定义 * @param &lt;E&gt; */public interface SelfList&lt;E&gt; extends Collection&lt;E&gt; {    /**     * 将元素添加到链表头部     * @param e 元素     */    void addHead(E e);    /**     * 将元素添加到链表尾部     * @param e     */    void addTail(E e);    /**     * 此方法删除元素     * @param e 元素     * @return     */    E delete(E e);    /**     * 获取列表中位置i上的元素     * @param i     * @return     */    E get(int i);    /**     * 获取列表的第一个元素     * @return     */    E getHead();    /**     * 获取列表的最后一个元素     * @return     */    E getTail();}\n1.5.2 定义抽象实现类AbstractionSelfList\n然后定义它的抽象实现类,将其中的可抽象的实现提供默认的实现.\n例如, 给add方法提供一个默认实现,抛出一个异常\npackage Progress.exa27_1;public abstract class AbstractionSelfList&lt;E&gt; implements SelfList&lt;E&gt;{    public boolean add(E e) {        throw new UnsupportedOperationException();    }}\n1.5.2 定义具体实现类ArraySelfList\n下面展示部分实现部分，完整代码需要访问代码地址去看(文章末尾)\npackage Progress.exa27_1;import java.util.Collection;import java.util.Iterator;/** * 具体实现 * @param &lt;E&gt; */public class ArraySelfList&lt;E&gt; extends AbstractionSelfList&lt;E&gt;{     int size = 0;     Object[] elementData;     public String toString(){         StringBuilder builder = new StringBuilder();         builder.append(\"[\");         for(Object e:elementData){             if(e!=null){                 builder.append(e.toString()).append(\",\");             }         }         builder.replace(builder.length()-1,builder.length(),\"\");         builder.append(\"]\");         return builder.toString();     }     public ArraySelfList(){         elementData = new Object[16];     }     public ArraySelfList(int capacity){         elementData = new Object[capacity];     }    @Override    public void addHead(E e) {         //如果是第一次添加         if(size==0){             elementData[0] = e;         } else if(size&lt;elementData.length){             Object[] temp = new Object[elementData.length];             System.arraycopy(elementData,0,temp,1,size);             temp[0] = e;             elementData = temp;         }else{             Object[] temp = new Object[elementData.length+5];             System.arraycopy(elementData,0,temp,1,size);             temp[0] = e;             elementData = temp;         }        size++;    }    @Override    public void addTail(E e) {       if(size&lt;elementData.length){            elementData[size++] = e;        }else{            Object[] temp = new Object[elementData.length+5];            System.arraycopy(elementData,0,temp,0,size);            temp[size++] = e;            elementData = temp;        }    }    @Override    public E delete(E e) {        return null;    }    @Override    public E get(int i) {         if(i&lt;size)           return (E)elementData[i];         else             throw new ArrayIndexOutOfBoundsException();    }}\n1.5.4 测试使用\npackage Progress.exa27_1;public class ArraySelfListTest {    public static void main(String[] args) {        ArraySelfList&lt;String&gt; list = new ArraySelfList&lt;&gt;(5);        list.addHead(\"first\");        System.out.println(list);        list.addHead(\"second\");        System.out.println(list);        list.addTail(\"three\");        System.out.println(list);        System.out.println(list.get(2));    }}\n测试结果：\n[first][second,first][second,first,three]threeProcess finished with exit code 0\n代码地址：\nJava基础学习/src/main/java/Progress/exa27_1 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"9.2 Java集合基础学习(集合基本概念,基础接口)","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-9-2-java%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E9%9B%86%E5%90%88%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E7%A1%80%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0%EF%BC%89/","content":"学习总结自《java核心技术卷Ⅰ》\n1.Java集合框架\nJava最初的版本只为最常用的数据结构提供了一组类：Vector(链表),Stack(栈),Hashtable(哈希表)，\nBitSet(位集合)和Enumeration（枚举）接口。 其中的Enumeration接口提供了一种用于访问任意容器中各个元素的抽象机制，\n这句话的意思实际上说的就是我们可以实现这个接口来访问任意容器的元素：\npublic interface Enumeration&lt;E&gt; {    boolean hasMoreElements();    E nextElement();}\n不过现在迭代器更为常用，现在Java中的集合框架经过发展已经支持很多数据结构了。\n1.1.Java集合设计思想\nJava集合框架的一个中心思想是接口和实现分离。这种机制较好的保持了一些集合的特性,又给开发者提供了灵活的实现方式和增加一些特性。\n1.1.1 自定义队列\n下面我们通过自己构造队列的一种实现是如何被定义的来了解如何分离的\n\n首先我们要定义一个队列接口\n\n队列接口应指出可以在队列的尾部添加元素，在队列的头部删除元素，并且可以查询队列中元素的个数。\n其最简单形式类似下面：\npublic interface Queue&lt;E&gt;{ void add(E element);//尾部添加元素 E remove();//头部删除元素 int size();//查询元素个数}\n\n然后我们要实现它:\n上面的接口并没有说明队列是如何实现的，所以我们要实现它来实现队列，队列通常有两种实现方式：循环数组实现，链表实现\n下面分别大体实现下：\n\ni.循环数组实现\npublic class CircularArrayQueue&lt;E&gt; implements Queue&lt;E&gt;{  private int head;//定义队列头元素  private int tail;//队列尾元素  CircularArrayQueue(int capacity){......}//队列构造函数  public void add(E element){......}//添加元素  public E remove(){......}//删除元素  public int size(){......}//返回队列大小  private E[] elements;//存储元素的数组}\nii.链表实现\npublic class LinkedListQueue&lt;E&gt; implements Queue&lt;E&gt;{  private Link head;  private Link tail;  LinkedListQueue(){...}  public void add(E element){...}  public E remove(){...}  public int size(){...}}\n\n最后我们就可以在应用中用它了\n上面是我们自己写的，其实Java库的开发者已经把上面的工作全做了，而且很系统的开发了很多数据结构供我们使用,\n实际上我们只需要学习如何使用就可以了。\n\n2.Java集合框架中有哪些接口？\ngraph LR\n\nCollection --extend--&gt; Iterable\n\nList--extend--&gt; Collection\n\nSet--extend--&gt; Collection\n\nQueue--extend--&gt; Collection\n\nSortedMap --extend--&gt; Map\n\nSortedSet--extend--&gt;Set\nDeque--extend--&gt;Queue\nNavigableMap --extend--&gt; SortedMap\nNavigbleSet --extend--&gt; SortedSet\nListIterator--extend--&gt;Iterator\nRandomAccess\n这张图为我们比较完整的描述就Java中集合框架的基本接口。下面我们先了解一些比较重要的接口\n2.1.Iterable接口\n它是一个迭代器接口，实现它的类都是可被按顺序遍历的集合类。\npublic interface Iterable&lt;T&gt; {        //获取迭代器    Iterator&lt;T&gt; iterator();        //default是在java8中引入的关键字，在接口内部包含了一些默认的方法实现，    //从而使得接口在进行扩展的时候，不会破坏与接口相关的实现类代码。    /*    * 对Iterable的每个元素执行给定的操作，直到所有元素都被处理或动作引发异常    */    default void forEach(Consumer&lt;? super T&gt; action) {        Objects.requireNonNull(action);        for (T t : this) {            action.accept(t);        }    }    /*    *在Iterable描述的元素上创建一个Iterable    */    default Spliterator&lt;T&gt; spliterator() {        return Spliterators.spliteratorUnknownSize(iterator(), 0);    }}\n2.2 Collection接口\n它继承了迭代器接口。它是集合接口，它里面定义了一些方法，这些方法都是操作集合的常用方法。\n这个接口有两个基本方法：\npublic interface Collection&lt;E&gt;{ boolean add(E element);//添加元素方法 Iterator&lt;E&gt; iterator();//迭代器}\n[对于Collection的具体学习请看上一节](/9.1 Java集合接口学习)。\n2.3 List,Set,Queue\nList，Set ，Queue接口则是继承Collection定义具体的数据结构的接口\n其中List定义了链表, 对应着链表数据结构, 线性顺序存储元素集\nSet定义了不重复集数据结构, 一般是非线性无序存储不重复的元素集\nQueue定义了队列数据结构, 其数据集遵守着先进先出的基本原则\n2.4 Map接口\n它是一个独立的接口，它不继承Collection接口\n它用来定义键值对数据结构的接口, 一般用的是Hash映射(时间复杂度为1)\n它定义的接口常用方法如下：\n//从该Map中删除所有的映射数据（可选操作）: 清空操作void clear()//如果此Map包含指定key，则返回 trueboolean containsKey(Object key)//如果此Map包含指定的value，则返回 trueboolean containsValue(Object value)//返回此Map中包含的Entry的Set集合,可以用来遍历MapSet&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()//将指定的对象与此Map对象相比较获得相等性。boolean equals(Object o)//返回到指定键所对于的值，如果不包含指定的键，则返回nullV\tget(Object key)//返回到指定键所对于的值，如果不包含指定的键，则返回defaultValuedefault V getOrDefault(Object key, V defaultValue)//返回此对象的hashCodeint hashCode()//判断此Map是否为空boolean isEmpty()//返回此Map中包含的键的Set视图。Set&lt;K&gt; keySet()//向Map中添加键值对V\tput(K key, V value)//将另一个Map的所有键值对添加到此Map中void putAll(Map&lt;? extends K,? extends V&gt; m)//根据键从Map中删除一个键值对V remove(Object key)//只有给出的key,value和存储的对的上，才进行删除操作default boolean remove(Object key, Object value)// /只有给出的key,value和存储的对的上，才进行替换操作default boolean replace(K key, V oldValue, V newValue)//返回此Map中存储的键值对的数量int size()//返回此Map中包含的值的Collection对象。Collection&lt;V&gt; values()\n2.5 Iterator接口\n迭代器接口，里面的方法用于遍历集合元素\n//对每个剩余元素执行给定的操作，直到所有元素都被处理或动作引发异常。default void forEachRemaining(Consumer&lt;? super E&gt; action)//如果迭代具有更多元素，则返回 true 。boolean hasNext()//返回迭代中的下一个元素。E next()//从底层集合中删除此迭代器返回的最后一个元素（可选操作）。default void remove()\n每个支持迭代器的集合都应该给出自己的实现。\n2.6.RandomAccess接口\n此接口是一个标记接口，实现它的集合类具备支持随机访问的能力。\n表明它们支持快速（通常为恒定时间）随机访问。\n2.7 基础接口的具体实现\n其他的所有接口或具体的实现类都是由Collection,Map,Iterator,Iterable衍生而来。\n抽象类分别实现了对应的接口\n如下图：\nCollection衍生集合派系：\ngraph LR\n\nAbstractCollection--impl--&gt;Collection\nAbstractList --extend--&gt;AbstractCollection\nAbstractSet --extend--&gt;AbstractCollection\nAbstractQueue--extend--&gt;AbstractCollection\nArrayQueue--extend--&gt;AbstractCollection\nAbstractSequentialList--extend--&gt;AbstractList\nArrayList --extend--&gt; AbstractList\nLinkedList--extend--&gt;AbstractSequentialList\nHashSet--extend--&gt;AbstractSet\nEnumSet--extend--&gt;AbstractSet\nTreeSet--extend--&gt;AbstractSet\nLinkedHashSet--extend--&gt;HashSet\nPriorityQueue--extend--&gt;AbstractQueue\nMap衍生集合派系：\ngraph LR\nAbstractMap--impl--&gt;Map\nHashMap--extend--&gt;AbstractMap\nTreeMap--extend--&gt;AbstractMap\nEnumMap--extend--&gt;AbstractMap\nWeakHashMap--extend--&gt;AbstractMap\nIdentityHashMap--extend--&gt;AbstractMap\nLinkedHashMap--extend--&gt;HashMap\n2.8 java类库中的具体集合有14个\n\n\n\n集合类型\n描述\n\n\n\n\nArrayList\n一种可以动态增长和缩减的索引序列\n\n\nLinkedList\n一种可以在任何位置进行高效地插入和删除操作的有序序列\n\n\nArrayDeque\n一种用循环数组实现的双端队列\n\n\nHashSet\n一种没有重复元素的无序集合\n\n\nTreeSet\n一种没有重复元素的有序集合\n\n\nEnumSet\n一种包含枚举类型值的集\n\n\nLinkedHashSet\n一种可以记住元素插入次序的集\n\n\nPriorityQueue\n一种允许高效删除最小/大元素的集合\n\n\nHashMap\n存储key-value结构的数据结构\n\n\nTreeMap\n存储key有序的key-value的数据结构\n\n\nEnumMap\n一种键值属于枚举类型的映射表\n\n\nLinkedHashMap\n一种可以记录键值插入顺序的结构\n\n\nWeakHashMap\n一种其值没用后可以被垃圾回收器回收的结构\n\n\nIdentityHashMap\n一种用==而不是用equals比较键值的结构\n\n\n\n在接下来的博客中我会具体的分析每个集合的特性和学习如何使用它们。\n","tags":["Java进阶"]},{"title":"9.3 Java集合之List(基本概念,API,存储原理)","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-9-3-Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E4%B9%8BList%EF%BC%88%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%8CAPI%EF%BC%8C%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86%EF%BC%89/","content":"1. List接口\n在学习List接口之前我们还是得复习下这张图\ngraph LR\n\nCollection --extend--&gt; Iterable\n\nList--extend--&gt; Collection\n\nSet--extend--&gt; Collection\n\nQueue--extend--&gt; Collection\n\nSortedMap --extend--&gt; Map\n\nSortedSet--extend--&gt;Set\nDeque--extend--&gt;Queue\nNavigableMap --extend--&gt; SortedMap\nNavigbleSet --extend--&gt; SortedSet\nListIterator--extend--&gt;Iterator\nRandomAccess\n从图中我们知道了，List接口继承了Collection接口。\n也就是说List接口是在Collection接口的基础上衍生出来的具体的链表数据结构的接口，在Java集合中，链表数据结构类都必须要实现List接口。\n通过查看List接口的定义并和Collection接口进行比较，可以找到，专属于List接口的方法有：\n//指定开始位置将另一个集合的元素插入进List中boolean addAll(int index, Collection&lt;? extends E&gt; c);//将List中的元素通过传入的Operator进行替换处理default void replaceAll(UnaryOperator&lt;E&gt; operator) {    Objects.requireNonNull(operator);    final ListIterator&lt;E&gt; li = this.listIterator();    while (li.hasNext()) {        li.set(operator.apply(li.next()));    }}//将List中的元素通过传入的Comparator进行排序处理default void sort(Comparator&lt;? super E&gt; c) {    Object[] a = this.toArray();    Arrays.sort(a, (Comparator) c);    ListIterator&lt;E&gt; i = this.listIterator();    for (Object e : a) {        i.next();        i.set((E) e);    }}//根据索引位置得到指定位置的元素E get(int index);//重置指定索引位置的元素E set(int index, E element);//向指定位置插入新的元素void add(int index, E element);//删除指定位置的元素E remove(int index);//得到第一个和对象o相等的对象的位置int indexOf(Object o);//得到最后一个和对象o相等的对象的位置int lastIndexOf(Object o);// 获得链表迭代器ListIterator&lt;E&gt; listIterator();//获得指定起始位置的链表迭代器ListIterator&lt;E&gt; listIterator(int index);//获得指定位置范围的链表List&lt;E&gt; subList(int fromIndex, int toIndex);\n2. List的具体实现\n\n\n\n集合类型\n描述\n\n\n\n\nArrayList\n一种可以动态增长和缩减的索引序列\n\n\nLinkedList\n一种可以在任何位置进行高效地插入和删除操作的有序序列\n\n\nArrayDeque\n一种用循环数组实现的双端队列\n\n\nHashSet\n一种没有重复元素的无序集合\n\n\nTreeSet\n一种没有重复元素的有序集合\n\n\nEnumSet\n一种包含枚举类型值的集\n\n\nLinkedHashSet\n一种可以记住元素插入次序的集\n\n\nPriorityQueue\n一种允许高效删除最小/大元素的集合\n\n\nHashMap\n存储key-value结构的数据结构\n\n\nTreeMap\n存储key有序的key-value的数据结构\n\n\nEnumMap\n一种键值属于枚举类型的映射表\n\n\nLinkedHashMap\n一种可以记录键值插入顺序的结构\n\n\nWeakHashMap\n一种其值没用后可以被垃圾回收器回收的结构\n\n\nIdentityHashMap\n一种用==而不是用equals比较键值的结构\n\n\n\n在具体的查看源码前，我们可以根据上面的表格先猜出那些具体的集合是通过实现List接口来定义的：\nArrayList,  LinkedList 这是两个比较明显的实现了。\n2.1 ArrayList\n简单介绍一下ArrayList的实现就是：\nArrayList是基于动态数组实现的一个链表数据结构的一个线程不安全的类。\n它的使用特性是插入，删除慢。修改快，查询快，且支持随机查询（根据get(int index)能以常数时间获取元素）。\n2.1.1 存储原理\n\n开辟存储存储空间：\n如果使用的是默认无参构造方法，size1.5&lt;=size+1，则为elementData开辟10个对象空间。\n如果使用的是指定数量的构造方法，size1.5&lt;=size+1，则为elementData开辟size+1个对象空间。\n扩容机制：\n每次添加前会对size+1进行检查\n如果在原数组的基础上增加了一半后大于size+1且小于MAX_ARRAY_SIZE,则将数组扩容至150%大小。\n\n具体的实现可以查阅Jdk源码来进行学习。\n2.1.2  性能测试实例\n//完整代码地址在文章最后public static void main(String[] args) {    List&lt;Integer&gt; list = addTest(100000);    System.out.println(\"修改耗时：\"+updateTest(list)+\"ms\");    System.out.println(\"查询耗时： \"+queryTest(list)+\"ms\");    System.out.println(\"插入耗时： \"+insertTest(list)+\"ms\");    System.out.println(\"删除耗时： \"+deleteTest(list)+\"ms\");}\n运行结果：\n添加耗时：5ms修改耗时：5ms查询耗时： 4ms插入耗时： 2760ms删除耗时： 2167msProcess finished with exit code 0\n上面的测试结果实事求是的验证了ArrayList的 插入，删除慢。\n2.2 LinkedList\n简单概述一下LinkedList的实现就是：LinkedList是基于双向链表实现的一个链表数据结构实现的一个线程不安全的类。\n2.2.1 存储原理\nLinkedList 采用链表存储，如果是在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e) addLast(E e)、removeFirst()、 removeLast()），时间复杂度为 O(1)，效率非常好。\n如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o)）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入。但是不需要进行原有数据的整体移动处理。\n需要注意的是： LinkedList不支持高效随机元素访问，ArrayList支持。 LinkedList则无需担心扩容问题，它的存储原理是需要的时候进行开辟空间，然后通过引用链接到一起，所以LinkedList的存储位置是碎片化，不连续的。\n具体的实现请查阅源码。\n2.2.2 性能测试实例\n//代码地址在文章最后public static void main(String[] args) {    List&lt;Integer&gt; list = addTest(100000);    System.out.println(\"修改耗时：\"+updateTest(list)+\"ms\");    System.out.println(\"查询耗时： \"+queryTest(list)+\"ms\");    System.out.println(\"插入耗时： \"+insertTest(list)+\"ms\");    System.out.println(\"删除耗时： \"+deleteTest(list)+\"ms\");}\n运行结果：\n添加耗时：6ms修改耗时：5284ms查询耗时： 4917ms插入耗时： 8351ms删除耗时： 7564msProcess finished with exit code 0\n可以看到，相比而言，其总体性能和ArrayList相比差距还是较大的,所以在实际的使用过程中, ArrayList是首选。\n2.3 Vector\n其实除了ArrayList, LinkedList两种有名的实现之外，JDK最开始提供的List的实现版本是Vector但是它的性能和功能都逐渐被淘汰了。\n2.3.1 存储原理\nVector底层用的是数组实现。 它的关键操作方法都是同步的，这使得线程安全，但是性能不好。\n\n开辟内存空间\n默认开辟10个内存空间\n扩容机制\n既然是使用数组实现，那么它也一定会有相应的扩容机制，每次添加前会对elementCount+1进行检查，\n如果它大于了数组长度，则进行扩容，采用的基本逻辑是如果指定了扩容大小capIncre，则扩为 oldCap+capIncre,否则进行两倍扩容。扩完后如果还是小于elementCount+1,则newCap = elementCount+1\n还进行了一些极限纠正。\n\n具体的实现请查阅源码。\n2.3.2 性能测试实例\n//完整代码地址见下方链接public static void main(String[] args) {    List&lt;Integer&gt; list = addTest(100000);    System.out.println(\"修改耗时：\"+updateTest(list)+\"ms\");    System.out.println(\"查询耗时： \"+queryTest(list)+\"ms\");    System.out.println(\"插入耗时： \"+insertTest(list)+\"ms\");    System.out.println(\"删除耗时： \"+deleteTest(list)+\"ms\");}\n运行结果：\n添加耗时：15ms修改耗时：12ms查询耗时： 6ms插入耗时： 3288ms删除耗时： 2760msProcess finished with exit code 0\n可以看到在这个测试实例下，Vector的性能和ArrayList相差不大。\n但是，在多线程的情况下它的性能下降的还是很厉害的。\n完整代码地址：\nhttps://gitee.com/yan-jiadou/study/tree/master/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/src/main/java/Progress/exa27_3\n\nLinkedList部分参考了文章： https://javaguide.cn/java/collection/java-collection-questions-01.html#collection-%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B9%8B-list\n\n","tags":["Java进阶"]},{"title":"9.4 Java集合之Map学习","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-9-4-Java%E9%9B%86%E5%90%88%E4%B9%8BMap%E5%AD%A6%E4%B9%A0/","content":"1.Map接口\ngraph LR\n    NavigableMap--extend--&gt;SortedMap--extend--&gt;Map\n从上图中我们知道Map是个独立的接口,它和Collection是一个层次的,他们之间不存在继承关系，但可能存在组合关系。\nMap是用来存储键值对的数据结构。\n1.1 Map接口定义\n\n\n\n方法定义\n方法描述\n\n\n\n\nint size()\n获得Map中存储键值对个数\n\n\nboolean isEmpty()\n判断Map是否为空\n\n\nboolean containsKey(Object key)\n判断Map中是否包含指定键\n\n\nboolean containsValue(Object value)\n判断Map中是否包含指定值\n\n\nV get(Object key)\n根据键对象在Map中获取对应的值\n\n\nV put(K key,V value)\n向Map中添加键值对\n\n\nV remove(Object key)\n从Map中删除指定键对应的键值对\n\n\n\n等等.\n从上面我们可以看到，如果我们想得到包含键值对的集合对Map进行遍历，我们可以对Map.Entry来进行操作。\n下面我们就来学习一下Map中对于Entry的定义\n1.2 Entry接口\n\n\n\n方法定义\n方法描述\n\n\n\n\nK getKey()\n获取Key值\n\n\nV getValue()\n获取Value值\n\n\nV setValue(V value)\n设置value并返回旧值\n\n\n\n等等.\n2. Map具体实现\n\n\n\n集合类型\n描述\n\n\n\n\nArrayList\n一种可以动态增长和缩减的索引序列\n\n\nLinkedList\n一种可以在任何位置进行高效地插入和删除操作的有序序列\n\n\nArrayDeque\n一种用循环数组实现的双端队列\n\n\nHashSet\n一种没有重复元素的无序集合\n\n\nTreeSet\n一种没有重复元素的有序集合\n\n\nEnumSet\n一种包含枚举类型值的集\n\n\nLinkedHashSet\n一种可以记住元素插入次序的集\n\n\nPriorityQueue\n一种允许高效删除最小/大元素的集合\n\n\nHashMap\n存储key-value结构的数据结构\n\n\nTreeMap\n存储key有序的key-value的数据结构\n\n\nEnumMap\n一种键值属于枚举类型的映射表\n\n\nLinkedHashMap\n一种可以记录键值插入顺序的结构\n\n\nWeakHashMap\n一种其值没用后可以被垃圾回收器回收的结构\n\n\nIdentityHashMap\n一种用==而不是用equals比较键值的结构\n\n\n\n从图中可以看到实现的Map的类有：\nHashMap, TreeMap, EnumMap, LinkedHashMap, WeakHashMap, IdentityHashMap 6个，\n如果算上AbstractMap，就是7个了。\n2.1 AbstractMap\n在Jdk中，和Collection体系一样，也提供了抽象类AbstractMap，其中包含了一些可复用的代码，方便在编写具体实现类时不做重复的工作。\n我们可以参考它的实现来学习如何去实现一个Map\n我们可以看一下其中的一些实现方法\n2.1.1 put方法实现\n/***  向Map中添加一个键值对**/public V put(K key, V value) {    throw new UnsupportedOperationException();}\n从这里我们可以看到，AbstractMap中是不提供put方法的实现的，因为它是随着存储原理的不同而不同的。\n2.1.2 get方法实现\n/*** 根据key在Map中获取它的value, 提供了基础实现，* 实现类逻辑很简单，就是先获得Entry的集合的迭代器，然后进行遍历比较key**/public V get(Object key) {    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();    if (key==null) {        while (i.hasNext()) {            Entry&lt;K,V&gt; e = i.next();            if (e.getKey()==null)                return e.getValue();        }    } else {        while (i.hasNext()) {            Entry&lt;K,V&gt; e = i.next();            if (key.equals(e.getKey()))                return e.getValue();        }    }    return null;}\n从这里我们可以看到，在Map中是允许key为null的数据存储。\n2.1.3 size()方法实现\n/*** 这里取得就是Entry的集合的大小**/public int size() {    return entrySet().size();}public abstract Set&lt;Entry&lt;K,V&gt;&gt; entrySet();\n2.1.4 isEmpty方法实现\n/*** 通过判断size()得到的值是否为0**/public boolean isEmpty() {    return size() == 0;}\n2.1.5 containsKey方法实现\n/*** 实现类逻辑很简单，就是先获得Entry的集合的迭代器，然后进行遍历比较key**/public boolean containsKey(Object key) {    Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator();    if (key==null) {        while (i.hasNext()) {            Entry&lt;K,V&gt; e = i.next();            if (e.getKey()==null)                return true;        }    } else {        while (i.hasNext()) {            Entry&lt;K,V&gt; e = i.next();            if (key.equals(e.getKey()))                return true;        }    }    return false;}\n2.1.6 containsValue方法实现\n/*** 实现类逻辑很简单，就是先获得Entry的集合的迭代器，然后进行遍历比较value**/public boolean containsValue(Object value) {    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();    if (value==null) {        while (i.hasNext()) {            Entry&lt;K,V&gt; e = i.next();            if (e.getValue()==null)                return true;        }    } else {        while (i.hasNext()) {            Entry&lt;K,V&gt; e = i.next();            if (value.equals(e.getValue()))                return true;        }    }    return false;}\n更多实现大家可以自行查阅源码进行学习。\n2.2 HashMap\n学习HashMap，首先我们要学习的是数据的存储结构：\n通过阅读源码我们知道了，HashMap的存储结构是数组+链表+红黑树存储，将数据存放到Node类型的数组中\ntransient Node&lt;K,V&gt;[] table;//可以知道Node实现了Entry接口static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    final int hash;    final K key;    V value;    Node&lt;K,V&gt; next;  }\n2.2.1 扩容机制\n既然是数组存储结构，那么它的扩容机制是我们一定要了解的！！\nHashMap的扩容逻辑放在方法resize()中，其逻辑如下:\n如果是oldCap=0且oldThr=0，初始化容量为：16，负载因子为：0.75  初始扩容阈值为：16*0.75=12如果oldCap&gt;0:    如果oldCap&gt;=(1&lt;&lt;30), 将阈值调为2^31-1.,不进行扩容.     如果oldCap&lt;(1&lt;&lt;30), 则newCap = oldCap*2, newThr = oldThr *2如果oldCap&lt;=0&amp;&amp;oldThr&gt;0   newCap = oldThr如果oldThr = 0, 计算之： newThr = newCap*loadFactor || MAX_VALUE然后进行新数组创建，旧数组的数据迁移到新数组中,在这个迁移过程中可能会出现树转链表的操作。\n总而言之,一般情况下HashMap的默认初始容量为16,负载因子为0.75, 扩容机制为2倍扩容。\n2.2.2 存储原理\n对于HashMap的存储原理，我们可以分为两类：\n\n\n不存在hash冲突的存储原理：如果不存在hash冲突，其存储原理是通过Key的（hash值 &amp; 数组长度-1）取余计算出该Node在Node数组中存储的位置，然后通过newNode方法新建一个Node并存储到指定位置。\n\n\n存在hash冲突的存储原理：首先我们要知道为啥存在冲突了呢？ 通过前面的存储原理我们知道元素存储的位置是通过(n - 1) &amp; hash计算出来的，那么 在n-1不变的情况下，不同的Key的hash值和n-1通过与运算可能得到相同的结果，相同的Key的hash值就更不用说了，所以hash冲突发生从情况有两种：\n\n使用相同的Key进行put: 对原有位置的value进行覆盖为最新的。\n使用不同的Key进行put:\n如果冲突的个数小于8个，采用链接法进行解决，就是将原有位置上最外层的元素的next指向它，如图：\n\n\n\n\n如果冲突的个数大于了8个，如果数组的长度大于或等于了最小树化容量（默认64）,则进行树化（链表转为红黑树），否则进行扩容操作。\n何时转会链表？\n当树的大小小于7的时候，会将树转回链表结构。\n为何要转成树结构？\n因为长度过长的化链表的检索速度是比较慢的O(n)，而树结构则检索比较快O(logn)。\n为何树结构用的是红黑树，而不是平衡二叉查找树？\n\n\nAVL 和RBT 都是二叉查找树的优化。其性能要远远好于二叉查找树。他们之间都有自己的优势，其应用上也有不同。\n\n\n结构对比： AVL的结构高度平衡，RBT的结构基本平衡。平衡度AVL &gt; RBT.\n\n\n查找对比： AVL 查找时间复杂度最好，最坏情况都是O(logN)。RBT 查找时间复杂度最好为O(logN)，最坏情况下比AVL略差。\n\n\n插入删除对比：\nAVL的插入和删除结点很容易造成树结构的不平衡，而RBT的平衡度要求较低。因此在大量数据插入的情况下，RBT需要通过旋转变色操作来重新达到平衡的频度要小于AVL。\n如果需要平衡处理时，RBT比AVL多一种变色操作，而且变色的时间复杂度在O(logN)数量级上。但是由于操作简单，所以在实践中这种变色仍然是非常快速的。\n当插入一个结点都引起了树的不平衡，AVL和RBT都最多需要2次旋转操作。但删除一个结点引起不平衡后，AVL最多需要logN 次旋转操作，而RBT最多只需要3次。因此两者插入一个结点的代价差不多，但删除一个结点的代价RBT要低一些。\nAVL和RBT的插入删除代价主要还是消耗在查找待操作的结点上。因此时间复杂度基本上都是与O(logN) 成正比的。\n\n\n总体评价：大量数据实践证明，RBT的总体统计性能要好于平衡二叉树。\n2.2.3 性能测试实例\nHashMap的存取效率都很高。\n//public static void main(String[] args) {   HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();   //测试存储效率    long start = System.currentTimeMillis();    for(int i=0;i&lt;10000000;i++){        map.put(i+ (int) (Math.random() * 100),i);    }    long end1 = System.currentTimeMillis();    System.out.println(\"存储耗时： \"+ (end1-start)+\"ms\");    for(int i=0;i&lt;10000000;i++){        map.get(i);    }    System.out.println(\"查询耗时：\"+(System.currentTimeMillis()-end1)+\"ms\");}\n运行结果：\n存储耗时： 4829ms查询耗时：154msProcess finished with exit code 0\n使用HashMap存取1000万的数据耗时在10秒以内，可见其存取效率了。\n2.3 TreeMap\n2.3.1 存储原理\nTreeMap是Map的有序实现，它会根据键的顺序将元素组织为一个搜索树，使用的存储结构是红黑树。\nprivate transient Entry&lt;K,V&gt; root;static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    K key;    V value;    Entry&lt;K,V&gt; left;    Entry&lt;K,V&gt; right;    Entry&lt;K,V&gt; parent;    boolean color = BLACK;}\n关于红黑树，感兴趣的同学可以仔细阅读源码，看看它是如何实现增删改查操作的。\nTreeMap默认的存储是根据Key的大小顺序存储的，也就是说遍历的时候是Key有序的遍历。默认是按 key 的升序排序\n2.3.2 性能测试实例\n//public static void main(String[] args) {    TreeMap&lt;Integer,Integer&gt; map = new TreeMap&lt;&gt;();    //测试存储效率    long start = System.currentTimeMillis();    for(int i=0;i&lt;10000000;i++){        map.put(i+ (int) (Math.random() * 100),i);    }    long end1 = System.currentTimeMillis();    System.out.println(\"存储耗时： \"+ (end1-start)+\"ms\");    for(int i=0;i&lt;10000000;i++){        map.get(i);    }    System.out.println(\"查询耗时：\"+(System.currentTimeMillis()-end1)+\"ms\");}\n运行结果：\n存储耗时： 5466ms查询耗时：1136msProcess finished with exit code 0\nTreeMap在相同条件下的存储性能还要略好于HashMap, 但其查询性能略低于HashMap， 但是它有着HashMap难以实现的特性：它可以实现有序存储。\n2.4 EnumMap\n2.4.1 存储原理\n基于数组实现，但是其中不存在扩容机制。\n这个Map实现比较特殊，它的Key只能是枚举类型的, 因为枚举类型的对象自带唯一属性，所以使用它无需考虑冲突问题。\n/*** 从这里可以看出,EnumMap在构造时已经将长度定义好了：*  就是枚举类中枚举值的数量**/public EnumMap(Class&lt;K&gt; keyType) {    this.keyType = keyType;    keyUniverse = getKeyUniverse(keyType);    vals = new Object[keyUniverse.length];}\npublic V put(K key, V value) {    typeCheck(key);    int index = key.ordinal();    Object oldValue = vals[index];    vals[index] = maskNull(value);    if (oldValue == null)        size++;    return unmaskNull(oldValue);}\nEnumMap的特性是存取效率极高，但是使用范围有限。\n2.4.2 使用实例\npublic class EnumMapStudy {    public static void main(String[] args) {        EnumMap&lt;TestEnum, String&gt; enumMap = new EnumMap&lt;&gt;(TestEnum.class);        enumMap.put(TestEnum.ONE, \"333\");        enumMap.put(TestEnum.ONE,\"999\");        for (Map.Entry&lt;TestEnum, String&gt; entry : enumMap.entrySet()) {            System.out.println(entry.getKey()+\":\"+entry.getValue());        }    }}enum TestEnum{    ONE,TWO, THREE,FOUR,FIVE,SIX,SEVEN,EIGHT,NINE,TEN;}\n运行结果：\nONE:999Process finished with exit code 0\n2.5 LinkedHashMap\n2.5.1 存储原理\nLinkedHashMap继承了HashMap实现，是对HashMap的一种增强：\n它会记住插入元素的顺序，这样在使用迭代器进行遍历的时候，遍历元素则是有序的。\nLinkedHashMap通过重写newNode方法，让其在新创建Node的时候将其插入顺序通过双向链表结构记录下来。\ntransient LinkedHashMap.Entry&lt;K,V&gt; head;transient LinkedHashMap.Entry&lt;K,V&gt; tail;\n注意：它和TreeMap的差别。\n2.5.2 性能测试实例\npublic static void main(String[] args) {    LinkedHashMap&lt;Integer,Integer&gt; map = new LinkedHashMap&lt;&gt;();    //测试存储效率    long start = System.currentTimeMillis();    for(int i=0;i&lt;10000000;i++){        map.put(i+ (int) (Math.random() * 100),i);    }    long end1 = System.currentTimeMillis();    System.out.println(\"存储耗时： \"+ (end1-start)+\"ms\");    for(int i=0;i&lt;10000000;i++){        map.get(i);    }    System.out.println(\"查询耗时：\"+(System.currentTimeMillis()-end1)+\"ms\");}\n运行结果：\n存储耗时： 3030ms查询耗时：2076msProcess finished with exit code 0\n由于它继承了HashMap，所以它在性能上和HashMap差不多，但是在能力上，它具有记忆键值对插入顺序的能力。\n2.6 WeakHashMap\n简单来说这个Map实现能有效的节省空间，当使用它存储键值对的时候，当值没有地方用它的时候可以被垃圾回收器回收从而提高空间利用率。\n2.6.1 存储原理\n通过阅读源码我们可以知道：\nEntry&lt;K,V&gt;[] table;\nWeakHashMap的存储方式是通过数组实现的，存储计算逻辑和HashMap类似，通过计算Key的hash,然后和数组最大索引值进行按位与运算，获得存储位置。\n2.6.2 WeakHashMap特性\n在WeakHashMap中，Key键是一个弱引用的键，如果Key键被回收，则在get该map中值后，会自动remove掉value\n如果Key键始终被强引用，则是无法被回收的；\n注意Value是被强引用的，所以不要让Value间接的引用了Key键，这将导致key始终被强引用\n适合于受Key的生命周期控制的缓存\n\nJava对象的强、软、弱和虚引用+ReferenceQueue-java教程-PHP中文网\n\n2.6.3 使用实例\npublic static void main(String[] args) throws InterruptedException {    WeakHashMap&lt;Integer,Integer&gt; map = new WeakHashMap&lt;&gt;();    for(int i=0;i&lt;1000;i++){        map.put(i,i);    }    System.out.println(map.size());}\n2.7 IdentityHashMap\n此Map实现“允许” 相同的Key存入， 原因是进行重复性检查用的是== 而不是equals， 这就使得如果Key是复杂引用类型，那么会出现存储相同的键值对的情况。\n2.7.1 存储原理\ntransient Object[] table;\n通过查阅源码，发现的存储结构也是数组。\n不过它的数据结构不用Entry了哦，而是直接时Object了哦，这和其他的Map实现不同了。\n所以就去看了put方法的实现，果然，看出了不一样的地方：\ntab[i] = k;tab[i + 1] = value;\n从这里可以看到，IdentityHashMap虽然用的数组存储，但是它的key和value是挨在一起存储的。\n具体的实现还需查阅源码。\n2.7.2 使用实例\npublic static void main(String[] args) {    IdentityHashMap&lt;Integer,Integer&gt; map = new IdentityHashMap&lt;&gt;();    for(int i=0;i&lt;10;i++){        map.put(new Integer(i),i);    }    for(int i=0;i&lt;10;i++){        map.put(i,i);    }    System.out.println(\"map 大小： \"+map.size());    IdentityHashMap&lt;Integer,Integer&gt; map1 = new IdentityHashMap&lt;&gt;();    for(int i=0;i&lt;10;i++){        map1.put(i,i);    }    for(int i=0;i&lt;10;i++){        map1.put(i,i);    }    System.out.println(\"map1 大小：\"+map1.size());}\n运行结果：\nmap 大小： 20map1 大小：10Process finished with exit code 0\n代码地址：\nJava基础学习/src/main/java/Progress/exa27_4 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"9.5 Java集合之Set学习","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-9-5-Java%E9%9B%86%E5%90%88%E4%B9%8BSet%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%8C%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86%EF%BC%8C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/","content":"1.Set接口\ngraph LR\n\nCollection --extend--&gt; Iterable\n\nList--extend--&gt; Collection\n\nSet--extend--&gt; Collection\n\nQueue--extend--&gt; Collection\n\nSortedMap --extend--&gt; Map\n\nSortedSet--extend--&gt;Set\nDeque--extend--&gt;Queue\nNavigableMap --extend--&gt; SortedMap\nNavigbleSet --extend--&gt; SortedSet\nListIterator--extend--&gt;Iterator\nRandomAccess\n在正式学习Set接口之前，我们得先复习一下上面的图片。\n我们知道Set接口继承Collection接口，但是又有自己的特点，它存放一组相互不重复的元素集。\n和Collection的定义相比,实际上并没有什么特殊的方法定义, 只是它的实现逻辑要进行特殊化.\n现在我们思考一下，为何没有呢？ 其实这个问题我们可以思考一下Collection中定义的方法是否能满足Set特性？\n1.1 Set的特性是什么？\nSet的最大的特性就是存储不重复的元素。\n那么我们只需要保证使用Set的add()时具有排重逻辑。 其他的和Collection无异。\n注意：我个人认为无序并不是Set的主要特性，无序是Hash存储的特性。\n2.具体实现\n老规矩，看图复习，然后根据具体的类进行学习。\n\n\n\n集合类型\n描述\n\n\n\n\nArrayList\n一种可以动态增长和缩减的索引序列\n\n\nLinkedList\n一种可以在任何位置进行高效地插入和删除操作的有序序列\n\n\nArrayDeque\n一种用循环数组实现的双端队列\n\n\nHashSet\n一种没有重复元素的无序集合\n\n\nTreeSet\n一种没有重复元素的有序集合\n\n\nEnumSet\n一种包含枚举类型值的集\n\n\nLinkedHashSet\n一种可以记住元素插入次序的集\n\n\nPriorityQueue\n一种允许高效删除最小/大元素的集合\n\n\nHashMap\n存储key-value结构的数据结构\n\n\nTreeMap\n存储key有序的key-value的数据结构\n\n\nEnumMap\n一种键值属于枚举类型的映射表\n\n\nLinkedHashMap\n一种可以记录键值插入顺序的结构\n\n\nWeakHashMap\n一种其值没用后可以被垃圾回收器回收的结构\n\n\nIdentityHashMap\n一种用==而不是用equals比较键值的结构\n\n\n\n上面的图片中我们可以看出，实现Set的实现可能有：\nHashSet, TreeSet, EnumSet, LinkedHashSet\n嗯？ 这不是和HashMap, TreeMap, EnumMap,LinkedHashMap有异曲同工之妙吗？\n别着急，更神奇的还在后头！！\n2.1 HashSet\n通过查阅源码，我们发现了，HashSet中维护的存储结构是HashMap。\n2.1.1 存储原理\n当进行add(E e)的时候，就会向map中put(e,Object常量)，如果返回的是null,则表示添加成功，如果返回的不是null，则表示Map中已经存在键值对，添加失败。\n当进行contains(Object o)的时候，调用的也是Map的containsKey(Object o);\n所以HashSet的存储原理就是利用HashMap的键不可重复的特性进行实现的。\n由于HashSet借助了HashMap进行存储，所以对其进行存储时无法保证有序存储。\n2.1.2 性能测试\n//完整代码存放在git仓库中，地址在文章底部public static void main(String[] args) {    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();    long start = System.currentTimeMillis();    for(int i=0;i&lt;10000000;i++){        set.add(i);    }    System.out.println(\"存储耗时： \"+(System.currentTimeMillis()-start)+\" ms\");    long start2 = System.currentTimeMillis();    for(int i=0;i&lt;10000000;i++){       boolean c = set.contains(i);    }    System.out.println(\"查询耗时： \"+(System.currentTimeMillis()-start2)+\" ms\");}\n运行结果：\n存储耗时： 4380 ms查询耗时： 214 msProcess finished with exit code 0\n2.2 TreeSet\n通过查阅源码，我们可以知道，TreeSet中维护的存储结构是NavigableMap接口，默认实现是TreeMap，\n简单来说，TreeSet也是借助TreeMap来进行存储的，TreeMap是Map的有序实现，它会根据键的顺序将元素组织为一个搜索树。\n2.2.1 存储原理\n当进行add(E e)的时候，就会向map中put(e,Object常量)，如果返回的是null,则表示添加成功，如果返回的不是null，则表示Map中已经存在键值对，添加失败。\n当进行contains(Object o)的时候，调用的也是Map的containsKey(Object o);\n所以TreeSet的存储原理就是利用TreeMap的键不可重复的特性进行实现的。\n由于TreeSet借助了TreeMap进行存储，所以对其进行存储可以保证存储的顺序。\n2.2.2 性能测试\n//完整代码存放在git仓库中，地址在文章底部public static void main(String[] args) {    TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;();    long start = System.currentTimeMillis();    for(int i=100;i&gt;0;i--){        set.add(i);    }    System.out.println(\"存储耗时： \"+(System.currentTimeMillis()-start)+\" ms\");    long start2 = System.currentTimeMillis();    for(int i=0;i&lt;100;i++){        boolean c = set.contains(i);    }    System.out.println(\"查询耗时： \"+(System.currentTimeMillis()-start2)+\" ms\");    for(Integer i:set){        System.out.print(i+\" \");    }}\n运行结果：\n存储耗时： 2 ms查询耗时： 1 ms1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 Process finished with exit code 0\n可以看到在TreeSet中，存储Integer是自然升序排序的。\n2.3 EnumSet（了解即可）\n它是一个继承了AbstractSet的抽象类。\n其中一个具体的实现是：RegularEnumSet  它是Set的常规实现, EnumSet的实现并不是一个公共的类，所以它不能作为公共API直接使用。\n它是用来存储枚举的Set集合。这个类好像只能存，不能取。\n2.3.1 存储原理\n我们以RegularEnum为例子进行存储原理的学习。\n通过阅读add源码， 我们发现其中关键在于使用了elements这个变量来记录传入的值。\n//add操作实际是用位运算，//将这个long值对应你传入的枚举值的下标的那个bit位改成1，//比如我传入的是IdentityEnu.DRIVER, 对应的ordinal是1，//则是将elements的bit位中的第2位改成1，public boolean add(E e) {    typeCheck(e);    long oldElements = elements;    elements |= (1L &lt;&lt; ((Enum&lt;?&gt;)e).ordinal());    return elements != oldElements;}//contains操作就是检查指定位的是否为0来判断public boolean contains(Object e) {    if (e == null)        return false;    Class&lt;?&gt; eClass = e.getClass();    if (eClass != elementType &amp;&amp; eClass.getSuperclass() != elementType)        return false;    return (elements &amp; (1L &lt;&lt; ((Enum&lt;?&gt;)e).ordinal())) != 0;}\n比较特殊的一点是，elements用的是long,它只有64位，所以，它存储的枚举类的值不能超过64.\n2.4 LinkedHashSet\n这个类继承的HashSet，所以它的存储结构仍然是HashMap。\n查看LinkedHashSet的源码时，你也许会这么想，但是，真的是这样的吗？\n但是我们需要实事求是，看下源码到底是怎么运行的：\nHashSet(int initialCapacity, float loadFactor, boolean dummy) {    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);}\n看到这里，我们意识到猜错了，其实LinkedHashSet的存储结构是LinkedHashMap!!\nLinkedHashMap是对HashMap的一种增强：\n它会记住插入元素的顺序，这样在使用迭代器进行遍历的时候，遍历元素则是有序的。\nLinkedHashMap通过重写newNode方法，让其在新创建Node的时候将其插入顺序通过双向链表结构记录下来。\ntransient LinkedHashMap.Entry&lt;K,V&gt; head;transient LinkedHashMap.Entry&lt;K,V&gt; tail;\n2.4.1 存储原理\n当进行add(E e)的时候，就会向map中put(e,Object常量)，如果返回的是null,则表示添加成功，如果返回的不是null，则表示Map中已经存在键值对，添加失败。\n当进行contains(Object o)的时候，调用的也是Map的containsKey(Object o);\n所以LinkedHashSet的存储原理就是利用LinkedHashMap的键不可重复的特性进行实现的。\n由于LinkedHashSet借助了LinkedHashMap进行存储，所以对其进行存储可以保证存储的顺序。\n2.4.2 性能测试\npublic static void main(String[] args) {    LinkedHashSet&lt;Integer&gt; set = new LinkedHashSet&lt;&gt;();    long start = System.currentTimeMillis();    for(int i=100;i&gt;0;i--){        set.add(i);    }    System.out.println(\"存储耗时： \"+(System.currentTimeMillis()-start)+\" ms\");    long start2 = System.currentTimeMillis();    for(int i=0;i&lt;100;i++){        boolean c = set.contains(i);    }    System.out.println(\"查询耗时： \"+(System.currentTimeMillis()-start2)+\" ms\");    for(Integer i:set){        System.out.print(i+\" \");    }}\n运行结果：\n存储耗时： 0 ms查询耗时： 0 ms100 99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 Process finished with exit code 0\n2.4.3 代码地址\nJava基础学习/src/main/java/Progress/exa27_5 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"9.6 Java集合之Queue学习","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-9-6-Java%E9%9B%86%E5%90%88%E4%B9%8BQueue%E5%AD%A6%E4%B9%A0-Queue%E6%8E%A5%E5%8F%A3%EF%BC%8CPriorityQueue/","content":"1. Queue接口\ngraph LR\n\nCollection --extend--&gt; Iterable\n\nList--extend--&gt; Collection\n\nSet--extend--&gt; Collection\n\nQueue--extend--&gt; Collection\n\nSortedMap --extend--&gt; Map\n\nSortedSet--extend--&gt;Set\nDeque--extend--&gt;Queue\nNavigableMap --extend--&gt; SortedMap\nNavigbleSet --extend--&gt; SortedSet\nListIterator--extend--&gt;Iterator\nRandomAccess\n在正式学习Queue之前，我们得先复习一下上面的图片。\nQueue接口继承于Collection接口，但是它有具有自己的数据结构特点，Queue，队列，它的特性是先进先出。\n下面我们看一下Queue接口有没有不同于Collection的特殊的定义：\n//向队列添加元素并返回true，如果队列没有剩余空间，抛出异常boolean add(E e);//在容量充足的情况下添加元素,添加成功返回true,失败返回falseboolean offer(E e);//从队列中取出元素并删除，如果队列为空，则抛出异常E remove();//从队列中取出元素并删除，如果队列为空，则返回nullE poll();//取出队列的第一个元素，但不删除，如果队列为空，则抛出异常E element();//取出队列的第一个元素，但不删除，如果队列为空，则返回nullE peek();\n1.1 Queue的特性\nQueue(队列)最大的特性就是，先进先出,按元素存入的顺序排队处理，对这个数据结构的所有操作应遵循这个原理。\n2.具体实现\n\n\n\n集合类型\n描述\n\n\n\n\nArrayList\n一种可以动态增长和缩减的索引序列\n\n\nLinkedList\n一种可以在任何位置进行高效地插入和删除操作的有序序列\n\n\nArrayDeque\n一种用循环数组实现的双端队列\n\n\nHashSet\n一种没有重复元素的无序集合\n\n\nTreeSet\n一种没有重复元素的有序集合\n\n\nEnumSet\n一种包含枚举类型值的集\n\n\nLinkedHashSet\n一种可以记住元素插入次序的集\n\n\nPriorityQueue\n一种允许高效删除最小/大元素的集合\n\n\nHashMap\n存储key-value结构的数据结构\n\n\nTreeMap\n存储key有序的key-value的数据结构\n\n\nEnumMap\n一种键值属于枚举类型的映射表\n\n\nLinkedHashMap\n一种可以记录键值插入顺序的结构\n\n\nWeakHashMap\n一种其值没用后可以被垃圾回收器回收的结构\n\n\nIdentityHashMap\n一种用==而不是用equals比较键值的结构\n\n\n\n从图中，我们可以猜到实现Queue接口的具体类会有：PriorityQueue\n也可以猜出其也会有一个对应的AbstractQueue抽象类，提供了一些公用代码。\n下面进行源码阅读验证一下自己的猜想是否正确\n2.1 AbstractQueue\n果然，JDK对于Queue接口提供了一些基础实现，这个类的实现的方法不多。\n2.1.1 add方法\n//接口的定义是：向队列中添加元素，如果队列满了，则抛出异常。//可以看到它的实现遵循了接口中对这个方法的定义public boolean add(E e) {    if (offer(e))        return true;    else        throw new IllegalStateException(\"Queue full\");}\n2.1.2 remove方法\n//接口的定义是：取出一个元素并删除，如果队列为空，则抛出异常public E remove() {    E x = poll();    if (x != null)        return x;    else        throw new NoSuchElementException();}\n2.1.3 element方法\n//接口的定义是：取出一个元素但不删除，如果队列为空，则抛出异常public E element() {    E x = peek();    if (x != null)        return x;    else        throw new NoSuchElementException();}\n2.1.4 clear方法\n//清空队列public void clear() {    while (poll() != null);}\n2.1.5 addAll方法\n// 将集合c中的元素都添加到队列中，如果c为空则抛出异常// 如果c就是队列本身，也抛出异常public boolean addAll(Collection&lt;? extends E&gt; c) {    if (c == null)        throw new NullPointerException();    if (c == this)        throw new IllegalArgumentException();    boolean modified = false;    for (E e : c)        if (add(e))            modified = true;    return modified;}\n2.2 PriorityQueue\n这个类是Queue的一个具体实现，它实现的是名为优先队列的数据结构，它会根据优先级的设置来完进行进队，出队的操作。\n2.2.1 存储原理\ntransient Object[] queue; // non-private to simplify nested class access\n通过查阅源码我们可以得知，PriorityQueue使用的数组存储。\n说到数组，我们就不得不说它的扩容机制了哈哈哈。\n2.2.1.1 扩容机制\n由于代码比较简单，我们就简单的浅读下它的扩容源码：\nprivate void grow(int minCapacity) {    //获取queue原来的长度    int oldCapacity = queue.length;    // 如果oldCap小于64，则newCap = oldCap*2+2    // 如果oldCap&gt;=64, 则newCap = oldCap*1.5    int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ?                                     (oldCapacity + 2) :                                     (oldCapacity &gt;&gt; 1));    // 超大容量检查处理    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    queue = Arrays.copyOf(queue, newCapacity);}\n关于PriorityQueue的扩容机制，总结起来就是：如果原始长度小于64，则扩1倍，否则扩0.5倍。\n2.2.2 优先级机制\n上面介绍了它的存储原理，下面来介绍它的优先级机制。\n通过阅读构造方法源码，我们可以发现，它提供了下面类型的构造方法\n//可以传入一个比较器，我们可以猜出这个比较器应该就是实现优先级机制的关键public PriorityQueue(Comparator&lt;? super E&gt; comparator) {    this(DEFAULT_INITIAL_CAPACITY, comparator);}\n下面我们阅读一下它的offer方法：\npublic boolean offer(E e) {    if (e == null)        throw new NullPointerException();    modCount++;    int i = size;    if (i &gt;= queue.length)        grow(i + 1);    size = i + 1;    if (i == 0)        queue[0] = e;    else        siftUp(i, e);//关键点，这个方法有啥用？    return true;}\n我们会发现一个名为siftUp方法，当我们点进去的时候：\n//会发现，这里用到比较器了，它的逻辑是：// 如果传入比较器了，则用传入的比较器，否则就用元素自身默认的比较器// 那么问题来了，如果传入的元素并没有实现Comparable接口呢？ private void siftUp(int k, E x) {    if (comparator != null)        siftUpUsingComparator(k, x);    else        siftUpComparable(k, x);}\n我们进入siftUpComparable方法看看：\n//它的逻辑是首先获取自己的比较器，然后进行优先位置调整private void siftUpComparable(int k, E x) {    Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x;    while (k &gt; 0) {        int parent = (k - 1) &gt;&gt;&gt; 1;        Object e = queue[parent];        if (key.compareTo((E) e) &gt;= 0)            break;        queue[k] = e;        k = parent;    }    queue[k] = key;}\n也就是说，每次进行元素入队的时候都要进行位置调整。\n2.3.2 使用案例\nPriorityQueue， 简单来说就是优先队列，下面我们陆续测试队列的功能和性能。\n正常使用\npublic class PriorityQueueStudy {    public static void main(String[] args) {        Queue&lt;Integer&gt; queue = addTest();        System.out.println(\"队列大小：\"+queue.size());        queue = pollTest(queue);        System.out.println(\"取出元素后队列大小：\"+queue.size());    }    /**     * 添加元素进入队列     * @return     */    public static Queue&lt;Integer&gt; addTest(){        long start = System.currentTimeMillis();        Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();        for(int i=1000;i&gt;0;i--){            boolean sus = queue.offer(i);            if(sus) System.out.println(\"入队成功！\");        }        System.out.println(\"添加耗时：\"+ (System.currentTimeMillis()-start)+\"ms\");        return queue;    }    public static Queue&lt;Integer&gt; pollTest(Queue&lt;Integer&gt; queue){        System.out.println(\"取出10个元素\");        for(int i=0;i&lt;10;i++){            System.out.print(queue.poll());        }        System.out.println();        return queue;    }}\n运行结果：\n......入队成功！入队成功！入队成功！入队成功！入队成功！添加耗时：18ms队列大小：1000取出10个元素12345678910取出元素后队列大小：990\n可以看到，当元素是Integer类型的时候，优先队列会默认使用Integer的比较器进行优先级排序。\n非正常使用\n下面我们试图向队列存入不实现Comparable接口的实例\npublic static Queue&lt;PriorityQueueStudy&gt; noCompareToTest(){    long start = System.currentTimeMillis();    Queue&lt;PriorityQueueStudy&gt; queue = new PriorityQueue&lt;&gt;();    for(int i=10;i&gt;0;i--){        boolean sus = queue.offer(new PriorityQueueStudy());        if(sus) System.out.println(\"入队成功！\");    }    System.out.println(\"添加耗时：\"+ (System.currentTimeMillis()-start)+\"ms\");    return queue;}\nException in thread \"main\" java.lang.ClassCastException: Progress.exa27_6.PriorityQueueStudy cannot be cast to java.lang.Comparable\tat java.util.PriorityQueue.siftUpComparable(PriorityQueue.java:652)\tat java.util.PriorityQueue.siftUp(PriorityQueue.java:647)\tat java.util.PriorityQueue.offer(PriorityQueue.java:344)\tat Progress.exa27_6.PriorityQueueStudy.noCompareToTest(PriorityQueueStudy.java:46)\tat Progress.exa27_6.PriorityQueueStudy.main(PriorityQueueStudy.java:15)\n发现报错了，所以当我们使用优先队列的时候，这个点我们需要注意！！！\n3.代码地址\nJava基础学习/src/main/java/Progress/exa27_6 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"9.6 Java集合之Deque(双端队列)学习","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-9-7-Java%E9%9B%86%E5%90%88Deque%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%EF%BC%89/","content":"1. Deque接口\ngraph LR\n\nCollection --extend--&gt; Iterable\n\nList--extend--&gt; Collection\n\nSet--extend--&gt; Collection\n\nQueue--extend--&gt; Collection\n\nSortedMap --extend--&gt; Map\n\nSortedSet--extend--&gt;Set\nDeque--extend--&gt;Queue\nNavigableMap --extend--&gt; SortedMap\nNavigbleSet --extend--&gt; SortedSet\nListIterator--extend--&gt;Iterator\nRandomAccess\n双端队列，它的特点是既支持先进先出，也支持先进后出。\n通过上面的图片可以看到，Deque继承了Queue，它在Queue的基础上进行了增强。\n下面了解一下Deque不同于Queue的特殊方法定义：\n//在队列的前面插入元素，如果队列容量已满，则抛出异常void addFirst(E e);//在队列后面插入元素，如果队列已满，则抛出异常void addLast(E e);//如果队列容量允许，向队列前面添加元素，成功返回true， 否则返回falseboolean offerFirst(E e);//如果队列容量允许，在队列后面添加元素，成功返回true， 否则返回falseboolean offerLast(E e);//从队列中取出前面的元素并删除，如果队列为空，则抛出异常E removeFirst();//从队列中取出后面的元素并删除，如果队列为空，则抛出异常E removeLast();//从队列中取出前面的元素并删除，如果队列为空，则返回nullE pollFirst();//从队列中取出后面的元素并删除，如果队列为空，则返回nullE pollLast();//取出队列前面的元素但不删除,如果队列为空则抛出异常E getFirst();//取出队列后面的元素但不删除，如果队列为空则抛出异常E getLast();//取出队列前面的元素但不删除,如果队列为空，则返回nullE peekFirst();//取出队列后面的元素但不删除，如果队列为空，则返回nullE peekLast();//删除前面开始第一个和o相等的元素boolean removeFirstOccurrence(Object o);//删除后面开始第一个和o相等的元素boolean removeLastOccurrence(Object o);//这个方法和addFirst等价void push(E e);// 这个方法和removeFirst等价E pop();//返回一个倒序迭代器Iterator&lt;E&gt; descendingIterator();\n2.具体实现\n\n\n\n集合类型\n描述\n\n\n\n\nArrayList\n一种可以动态增长和缩减的索引序列\n\n\nLinkedList\n一种可以在任何位置进行高效地插入和删除操作的有序序列\n\n\nArrayDeque\n一种用循环数组实现的双端队列\n\n\nHashSet\n一种没有重复元素的无序集合\n\n\nTreeSet\n一种没有重复元素的有序集合\n\n\nEnumSet\n一种包含枚举类型值的集\n\n\nLinkedHashSet\n一种可以记住元素插入次序的集\n\n\nPriorityQueue\n一种允许高效删除最小/大元素的集合\n\n\nHashMap\n存储key-value结构的数据结构\n\n\nTreeMap\n存储key有序的key-value的数据结构\n\n\nEnumMap\n一种键值属于枚举类型的映射表\n\n\nLinkedHashMap\n一种可以记录键值插入顺序的结构\n\n\nWeakHashMap\n一种其值没用后可以被垃圾回收器回收的结构\n\n\nIdentityHashMap\n一种用==而不是用equals比较键值的结构\n\n\n\n从图中我们可以看到实现Deque接口的具体类有：ArrayDeque\n通过之前的经验，我们也可以猜出也会有一个对应的AbstractDeque抽象类，提供了一些公用代码。\n2.1 AbstractDeque（并不存在）\n有时，根据经验也会判断失误，事实上，Jdk里并没有一个名为AbstractDeque的抽象类哈哈哈。\n猜测归猜测，我们还是要实事求是的去验证。\n不过有了意外发现，除了ArrayDeque外，LinkedList也实现了Deque接口哦。\n2.2 ArrayDeque\n2.2.1 存储原理\ntransient Object[] elements; // non-private to simplify nested class access\n通过阅读源码可以知道，ArrayDeque的存储结构也是基于数组实现的。\n既然是基于数组，那么它一定会有相应的扩容机制：\nprivate void doubleCapacity() {    assert head == tail;    int p = head;    int n = elements.length;    int r = n - p; // number of elements to the right of p    int newCapacity = n &lt;&lt; 1;    if (newCapacity &lt; 0)        throw new IllegalStateException(\"Sorry, deque too big\");    Object[] a = new Object[newCapacity];    System.arraycopy(elements, p, a, 0, r);    System.arraycopy(elements, 0, a, r, p);    elements = a;    head = 0;    tail = n;}\n在ArrayDeque的扩容也很直接，直接doubleCapacity，当容量满了后，直接将其容量扩为原来的两倍。\n2.2.2 使用案例\npublic class ArrayDequeStudy {    public static void main(String[] args) {        FIFOTest();        LIFOTest();    }    /**     * 先进先出测试     */    public static void FIFOTest(){        ArrayDeque&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;();        System.out.println(\"将0-99按顺序放入队列中\");        for(int i=0;i&lt;100;i++){            queue.addLast(i);        }        System.out.println(queue.size());        System.out.println(\"取出10个元素： \");        for(int i=0;i&lt;10;i++){            System.out.print(queue.poll()+\" \");        }        System.out.println(\"队列大小： \");        System.out.println(queue.size());    }    /**     * 后进先出测试     */    public static void LIFOTest(){        ArrayDeque&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;();        System.out.println(\"将0-99按顺序放入栈中\");        for(int i=0;i&lt;100;i++){            queue.addFirst(i);        }        System.out.println(queue.size());        System.out.println(\"取出10个元素： \");        for(int i=0;i&lt;10;i++){            System.out.print(queue.poll()+\" \");        }        System.out.println(\"栈大小： \");        System.out.println(queue.size());    }}\n运行结果：\n将0-99按顺序放入队列中100取出10个元素： 0 1 2 3 4 5 6 7 8 9 队列大小： 90将0-99按顺序放入栈中100取出10个元素： 99 98 97 96 95 94 93 92 91 90 栈大小： 90Process finished with exit code 0\n2.3 LinkedList\n简单概述一下LinkedList的实现就是：\nLinkedList是基于双向链表实现的一个链表数据结构实现的一个线程不安全的类。\n2.3.1 存储原理\nLinkedList 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e) addLast(E e)、removeFirst()、 removeLast()），\n时间复杂度为 O(1)，如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o)）， 时间复杂度为 O(n) ，因为需要先移动到指定位置\n再插入。但是不需要进行原有数据的整体移动处理，这相比于数组实现具有它自己的优势\n需要注意的是： LinkedList不支持高效随机元素访问，ArrayList支持。 LinkedList则无需担心扩容问题，它的存储原理是需要的时候进行开辟空间，然后通过引用链接到一起，所以LinkedList的存储位置是碎片化，不连续的。\n具体的实现请查阅源码。\n2.3.2 使用案例\npublic class LinkedListStudy {    public static void main(String[] args) {        FIFOTest();        LIFOTest();    }    /**     * 先进先出测试     */    public static void FIFOTest(){        LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();        System.out.println(\"将0-99按顺序放入队列中\");        for(int i=0;i&lt;100;i++){            queue.addLast(i);        }        System.out.println(queue.size());        System.out.println(\"取出10个元素： \");        for(int i=0;i&lt;10;i++){            System.out.print(queue.poll()+\" \");        }        System.out.println(\"队列大小： \");        System.out.println(queue.size());    }    /**     * 后进先出测试     */    public static void LIFOTest(){        LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();        System.out.println(\"将0-99按顺序放入栈中\");        for(int i=0;i&lt;100;i++){            queue.addFirst(i);        }        System.out.println(queue.size());        System.out.println(\"取出10个元素： \");        for(int i=0;i&lt;10;i++){            System.out.print(queue.poll()+\" \");        }        System.out.println(\"栈大小： \");        System.out.println(queue.size());    }}\n运行结果：\n将0-99按顺序放入队列中100取出10个元素： 0 1 2 3 4 5 6 7 8 9 队列大小： 90将0-99按顺序放入栈中100取出10个元素： 99 98 97 96 95 94 93 92 91 90 栈大小： 90Process finished with exit code 0\n3.代码地址\nJava基础学习/src/main/java/Progress/exa27_7 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"10.1 Java进阶之线程的概念","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-10-1-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BB%BB%E5%8A%A1%EF%BC%8CThread%E7%B1%BB%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%8C%E9%94%81%E5%90%8C%E6%AD%A5/","content":"本博客代码完整，所有实例均可正常运行，代码仓库链接在文章底部，需要的自取。\nJava中重要机制之一就是支持内部多线程：在一个Java程序中允许同时运行多个任务。\n1.线程概念\n1.1 什么是线程？\n我们写一段程序，然后运行这段程序，当我们运行这段程序，实际上就启动了一个线程，也就是说线程是运行程序的单位。 而这个程序，就是一个任务。\n线程本质上讲就是执行任务的对象，如果把线程比作一台打印机，那么任务就是一份需要打印的文档。\n线程提供了运行一个任务的机制，对于Java, 可以在一个程序中并发地启动多个线程，这些线程可以同时运行。\n1.2 使用多线程的好处\n多线程可以使程序执行的更快，让程序的交互性更强，从而使得程序执行效率的提升。\n简单来说，如果当我们写一段程序处理一份数据时，如果我们使用多线程编程去解决这个问题，我们能更快的获得结果。\n如果使用多线程让程序同时执行不同类型的任务，就能让程序同时服务多个不同的请求，请求和请求之间可以不用排队，很快就能得到响应。\n2.Java如何定义任务和线程\n本节主要学习如何使用Java语言编写多线程程序。\n2.1 任务定义\n在Java中定义一个任务就是定义实现Runnable接口的一个类（Runnable中只有一个run方法）\n2.1.1 Runnable接口\n// 任务接口，Java中定义一个任务类必须要实现这个接口public interface Runnable {    public abstract void run();}\n可以看到，Runnable只有一个方法的定义，就是run，也就是说每个任务需要实现这个接口，给出run的程序，线程具体执行的代码就是这个run的实现。\n例如下面定义一个名为PrintChar的任务类：\npublic class PrintChar implements Runnable{        private final char charToPrint;    private final int times;    public PrintChar(char c,int t) {        charToPrint=c;        times=t;    }    @Override    public void run() {        for(int i=0;i&lt;times;i++) {            System.out.print(charToPrint);        }    }}\n定义好这个类后，当我们学习了Thread的使用，便可以创建任务对象，然后让线程去执行它。\n2.2 线程定义\n在Java中，我们只需要新建一个Thread对象，然后将具体任务对象作为参数传入，接着执行start方法即可开启一个线程并执行一个任务。\n例如：\npublic static void main(String[] args) {    //新建任务对象：这里新建了两个任务    Runnable printA=new PrintChar('a',100);    Runnable printB=new PrintChar('b',100);    //新建线程对象：这里新建了两个线程    Thread thread1=new Thread(printA);    Thread thread2=new Thread(printB);    //并行运行thread1,thread2    thread1.start();    thread2.start();}\n运行结果：\nabababbaabbaabababbababababaababbaabProcess finished with exit code -1\n这样的话，在程序中，这两个线程是不会相互影响的同时运行的，如果使用单线程(常规编程)，那么花费的时间会更长。\n3.学习Thread类\n通过上面的学习，我们写出了第一个多线程程序，可以看到多线程涉及的类主要有两个，一个是我们自定义的任务类，另一个就是Jdk提供了Thread类，下面我们对其进行学习。\n下面我们看下这个类的类图:\nclassDiagram\n\n    class Runnable{\n        \n    }\n\n    class Thread{\n        +Thread()\n        +Thread(task:Runnable)\n        +start() void\n        +isAlive() boolean\n        +setPriority(p:int) void\n        +join() void\n        +sleep(millis: long) void\n        +yield() void\n        +interrupt() void\n    }\n\n    Runnable &lt;|.. thread&lt; pre&gt;\n3.1 Thread实现了Runnable接口\n从上面我们可以看出Thread也实现了Runnable接口，所以，我们是不是也能通过Thread定义自己的任务呢？\n答案是可以的,下面首先定义一个TaskThreadDemo类：\npublic class TaskThreadDemo extends Thread {    private final char charToPrint;    private final int times;    public TaskThreadDemo(char charToPrint, int times) {        this.charToPrint = charToPrint;        this.times = times;    }    public void run(){        for(int i=0;i&lt;times;i++) {            System.out.print(charToPrint);        }    }}\n然后使用它：\npublic static void main(String[] args) {    Thread thread1 = new TaskThreadDemo('a',100);    Thread thread2 = new TaskThreadDemo('b',100);    thread1.start();    thread2.start();}\n运行结果：\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbProcess finished with exit code 0\n但是这种方法并不常用，因为让任务类去继承Thread并不是一个灵活的做法.\n因为在Java中一个类只能继承一个类，但可以实现多个接口，我们应该让任务类去继承更有价值的类。\n3.2 Thread中的方法学习\n可以通过下面的例子进行学习\npublic static void main(String[] args) throws InterruptedException {    //创建任务    Runnable printA=new PrintChar('a',5);    Runnable printB=new PrintChar('b',5);    //新建线程    Thread thread1 = new Thread(printA);    Thread thread2 = new Thread(printB);    //理论上优先级值越小, 执行越优先    thread1.setPriority(10);    thread2.setPriority(1);    //并行开始运行thread1,thread2    thread1.start();    thread2.start();    //等待thread1,thread2执行结束    thread1.join();    thread2.join();    System.out.println();    /**     * 利用isAlive对线程状态进行检查     */    while (true){        //让当前线程进入休眠状态        Thread.sleep(1000);        boolean thread1Alive = thread1.isAlive();        boolean thread2Alive = thread2.isAlive();        if(!thread1Alive&amp;&amp;!thread2Alive){            System.out.println(\"thread1 和 thread2 运行完毕！\");            break;        }        if(thread1Alive) System.out.println(\"thread1 正在运行\");        if(thread2Alive) System.out.println(\"thread2 正在运行\");    }}\n4.线程池\n操作系统创建线程的开销是比较大的，我们不能在程序中无止境的创建线程，但是我们可以利用已经存在的线程进行多线程任务执行，\n这时，我们就可以使用线程池来达到目的了。\n我们可以使用线程池来高效执行任务\n前面的对单个任务创建一个线程显然对大量任务而言使不够高效的，原因是：为每个任务开始一个新线程可能会限制吞吐量并且造成性能降低。线程池是管理并发执行任务个数的理想方法。\nJava提供Executor接口,ExecutorService接口，Executors类来支持线程池。\n他们类图如下：\nclassDiagram\n\n    class Executor{\n        \n    }\n\n    class ExecutorService{\n        +shutdown() void\n        +shutdownNow() List(Runnable)\n        +isShutdown() boolean\n        +isTerminated() boolean\n    }\n    \n\n    Executor &lt;|.. executorservice&lt; pre&gt;\n4.1 Executor接口\n此接口仅定义了一个方法execute， 这个方法相当于Thread中的start, 它让线程执行传入其中的任务\n//线程池用此方法执行传入的任务void execute(Runnable command);\n4.2 ExecutorService接口\n这个就是接口是线程池接口，其中定义了线程池包含的方法\npublic interface ExecutorService extends Executor {        //关闭线程池，已经提交的任务继续执行，不接受新任务    void shutdown();        //尝试停止所有正在执行的任务，停止等待任务的处理，并返回等待执行的任务列表。    List&lt;Runnable&gt; shutdownNow();        //如果线程池已经关闭，则返回true    boolean isShutdown();        //如果执行shutdown后，线程池中所有任务结束，则返回true    boolean isTerminated();         //执行shutdown后，进入阻塞等待状态直到所有任务都完成/超时    boolean awaitTermination(long timeout, TimeUnit unit)        throws InterruptedException;        // 提交一个带有返回值的任务    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);    //提交一个任务并返回一个Future对象    //这个Future对象能在在任务完成后使用get得到result对象    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);    //提交一个任务并返回一个Future对象    //这个Future对象能在任务完成后使用get得到null    Future&lt;?&gt; submit(Runnable task);    // 执行提交的集合中所有的任务并返回一个Future列表    // 可以使用Future.isDone来判断任务是否执行完成，如果完成返回true    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        throws InterruptedException;    //执行提交的集合中所有的任务并返回一个Future列表(任务结束或超时后可获取状态)    //可以使用Future.isDone来判断任务是否执行完成，如果完成返回true    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                                  long timeout, TimeUnit unit)        throws InterruptedException;    //执行给顶的任务列表，返回已成功完成的任务结果    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        throws InterruptedException, ExecutionException;    //执行给顶的任务列表，返回已成功完成的任务结果，如果超时则抛出异常    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                    long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutException;}\n4.3 AbstractExecutorService类\n这个类提供了线程池接口的抽象实现，提供了一些可复用的代码。\n感兴趣的同学可以学习下, 本节的目的不是解读源码，所以省略。\n4.4 ThreadPoolExecutor\n它是ExecutorService的一个具体实现。\n它继承了AbstractExecutorService抽象类，它是线程池的一种具体实现。\n我们可以直接使用它来构造自己的线程池。\n但是由于这个类的使用比较复杂，所以我们可以先使用Jdk中对这个类的封装。\n4.5 Executors类\n这个类是线程池的一个工厂类，它提供了一些ThreadPoolExecutor的对象生成方法,\n例如：\n//创建一个指定线程数的线程池public static ExecutorService newFixedThreadPool(int nThreads) {    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;());}//创建一个不限数量的线程池，当需要线程时，线程池会新建一个public static ExecutorService newCachedThreadPool() {    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;());}\n就上面两种线程池而言，一般前者更安全，因为后者存在线程超量的问题。\n课外扩充：\n\n\nnewFixedThreadPool 。这个方法创建一个固定长度的线程池，每当提交一个任务时就创建一个线程，\n直到达到线程池的最大数量，这时线程池的规模不再变化，如果某个线程由于发生了未预期的Exception而结束，\n那么线程池会补充一个新的线程。\n\n\nnewCachedThreadPool。这个方法创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，\n那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，这个线程池的规模不存在任何限制。\n\n\nnewSingleThreadExecutor。 这个方法创建一个单线程的Executor，它创建单个工作线程来执行任务，\n如果这个线程异常结束，线程池会创建一个线程来代替。 这个线程池可以保证任务在队列中按顺序执行。\n\n\nnewScheduledThreadPool。这个方法创建一个固定长度的线程池，与第一种不同的是，它可以延迟或定时的去执行任务。\n\n\n4.6 使用线程池\n/** * 学会使用Executors类来快速创建线程池并使用 */public class ThreadPoolStudy {    public static void main(String[] args) {        //创建一个线程池，且里面最多容纳1个线程        ExecutorService executor= Executors.newFixedThreadPool(1);        //添加任务到线程池中,实际上，这里的两个任务的执行时串行的        //因为前面定义线程池中线程的数量为1，只有一个线程执行任务        executor.execute(new PrintChar('a',5));        executor.execute(new PrintChar('b',5));        //关闭执行器        executor.shutdown();    }    static class PrintChar implements Runnable{        private final char charToPrint;        private final int times;        public PrintChar(char c,int t) {            charToPrint=c;            times=t;        }        public void run() {            for(int i=0;i&lt;times;i++) {                System.out.print(charToPrint);                try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }}\n运行结果：\naaaaabbbbbProcess finished with exit code 0\n5. 线程同步关键字\n线程同步用于协调相互依赖的线程的安全执行，保存程序中数据不出问题。\n在计算机中存在这样一个问题：如果一个共享资源被多个线程同时访问，则这个共享资源可能存在会遭到破坏的风险。\n因此为了避免这种情况发生，我们应该防止多个线程同时进入程序的某一特定修改共享资源的部分，这一部分称为临界区（critical region）\n5.1 同步方法\n在Java中，我们可以用关键字synchronized来保证多线程安全执行，以便一次只有一个线程可以访问这个方法，被synchronized修饰的方法我们可以称之为同步方法。\n一个同步方法在执行之前需要加锁,锁是一种实现资源排他使用的机制。\n对于实例同步方法，要给调用该方法的对象加锁。\n对于静态同步方法，要给这个类加锁。\n5.1.1 实例演示\n// 完整代码地址在文章最后public static void main(String[] args) {        ExecutorService executorService = Executors.newFixedThreadPool(1000);        Account account = new Account();        UnSynAccount unSynAccount = new UnSynAccount();        SynBlockAccount blockAccount = new SynBlockAccount();        for(int i=0;i&lt;500;i++){        executorService.execute(account);        }        for(int i=0;i&lt;500;i++){        executorService.execute(blockAccount);        }        for(int i=0;i&lt;500;i++){        executorService.execute(unSynAccount);        }        executorService.shutdown();        while (true){        if(executorService.isTerminated()) {        System.out.println(\"Account: \"+account.toString());        System.out.println(\"BlockAccount: \"+blockAccount.toString());        System.out.println(\"unSynAccount: \"+unSynAccount.toString());        break;        }   } }\n运行结果：\nAccount: Account{money=2500 age=2500}BlockAccount: Account{money=2500 age=2500}unSynAccount: Account{money=2500 age=2500}Process finished with exit code 0\n5.2 同步语句\n如果同步方法中只有几行代码是临界区，那么仅仅为了这几行临界区而牺牲整个方法的性能，这显然不值得，所以Java中存在同步语句机制来解决这一问题。\n同步语句允许设置同步方法中的部分代码，而不必是整个方法，这大大增强了程序的并发能力。\n当执行方法中的某一代码块时，同步语句不仅可用于对this对象的加锁，还可用于对任何对象加锁，这个代码块称为同步块（synchronized block）\n其一般形式为：\nsynchronized(expr){  statements;}\n表达式expr求值结果必须是一个对象的引用，如果对象已经被另一个线程锁定，则在解锁之前该线程将被阻塞，当获准对一个对象加锁时，该线程执行同步块中的语句，然后解除锁。\n实例演示：\n/** * 线程安全的类 * 同步阻塞Account */public class SynBlockAccount implements Runnable {    private int money;    private static int age;    public void deposit(int i) throws InterruptedException {        Thread.sleep(100);        synchronized (this){            money += i;        }        Thread.sleep(100);    }    public void ageAdd(int i) throws InterruptedException {        Thread.sleep(100);        synchronized (this){            age += i;        }        Thread.sleep(100);    }    @Override    public void run() {        try {            Thread.sleep(100);            deposit(5);            ageAdd(5);        } catch (InterruptedException e) {            e.printStackTrace();        }    }    @Override    public String toString() {        return \"Account{\" +                \"money=\" + money +                \" age=\"+ age+                '}';    }}\n6.API加锁实现同步（Lock类）\n我们可以显式地采用锁对象和状态来同步线程。\nJava可以显式地加锁，这给协调线程带来了更多的控制功能，在Java中提供了Lock接口来定义相应的锁机制。\n我们可以使用Lock具体的实现来实现加锁操作。\nclassDiagram\n\n    class Lock{\n        +lock() void\n        +unlock() void\n        +newCondition() Condition\n    }\n\n    class ReentrantLock{\n        +ReentrantLock()\n        +ReentrantLock(fair:boolean)\n    }\n    \n\n    Lock &lt;|.. reentrantlock&lt; pre&gt;\nReentrantLock是Lock的一个具体实现。\n6.1 Lock接口\nLock接口中定义如下\n//得到一个锁void lock();//获得一个锁如果线程没被中断void lockInterruptibly() throws InterruptedException;//当锁没有被占用，才获取锁。boolean tryLock();//尝试获取锁直到获取或超时boolean tryLock(long time, TimeUnit unit) throws InterruptedException;//释放锁void unlock();//返回一个绑定了锁的ConditionCondition newCondition();\n6.2 ReentrantLock\nReentrantLock是对Lock的具体实现，我们可以使用它来实现对临界区的保护，使用方式如下：\nLock lock = new ReentrantLock();lock.lock();try{    //临界代码块}catch(Exception e){    }finally{    //确保锁能被正常释放    lock.unlock();}\n这个结构能确保任何时刻只有一个线程进入临界区。 一旦一个线程锁定了锁锁对象，其他任何线程都无法正常执行lock语句。 当其他线程调用lock时，他们会暂停，直到前面的线程释放了这个锁对象。\n6.2.1 演示实例\npublic class LockStudy {    private static Account account = new Account();    public static void main(String[] args) {        //创建线程池        ExecutorService executor= Executors.newCachedThreadPool();        //循环添加任务        for(int i=0;i&lt;1000;i++) {            executor.execute(new AddAPennyTask());        }        // 关闭线程池        executor.shutdown();        //所有任务都执行完        while(true) {            if(executor.isTerminated()){                System.out.println(\"任务执行完毕！！\");                break;            }        }        System.out.println(\"what is balance? \"+account.getBalance());    }    public static class AddAPennyTask implements Runnable{        public void run() {            account.deposit(1);        }    }    private static class Account{        //创建一个互斥锁        private static final Lock lock = new ReentrantLock();        private int balance = 0;        public int getBalance(){            return balance;        }        public void deposit(int amount) {            //获取一个锁            lock.lock();            try{                int newBalance=balance+amount;                Thread.sleep(5);                balance=newBalance;            } catch(InterruptedException ex) {                System.out.println(\"线程中断！！\");            } finally{                //释放锁                lock.unlock();            }        }    }}\n7.本章完整代码地址\nJava基础学习/src/main/java/Progress/exa28_1 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"10.2 Java进阶之线程间协作","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-10-2-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%8D%8F%E4%BD%9C%EF%BC%8C%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85Demo%EF%BC%8C%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/","content":"1.线程间协作\n上一篇文章中说到可以让多个线程在临界区上的相互排斥(加锁实现)来让线程间同步，从而让多线程程序能安全的运行。\n线程同步可以避免竞争条件的发生，但有时候，我们也需要线程之间的相互协作。\n如果我们需要让不同的线程也能进行通信，可以使用条件对象来实现线程间的通信。\n我们可以用条件对象让线程在执行到一半时进入等待阻塞状态，其他线程可以通过条件对象来等待阻塞的线程。\n1.1 条件对象是什么？\n当线程进入临界区后却发现只有满足某个条件之后才能往下执行，这时我们可以使用一个条件对象来管理那些已经获得了一个锁却不能做有用的工作的线程。\n简单来说，当一个线程获得了锁准备运行程序的时候，但是代码中有一个if语句，如果if语句不满足，\n原则上程序不应该往下执行，但是线程占着锁不放是不合理的，\n这时我们可以使用条件对象让这个线程进入阻塞状态并释放锁，让锁资源能及时的被其他线程使用，\n当if条件满足后，其他线程会使用条件对象通知这个阻塞的线程可以往下执行了，这时这个线程就能顺利的往下执行了。\n条件对象从Java编程的角度上看就是通过调用Lock对象的newCondition()方法而创建的条件对象,一个锁可以产生多个条件对象。\n然后我们可以使用这个条件对象的await(),signal(),signalAll()方法来实现线程之间的通信，让线程获得锁的利用率最大化。\n1.1.1 Condition是一个接口\n接口图如下:\nclassDiagram\n    class Condition{\n        +await() void \n        +signal() void\n        +signalAll() Condition\n    }\n可以看到这个接口主要有三个方法：await, signal, signalAll。\n\nawait通知线程释放锁并进入等待状态\nsignal通知线程获取锁并往下执行\nsignalAll通知所有等待的线程往下执行\n\n注意：使用锁的条件对象前必须要先获得条件对象的锁。\n1.1.2 用例子来理解Condition\n下面两个任务，一个是提款任务，一个是存款的。\n提款任务的顺利执行的前提是余额足够，所以当余额不足时，它会等待存款任务执行直到符合条件。\n\n1.2.使用条件对象实现生产者消费者多线程程序\n程序逻辑图如下：\n\n1.2.1 示例代码\n//完整代码链接在文章底部public static void main(String[] args) {    ExecutorService executor= Executors.newFixedThreadPool(10);//创建一个并行线程池    executor.execute(new ProducerTask());    executor.execute(new ConsumerTask());    executor.execute(new ConsumerTask());    executor.execute(new ConsumerTask());    executor.execute(new ConsumerTask());    executor.execute(new ConsumerTask());    executor.shutdown();}\n运行结果：\nProducer writes1\t\t\tConsumer reads1\t\t\t缓冲区空了，等待写入\t\t\t缓冲区空了，等待写入\t\t\t缓冲区空了，等待写入\t\t\t缓冲区空了，等待写入Producer writes2\t\t\tConsumer reads2\t\t\t缓冲区空了，等待写入Producer writes3\t\t\tConsumer reads3\t\t\t缓冲区空了，等待写入Producer writes4\t\t\tConsumer reads4\n2.阻塞队列\n阻塞队列这样类型的一种的队列： 当我们试图向一个满队列中添加元素或者从空队列中删除元素时，会导致线程阻塞的一种队列。\n我们可以使用阻塞队列来简化生产者消费者模式的编程，因为阻塞队列本身就是线程安全的并支持阻塞。\n2.1.BlockingQueue\nBlockingQueue是一个接口，它继承了Queue接口，是Queue的一种增强。\n它在Queue的基础上增加了线程安全的同步定义处理。\n其接口类图如下：\nclassDiagram\n\n    class Queue{\n        \n    }\n\n     class BlockingQueue {\n       +put(element: E) void\n       +take() E\n    }\n\n    Queue &lt;|.. blockingqueue&lt; pre&gt;\n可以看到，阻塞队列主要的是put，take方法。其中put方法是向队列中安全的添加元素，take从队列中安全的取出元素。\n简单来说，阻塞队列就是内部有条件锁的队列。使用它可以简化我们的多线程代码，阻塞队列本身就是线程安全的，\n我们无需为了保证队列安全性再去进行编程做同步处理。\n我们可以看一下BlockQueue接口的定义：\n//向队列添加元素，如果队列满了则抛出异常boolean add(E e);//向队列添加元素，如果队列满了返回falseboolean offer(E e);//向队列添加元素，如果队列满了，进入等待阻塞状态，//直到队列有空余位置或者线程被中断void put(E e) throws InterruptedException;//向队列添加元素，如果队列满了，进入等待阻塞状态，//直到队列有空余位置或者超时或者线程被中断boolean offer(E e, long timeout, TimeUnit unit)    throws InterruptedException;    //从队列中获取元素，如果队列为空，则进入等待阻塞状态//直到队列有元素或线程被中断E take() throws InterruptedException;////从队列中获取元素，如果队列为空，则进入等待阻塞状态//直到队列有元素或线程被中断或超时E poll(long timeout, TimeUnit unit)    throws InterruptedException;    //预估队列剩余容量int remainingCapacity();//从队列中移除指定元素boolean remove(Object o);//判断指定的元素是否存在于队列中public boolean contains(Object o);//清空队列并向队列添加c中包含的元素int drainTo(Collection&lt;? super E&gt; c);//清空队列并向队列添加c中包含的元素，但限制最大数量int drainTo(Collection&lt;? super E&gt; c, int maxElements);\n2.2 .阻塞队列的具体实现\n看图：\nclassDiagram\n\n     class BlockingQueue {\n \n     }\n    \n    class ArrayBlockingQueue {\n    \n    \n    }\n    class LinkedBlockingQueue {\n    \n    }\n     class PriorityBlockingQueue {\n    \n    }\n    \n\n    BlockingQueue &lt;|.. arrayblockingqueue blockingqueue &lt;|.. linkedblockingqueue priorityblockingqueue&lt; pre&gt;\n我们可以看到在Java中，阻塞队列的实现有三种：\nArrayBlockingQueue  数组阻塞队列\nLinkedBlockingQueue 链表阻塞队列\nPriorityBlockingQueue 优先阻塞队列\n2.2.1 ArrayBlockingQueue 数组阻塞队列\n这个队列是基于数组实现的阻塞队列。\n阻塞队列中，主要用到的存取方法有：\n//存void put(E e) throws InterruptedException;boolean offer(E e, long timeout, TimeUnit unit)    throws InterruptedException;//取E take() throws InterruptedException;E poll(long timeout, TimeUnit unit)    throws InterruptedException;\n通过查阅源码可以知道，其中线程安全是依赖于ReentrantLock以及条件对象实现的。\nfinal ReentrantLock lock;\n下面我们基于阻塞队列实现生产者消费者，有兴趣的同学可以对比一下上一节的基于锁的实现：\n//完整代码链接在文章底部public class BlockingQueueStudy {   //使用阻塞队列来实现线程安全private static final ArrayBlockingQueue&lt;Integer&gt; buffer = new ArrayBlockingQueue&lt;&gt;(10);public static void main(String[] args) {    //创建一个并行线程池    ExecutorService executor= Executors.newFixedThreadPool(10);    executor.execute(new ProducerTask());    executor.execute(new ConsumerTask());    executor.execute(new ConsumerTask());    executor.execute(new ConsumerTask());    executor.shutdown();}}\n2.2.2 LinkedBlockingQueue\n链表阻塞队列，链表结构实现，通过引用将链表的元素串起来。\n//完整代码链接在文章底部private static final BlockingQueue&lt;Integer&gt; buffer = new LinkedBlockingQueue&lt;&gt;(10);public static void main(String[] args) {    //创建一个并行线程池    ExecutorService executor= Executors.newFixedThreadPool(10);    executor.execute(new ProducerTask());    executor.execute(new ConsumerTask());    executor.execute(new ConsumerTask());    executor.execute(new ConsumerTask());    executor.shutdown();}\n2.2.3 PriorityBlockingQueue\n优先级阻塞队列，通过数组实现，存储原理和优先队列一样。\nprivate static final BlockingQueue&lt;Integer&gt; buffer = new PriorityBlockingQueue&lt;&gt;(10);public static void main(String[] args) throws InterruptedException {    ExecutorService executorService = Executors.newFixedThreadPool(10);    executorService.execute(new ProducerTask());    Thread.sleep(5000);    executorService.execute(new ConsumerTask());    executorService.shutdown();}\n3 .代码仓库地址\nJava基础学习/src/main/java/Progress/exa28_2 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"10.3 Java进阶之线程信号量","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-10-3-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%BA%BF%E7%A8%8B%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%8C%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81/","content":"1.信号量\n1.1 什么是信号量？\n信号量指的是对共享资源进行访问控制的对象。\n在访问资源之前，线程必须从信号量获取许可证，访问完之后，将许可证归还给信号量。\n流程图如下：\ngraph TD\n\nseaphore.acquire--&gt;visit_resource--&gt;semaphore.release;\n这样有助于资源的正确的有效利用，也能保证资源数据的安全性。\n1.2 创建信号量\n创建信号量必须确定许可数量，可以选择是否使用公平策略。\nJava中信号量是用Semaphore类声明的对象。\n类图如下：\n`classDiagram\nclass Semaphore{\n+Semaphore(numberOfPermits: int)\n+Semaphore(numberOfPermits:int, fair: boolean)\n+acquires() void\n+release() void\n}\n`\n1.2.1 使用实例\n此示例通过操作账户对象的余额来展示信号量如果处理并发问题。\npublic class SemaphoreStudy {    public static void main(String[] args) {        // 创建一个账户实例        Account account = new Account();        // 新建一个容纳10个        ExecutorService executorService = Executors.newFixedThreadPool(10);        for(int j=0;j&lt;200;j++){            executorService.execute(()-&gt;{                for(int i = 0;i&lt;100;i++)                    account.deposit(100);            });        }        executorService.execute(()-&gt;{            while (true)                account.getBalance();        });    }    private static class Account {        //创建写信号量        private static Semaphore writeSemaphore = new Semaphore(1);        //创建读信号量        private static Semaphore readSemaphore = new Semaphore(5);        private int balance = 0;//余额        public int getBalance() {            int res = 0;            try {                readSemaphore.acquire();                res = balance;                System.out.println(\"获取余额：\"+res);                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }finally {                readSemaphore.release();            }            return res;        }        public void deposit(int amount) {            try{                writeSemaphore.acquire();//获得许可                int newBalance = balance+amount;//访问余额                balance = newBalance;//更新余额                //Thread.sleep(1000);            }catch(InterruptedException ex) {            } finally {                writeSemaphore.release();//归还信号量            }        }    }}\n2.避免死锁\n2.1 发生死锁\n死锁发生的条件是某个线程一直不释放自己的锁而导致其他很多线程一直在等待阻塞状态。\n简单来说，就是锁资源无法被其他线程获取，就是这个锁死了，俗称死锁。\n2.1.1 死锁程序再现\n//完整代码地址在文章底部public void write(int value) {    lock.lock();//上锁    try{        while(queue.size()==CAPACITY){            System.out.println(\"缓冲区满了，等待读取\");            //释放锁，线程进入等待状态            notFull.await();        }        queue.offer(value);//添加value到queue        notEmpty.signal();//唤醒read                //在这里添加循环，让线程一直不释放锁        while (true){        }            }catch(InterruptedException ex) {        ex.printStackTrace();    } finally{        lock.unlock();//解锁    }}\n可以发现，读取数据线程因为没获取到锁，所以没办法进行数据读取。\n死锁产生的经典场景是相互等待：\nclass Thread1 {        public void run(){        synchronized (object1) {            // do something here            synchronized (object2) {                // do something            }        }                    }}class Thread2 {    public void run(){        synchronized (object2) {            // do something here            synchronized (object1) {                // do something            }        }            }}\n如果出现上面的情况，就可能出现线程1在等线程2释放锁，而线程2又在等线程1释放锁，但是线程1和线程2谁也不释放锁，故而出现死锁。\n2.2 如何避免死锁\n我们可以采用正确的资源排序来避免死锁，或者引入合理的中断机制，让一些线程在无法长时间停留在获取锁或释放锁的阻塞状态。\n3.同步集合\n3.1 什么是同步集合？\n同步集合就是线程安全的集合，我们可以将同步集合使用在多线程编程上，无需对其进行同步编程(无需考虑锁的问题)\n前面学习Java合集框架的类并不一定是线程安全的，就是说如果它们同时被多个线程访问和更新可能会破坏其数据。\n那么怎么保证集合中数据的安全性呢？\n这时候我们可以通过Collections来保护合集中的数据。\n所以Collections提供6个静态方法来将合集建成同步版本，使用这些方法创建的合集称为同步集合类\n我们来看下类图：（将集合转换成同步版本的方法）\nclassDiagram \n    class Collections{\n      +synchronizedCollection(c:Collection) Collection\n      +synchronizedList(list:List) List\n      +synchronizedMap(m:Map) Map\n      +synchronizedSet(s:Set) Set\n      +synchronizedSortedMap(s:SortedMap) SortedMap\n      +synchronizedSortedSet(s:SortedSet) SortedSet\n    }\n3.2 Collections类\n//Collection参数封装为一个安全的集合并返回,这是一个比较通用的方法public static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c) {    return new SynchronizedCollection&lt;&gt;(c);}//将List对象封装为线程安全的List并返回public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) {    return (list instanceof RandomAccess ?            new SynchronizedRandomAccessList&lt;&gt;(list) :            new SynchronizedList&lt;&gt;(list));}//将Map对象封装为线程安全的Map并返回public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) {    return new SynchronizedMap&lt;&gt;(m);}//将传入的Set对象封装为线程安全的Set并返回public static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s) {    return new SynchronizedSet&lt;&gt;(s);}//将传入的SortedMap封装为线程安全的并返回public static &lt;K,V&gt; SortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt; m) {    return new SynchronizedSortedMap&lt;&gt;(m);}//将传入的SortSet对象封装为线程安全的SortedSet并返回public static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s) {    return new SynchronizedSortedSet&lt;&gt;(s);}\n想要了解更多大家可以看看源码，看看它是怎么把普通集合变为同步集合的。\n其实就是让对于的Synchronized…实现和实现类相同的接口，然后进行重写，在重写的方法中调用传入对象的方法的时候加入同步操作。\n例如：\npublic E set(int index, E element) {    synchronized (mutex) {return list.set(index, element);}}\n学到这里，应该算是入门多线程了，如果想要深入学习多线程，还需要另外花时间去研究和学习。\n4 代码地址\nJava基础学习/src/main/java/Progress/exa28_3 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"11.1 网络IP,DNS,TCP,UDP，客户端服务器通信套接字","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-11-1-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%BD%91%E7%BB%9CIP-DNS-TCP-UDP-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%EF%BC%8C%E5%A5%97%E6%8E%A5%E5%AD%97/","content":"1.网络术语解释\n1.1 什么是IP？\nIP是一种互联网协议地址，用它我们可以唯一的标识互联网上的计算机。它由四段用点隔开的0~225的十进制数组成，例如：130.254.204.31\n1.2 什么叫DNS？\n由于前面的ip地址由于数字很抽象难记，所以我们经常将它们映射为被称为域名的好记的名字。例如：www.baidu.com。在互联网上有特殊的称为域名服务器（DNS）的服务器，它把主机的名字转换成ip地址，然后用这个ip发送请求。\n1.3 TCP和UDP\n两个ip之间相互通信可以通过传输控制协议（TCP）和用户数据报协议(UDP)实现。\nTCP能够让两台主机建立连接并交换数据流，确保数据的传输，也确保数据包以它们发送的顺序传输。\nUDP允许一台计算机上的应用程序向另一台计算机上的应用程序发送数据报，UDP不确保数据完整到达。\n2.客户端/服务器通信\nJava支持基于流的通信和基于包的通信。其中基于流的通信使用TCP进行数据传输，因为TCP协议能够发现丢失的数据信息并重新发送。基于包的使用UDP，此协议不能保证传输没有丢失。所以大多数的java程序使用的是TCP协议(就是基于流的通信方式),保证数据完整传输。\n2.1 Java如何进行网络通信？\nJavaAPI提供用于创建套接字的类来便于程序通过Internet通信。\n一旦Java程序通过Socket建立连接，客户端和服务器就可以通过Socket进行通信。\n当客户端尝试连接到服务器时，服务器必须正在运行且为监听状态。\njava通信过程如下图\n\n首先启动服务器程序，服务器程序对指定端口进行监听。\n然后客户端通过ip:port尝试连接服务端，连接成功后就能进行通信了。\n2.2 下面我们学习Socket类\n2.2.1 ServerSocket\n要创建服务器，我们可以用ServerSocket类来创建一个套接字对象，并把它附在一个端口上，服务器从这个端口监听连接。\n端口号的范围为：0~65536 但其中的0 ~1024是为特定服务保留的端口号，建议不用。\n创建语句如下：\n//port为设置的服务器端口号ServerSocket serverSocket=new ServerSocket(port);\n创建之后我们可以使用下面语句进行监听：\nSocket socket=ServerSocket.accept();\n这个语句会一直等待，直到有客户端请求连接到此服务器。\n2.2 2 Socket\n客户端用以下语句来请求与服务器连接：\n//serverName是服务器的互联网主机名或IP，port为服务器建立服务对应的端口号Socket socket=new Socket(serverName,port);\n2.2.3 利用I/O流进行数据传输\n服务器和客户端连接后，我们可以从Socket中获取I/O流，然后通过I/O流机制就能实现网络数据传输了。\n如图：\n\n显然我们可以看到，关键是：\nsocket.getInputStream();//获得套接字输入流socket.getOutputStream();//获得套接字输出流\n2.示例演示（提供两个版本：UI版和无UI版）\n3.1 UI版\n下面开发出一个在线计算圆面积的例子：\n\n3.1.1 Server.java\npublic class Server extends Application &#123;    public void start(Stage primaryStage)&#123;        TextArea ta=new TextArea();        Scene scene=new Scene(new ScrollPane(ta),450,200);        primaryStage.setTitle(&quot;Server&quot;);        primaryStage.setScene(scene);        primaryStage.show();        /*          建立一个线程来进行端口监听         */        new Thread(()-&gt;&#123;            try&#123;                //创建服务器套接字，服务器端口号设为8000                ServerSocket serverSocket=new ServerSocket(8000);                Platform.runLater(()-&gt;ta.appendText(&quot;服务器启动成功 日期：&quot;+new Date()+&#x27;\\n&#x27;));                //服务器进入监听状态                System.out.println(&quot;服务器进入监听状态&quot;);                Socket socket = serverSocket.accept();                System.out.println(&quot;监听到连接，即将进入下一步&quot;);                //创建服务器接受和发送数据的流                DataInputStream inputFromClient = new DataInputStream(socket.getInputStream());                DataOutputStream outputToClient=new DataOutputStream(socket.getOutputStream());                while(true)&#123;                    double radius=inputFromClient.readDouble();//接受到的数据赋给radius                    double area=radius*radius*Math.PI;//计算面积                    outputToClient.writeDouble(area);//将计算值发送出去                    Platform.runLater(()-&gt;&#123;                        ta.appendText(&quot;接收到客户端传来的半径：:&quot;+radius+&#x27;\\n&#x27;);                        ta.appendText(&quot;面积是:&quot;+area+&#x27;\\n&#x27;);                    &#125;);                &#125;            &#125;catch(IOException ex)&#123;                ex.printStackTrace();            &#125;        &#125;).start();    &#125;&#125;\n3.1.2 Client.java\npublic class Client extends Application &#123;    DataOutputStream toServer=null;//声明输出流    DataInputStream fromServer=null;//声明输入流    public void start(Stage primaryStage) &#123;        BorderPane paneForTextField=new BorderPane();        paneForTextField.setPadding(new Insets(5,5,5,5));        paneForTextField.setStyle(&quot;-fx-border-color:green&quot;);        paneForTextField.setLeft(new Label(&quot;请输入半径：&quot;));        TextField tf = new TextField();        tf.setAlignment(Pos.BOTTOM_RIGHT);        paneForTextField.setCenter(tf);        BorderPane mainPane = new BorderPane();        TextArea ta = new TextArea();        mainPane.setCenter(new ScrollPane(ta));        mainPane.setTop(paneForTextField);        Scene scene=new Scene(mainPane,450,200);        primaryStage.setTitle(&quot;Client&quot;);        primaryStage.setScene(scene);        primaryStage.show();        tf.setOnAction(e-&gt;&#123;            try&#123;                double radius = Double.parseDouble(tf.getText().trim());                //将radius写入输出流发送出去                toServer.writeDouble(radius);                toServer.flush();//清空输出流                //从输入流中获取的值赋给area(此方法会阻塞)                double area = fromServer.readDouble();                ta.appendText(&quot;半径：&quot;+radius+&#x27;\\n&#x27;);                ta.appendText(&quot;面积是： &quot;+area+&#x27;\\n&#x27;);            &#125;catch (IOException ex) &#123;                System.err.println(ex);            &#125;        &#125;);        try&#123;            //创建套接字            Socket socket = new Socket(&quot;localhost&quot;,8000);            //创建客户端接受和发送数据的流            fromServer = new DataInputStream(socket.getInputStream());            toServer = new DataOutputStream(socket.getOutputStream());        &#125;catch(IOException ex) &#123;            ta.appendText(ex.toString()+&#x27;\\n&#x27;);        &#125;    &#125;&#125;\n3.2 无UI版\n\n3.2.1 Server.java\npublic class Server &#123;    public static void main(String[] args) &#123;             /*          建立一个线程来进行端口监听         */        new Thread(()-&gt;&#123;            try&#123;                //创建服务器套接字，服务器端口号设为8000                ServerSocket serverSocket=new ServerSocket(8000);                System.out.println(&quot;服务器启动成功 日期：&quot;+new Date()+&#x27;\\n&#x27;);                //服务器进入监听状态                System.out.println(&quot;服务器进入监听状态&quot;);                Socket socket = serverSocket.accept();                System.out.println(&quot;监听到连接，即将进入下一步&quot;);                //创建服务器接受和发送数据的流                DataInputStream inputFromClient = new DataInputStream(socket.getInputStream());                DataOutputStream outputToClient=new DataOutputStream(socket.getOutputStream());                while(true)&#123;                    //接受到的数据赋给radius                    double radius=inputFromClient.readDouble();                    double area=radius*radius*Math.PI;//计算面积                    outputToClient.writeDouble(area);//将计算值发送出去                    System.out.println(&quot;接收到客户端传来的半径：:&quot;+radius+&#x27;\\n&#x27;);                    System.out.println(&quot;面积是:&quot;+area+&#x27;\\n&#x27;);                &#125;            &#125;catch(IOException ex)&#123;                ex.printStackTrace();            &#125;        &#125;).start();    &#125;&#125;\n3.2.2 Client.java\npublic class Client &#123;    public static void main(String[] args) &#123;        DataOutputStream toServer=null;//声明输出流        DataInputStream fromServer=null;//声明输入流        try&#123;            //创建套接字            Socket socket = new Socket(&quot;localhost&quot;,8000);            //创建客户端接受和发送数据的流            fromServer = new DataInputStream(socket.getInputStream());            toServer = new DataOutputStream(socket.getOutputStream());            while (true)&#123;                System.out.println(&quot;请输入半径：&quot;);                Scanner sc = new Scanner(System.in);                double radius = sc.nextDouble();                //将radius写入输出流发送出去                toServer.writeDouble(radius);                toServer.flush();//清空输出流                //从输入流中获取的值赋给area(此方法会阻塞)                double area = fromServer.readDouble();                System.out.println(&quot;半径：&quot;+radius+&#x27;\\n&#x27;);                System.out.println(&quot;面积是： &quot;+area+&#x27;\\n&#x27;);            &#125;        &#125;catch(IOException ex) &#123;            ex.printStackTrace();        &#125;    &#125;&#125;\n4 代码地址\nJava基础学习/src/main/java/Progress/exa29_1 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"11.2 InetAddress类,多线程网络编程","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-11-2-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E7%BD%91%E7%BB%9CInetAddress%E7%B1%BB%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","content":"1.InetAddress类\n1.1 InetAddress类的作用\n服务器程序可以使用InetAddress类来获得对方端的IP地址和主机名字等信息。\n在服务器程序中使用下面的语句可以得到与客户端相连的套接字上的一个InetAddress实例并使用相应的方法显示客户端的主机名和IP地址：\npublic static void main(String[] args) &#123;    try&#123;        //创建套接字        Socket socket = new Socket(&quot;www.baidu.com&quot;,80);        InetAddress inetAddress = socket.getInetAddress();        System.out.println(&quot;Server&#x27;s host name is: &quot;+inetAddress.getHostName());        System.out.println(&quot;Server&#x27;s IP Address name is: &quot;+inetAddress.getHostAddress());    &#125;catch(IOException ex) &#123;        ex.printStackTrace();    &#125;&#125;\n\n除此之外，还可以使用静态方法getByName通过主机名或IP地址创建一个InetAddress的实例。\n例如下面语句为主机liang.armstrong.edu创建一个InetAddress实例：\nInetAddress address = InetAddress.getByName(&quot;www.baidu.com&quot;);\npublic static void main(String[] args) &#123;    try&#123;        //创建套接字        Socket socket = new Socket(&quot;www.baidu.com&quot;,80);        InetAddress inetAddress = socket.getInetAddress();        System.out.println(&quot;Server&#x27;s host name is: &quot;+inetAddress.getHostName());        System.out.println(&quot;Server&#x27;s IP Address name is: &quot;+inetAddress.getHostAddress());        InetAddress address = InetAddress.getByName(&quot;www.baidu.com&quot;);        System.out.println(&quot;Server&#x27;s host name is: &quot;+address.getHostName());        System.out.println(&quot;Server&#x27;s IP Address name is: &quot;+address.getHostAddress());    &#125;catch(IOException ex) &#123;        ex.printStackTrace();    &#125;&#125;\n\n2.服务多个用户\n我们可以使用线程处理服务器上多个客户端的同时访问。\n可以简单地为每个连接创建一个线程，下面给出服务器如何处理连接：\nwhile(true)&#123; Socket socket = serverSocket.accept(); Thread thread = new ThreadClass(socket);//为连接创建线程 thread.start();//线程开始&#125;\nwhile循环的每次迭代监听成功后创建一个新连接和新线程。\n2.2 多线程服务器例子学习\n2.2.1 带UI版\nServer.java\npackage Progress.exa29_2.part2.ui;import java.io.*;import java.net.*;import java.util.Date;import javafx.application.Application;import javafx.application.Platform;import javafx.scene.Scene;import javafx.scene.control.ScrollPane;import javafx.scene.control.TextArea;import javafx.stage.Stage;public class Server extends Application &#123;    private TextArea textArea = new TextArea();    private int clientNo = 0;    public void start(Stage primaryStage) &#123;        Scene scene=new Scene(new ScrollPane(textArea),450,200);        primaryStage.setTitle(&quot;Server&quot;);        primaryStage.setScene(scene);        primaryStage.show();        /*        建立一个线程创建服务器实例并启动监听         */        new Thread(()-&gt;&#123;            try&#123;                //创建服务器套接字，服务器端口号设为8000                ServerSocket serverSocket = new ServerSocket(8000);                Platform.runLater(()-&gt;textArea.appendText(&quot;Server started at&quot;+new Date()+&#x27;\\n&#x27;));                //进入无线循环                while(true)&#123;                    //服务器进入监听状态                    Socket socket = serverSocket.accept();                    //有客户端连接服务端，客户数加一                    clientNo++;                    Platform.runLater(()-&gt;&#123;                        textArea.appendText(&quot;客户端连接数: &quot;+clientNo+&quot;  &quot;+new Date()+&#x27;\\n&#x27;);                        InetAddress inetAddress = socket.getInetAddress();                        textArea.appendText(&quot;客户端 &quot;+clientNo+&quot; 号 的主机名为： &quot;+inetAddress.getHostName()+&#x27;\\n&#x27;);                        textArea.appendText(&quot;客户端 &quot;+clientNo+&quot;号的IP地址为： &quot;+inetAddress.getHostAddress()+&#x27;\\n&#x27;);                    &#125;);                    //为客户端创建新线程进行持续交互                    new Thread(new HandleAClient(socket)).start();                &#125;            &#125;catch(IOException ex)&#123;                ex.printStackTrace();            &#125;        &#125;).start();    &#125;    /**     * 持续交互任务定义     */    class HandleAClient implements Runnable&#123;        //此任务的客户端套接字        private Socket socket;        public HandleAClient(Socket socket) &#123;            this.socket=socket;        &#125;        public void run() &#123;            try&#123;                //创建服务器接受和发送数据的流                DataInputStream inputFromClient=new DataInputStream(socket.getInputStream());                DataOutputStream outputToClient = new DataOutputStream(socket.getOutputStream());                //持续监听客户端发送的数据                while(true) &#123;                    double radius = inputFromClient.readDouble();                    double area=radius*radius*Math.PI;                    outputToClient.writeDouble(area);                    Platform.runLater(()-&gt;&#123;                        textArea.appendText(&quot;得到客户端的半径数据： &quot;+radius+&#x27;\\n&#x27;);                        textArea.appendText(&quot;计算出来的面积为: &quot;+area+&#x27;\\n&#x27;);                    &#125;);                &#125;            &#125;catch (IOException ex) &#123;                ex.printStackTrace();            &#125;        &#125;    &#125;&#125;\nClient.java\npackage Progress.exa29_2.part2.ui;import javafx.application.Application;import javafx.geometry.Insets;import javafx.geometry.Pos;import javafx.scene.Scene;import javafx.scene.control.Label;import javafx.scene.control.ScrollPane;import javafx.scene.control.TextArea;import javafx.scene.control.TextField;import javafx.scene.layout.BorderPane;import javafx.stage.Stage;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.net.Socket;public class Client extends Application &#123;    DataOutputStream toServer=null;//声明输出流    DataInputStream fromServer=null;//声明输入流    public void start(Stage primaryStage) &#123;        BorderPane paneForTextField=new BorderPane();        paneForTextField.setPadding(new Insets(5,5,5,5));        paneForTextField.setStyle(&quot;-fx-border-color:green&quot;);        paneForTextField.setLeft(new Label(&quot;输入一个半径： &quot;));        TextField tf=new TextField();        tf.setAlignment(Pos.BOTTOM_RIGHT);        paneForTextField.setCenter(tf);        BorderPane mainPane = new BorderPane();        TextArea ta = new TextArea();        mainPane.setCenter(new ScrollPane(ta));        mainPane.setTop(paneForTextField);        Scene scene=new Scene(mainPane,450,200);        primaryStage.setTitle(&quot;Client&quot;);        primaryStage.setScene(scene);        primaryStage.show();        tf.setOnAction(e-&gt;&#123;            try&#123;                double radius = Double.parseDouble(tf.getText().trim());                toServer.writeDouble(radius);//将radius写入输出流                toServer.flush();//清空输出流                //从输入流中获取的值赋给area，此方法会阻塞，知道服务器传数据过来                double area = fromServer.readDouble();                ta.appendText(&quot;半径是： &quot;+radius+&#x27;\\n&#x27;);                ta.appendText(&quot;服务器返回的面积为： &quot;+area+&#x27;\\n&#x27;);            &#125;catch (IOException ex) &#123;                System.err.println(ex);            &#125;        &#125;);        try&#123;            //创建套接字            Socket socket = new Socket(&quot;localhost&quot;,8000);            //创建客户端接受和发送数据的流            fromServer=new DataInputStream(socket.getInputStream());            toServer = new DataOutputStream(socket.getOutputStream());        &#125;catch(IOException ex) &#123;            ta.appendText(ex.toString()+&#x27;\\n&#x27;);        &#125;    &#125;&#125;\n\n2.2.2 无UI版\nServer.java\npackage Progress.exa29_2.part2.noUi;import javafx.application.Platform;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.net.InetAddress;import java.net.ServerSocket;import java.net.Socket;import java.util.Date;public class NoUIServer &#123;    private static int clientNo = 0;    public static void main(String[] args) &#123;                /*        建立一个线程创建服务器实例并启动监听         */        new Thread(()-&gt;&#123;            try&#123;                //创建服务器套接字，服务器端口号设为8000                ServerSocket serverSocket = new ServerSocket(8000);                System.out.println((&quot;Server started at&quot;+new Date()+&#x27;\\n&#x27;));                //进入无线循环                while(true)&#123;                    //服务器进入监听状态                    Socket socket = serverSocket.accept();                    //有客户端连接服务端，客户数加一                    clientNo++;                    System.out.println(&quot;客户端连接数: &quot;+clientNo+&quot;  &quot;+new Date()+&#x27;\\n&#x27;);                    InetAddress inetAddress = socket.getInetAddress();                    System.out.println(&quot;客户端 &quot;+clientNo+&quot; 号 的主机名为： &quot;+inetAddress.getHostName()+&#x27;\\n&#x27;);                    System.out.println(&quot;客户端 &quot;+clientNo+&quot;号的IP地址为： &quot;+inetAddress.getHostAddress()+&#x27;\\n&#x27;);                    //为客户端创建新线程进行持续交互                    new Thread(new HandleAClient(socket)).start();                &#125;            &#125;catch(IOException ex)&#123;                ex.printStackTrace();            &#125;        &#125;).start();    &#125;&#125;/** * 持续交互任务定义 */class HandleAClient implements Runnable&#123;    //此任务的客户端套接字    private Socket socket;    public HandleAClient(Socket socket) &#123;        this.socket=socket;    &#125;    public void run() &#123;        try&#123;            //创建服务器接受和发送数据的流            DataInputStream inputFromClient=new DataInputStream(socket.getInputStream());            DataOutputStream outputToClient = new DataOutputStream(socket.getOutputStream());            //持续监听客户端发送的数据            while(true) &#123;                double radius = inputFromClient.readDouble();                double area=radius*radius*Math.PI;                outputToClient.writeDouble(area);                System.out.println(&quot;得到客户端的半径数据： &quot;+radius+&#x27;\\n&#x27;);                System.out.println(&quot;计算出来的面积为: &quot;+area+&#x27;\\n&#x27;);            &#125;        &#125;catch (IOException ex) &#123;            ex.printStackTrace();        &#125;    &#125;&#125;\nClient.java\npackage Progress.exa29_2.part2.noUi;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.net.Socket;import java.util.Scanner;public class NoUIClient &#123;    public static void main(String[] args) &#123;        DataOutputStream toServer=null;//声明输出流        DataInputStream fromServer=null;//声明输入流        try&#123;            //创建套接字            Socket socket = new Socket(&quot;localhost&quot;,8000);            //创建客户端接受和发送数据的流            fromServer=new DataInputStream(socket.getInputStream());            toServer = new DataOutputStream(socket.getOutputStream());            while (true)&#123;                System.out.println(&quot;请输入半径：&quot;);                Scanner sc = new Scanner(System.in);                double radius = sc.nextDouble();                //将radius写入输出流发送出去                toServer.writeDouble(radius);                toServer.flush();//清空输出流                //从输入流中获取的值赋给area(此方法会阻塞)                double area = fromServer.readDouble();                System.out.println(&quot;半径：&quot;+radius+&#x27;\\n&#x27;);                System.out.println(&quot;面积是： &quot;+area+&#x27;\\n&#x27;);            &#125;        &#125;catch(IOException ex) &#123;            System.out.println(ex.toString()+&#x27;\\n&#x27;);        &#125;    &#125;&#125;\n\n3.代码地址\nJava基础学习/src/main/java/Progress/exa29_2 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"11.3 通过网络传输对象","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-11-3-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1/","content":"1.Java如何通过网络发送和接受对象\n前面的网络学习的例子演示的只是基本数据类型的传输，但在实际的开发中，我们往往需要传输域对象（JavaBean）来进行通信。\n我们可以回顾到在我们学习IO流的时候，有这样一句话：\n在JavaAPI中，我们可以从字节序列来源地读入一个字节序列的对象称为输入流。字节序列的来源地可以是文件，也可以是网络，还可以是内存块等等。\n所以，我们可以在套接字流上使用ObjectOutputStream和ObjectinputStream来发送和接受对象数据。\n注意：传输的对象必须是可序列化的，也就是传输的对象的类定义中需要实现Serializable接口\n1.1 Demo展示\n\n代码地址：\nJava基础学习/src/main/java/Progress/exa29_3 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n1.1.1 JavaBean定义\nimport java.io.Serializable;public class StudentAddress implements Serializable &#123;    private String name;    private String street;    private String city;    private String state;    private String zip;    public StudentAddress(String name ,String street,String city,String state,String zip) &#123;        this.name=name;        this.street=street;        this.city=city;        this.state=state;        this.zip=zip;    &#125;    public String getName() &#123;        return name;    &#125;    public String getStreet() &#123;        return street;    &#125;    public String getCity() &#123;        return city;    &#125;    public String getState() &#123;        return state;    &#125;    public String getZip() &#123;        return zip;    &#125;    @Override    public String toString() &#123;        return &quot;StudentAddress&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, street=&#x27;&quot; + street + &#x27;\\&#x27;&#x27; +                &quot;, city=&#x27;&quot; + city + &#x27;\\&#x27;&#x27; +                &quot;, state=&#x27;&quot; + state + &#x27;\\&#x27;&#x27; +                &quot;, zip=&#x27;&quot; + zip + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n1.1.2 服务器代码\nimport java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.net.ServerSocket;import java.net.Socket;public class StudentServer &#123;    private ObjectOutputStream outputFile;//声明输出流    private ObjectInputStream inputFromClient;//声明输入流    public static void main(String[] args) &#123;        new StudentServer();    &#125;    public StudentServer()&#123;        try &#123;            ServerSocket serverSocket = new ServerSocket(8001);//设置服务器端口为8001            System.out.println(&quot;服务器已启动&quot;);            //输出对象流到文件student.dat（在根目录）中            outputFile = new ObjectOutputStream(new FileOutputStream(&quot;student.dat&quot;,true));            while(true) &#123;                //进入监听状态                Socket socket=serverSocket.accept();                //实例化套接字对象输入流                inputFromClient=new ObjectInputStream(socket.getInputStream());                //定义object存放输入流对象信息                Object object = inputFromClient.readObject();                //将信息写入文件student.dat                outputFile.writeObject(object);                System.out.println(&quot;接收到一个Student数据: &quot;+object.toString());            &#125;        &#125;catch (ClassNotFoundException ex)&#123;            ex.printStackTrace();        &#125;catch (IOException ex) &#123;            ex.printStackTrace();        &#125; finally&#123;            try&#123;                inputFromClient.close();                outputFile.close();            &#125;catch(Exception ex) &#123;                ex.printStackTrace();            &#125;        &#125;    &#125;&#125;\n1.1.3 客户端代码\nimport Progress.exa29_3.StudentAddress;import javafx.application.Application;import javafx.event.ActionEvent;import javafx.event.EventHandler;import javafx.geometry.HPos;import javafx.geometry.Pos;import javafx.scene.Scene;import javafx.scene.control.*;import javafx.scene.layout.GridPane;import javafx.scene.layout.HBox;import javafx.stage.Stage;import java.io.IOException;import java.io.ObjectOutputStream;import java.net.Socket;public class StudentClient extends Application &#123;    private TextField tfName=new TextField();    private TextField tfStreet=new TextField();    private TextField  tfCity=new TextField();    private TextField tfState=new TextField();    private TextField tfZip=new TextField();    private Button btRegister=new Button(&quot;发送数据到服务器&quot;);    String host=&quot;localhost&quot;;//定义ip地址    public void start(Stage primaryStage) &#123;        GridPane pane=new GridPane();        pane.add(new Label(&quot;姓名&quot;),0,0);        pane.add(tfName,1,0);        pane.add(new Label(&quot;街道&quot;),0,1);        pane.add(tfStreet,1,1);        pane.add(new Label(&quot;城市&quot;),0,2);        HBox hBox=new HBox(2);        pane.add(hBox,1,2);        hBox.getChildren().addAll(tfCity,new Label(&quot;州&quot;),tfState,new Label(&quot;编码&quot;),tfZip);        pane.add(btRegister,1,3);        GridPane.setHalignment(btRegister, HPos.RIGHT);        pane.setAlignment(Pos.CENTER);        tfName.setPrefColumnCount(15);        tfStreet.setPrefColumnCount(15);        tfCity.setPrefColumnCount(10);        tfState.setPrefColumnCount(2);        tfZip.setPrefColumnCount(3);        btRegister.setOnAction(new ButtonListerner());        Scene scene=new Scene(pane,450,200);        primaryStage.setTitle(&quot;StudentClient&quot;);        primaryStage.setScene(scene);        primaryStage.show();    &#125;    private class ButtonListerner implements EventHandler&lt;ActionEvent&gt; &#123;        public void handle(ActionEvent e)        &#123;            try&#123;                Socket socket=new Socket(host,8001);//定义套接字的ip和端口号                //定义套接字的对象输出流                ObjectOutputStream toServer=new ObjectOutputStream(socket.getOutputStream());                String name=tfName.getText().trim();                String street=tfStreet.getText().trim();                String city=tfCity.getText().trim();                String state=tfState.getText().trim();                String zip=tfZip.getText().trim();                StudentAddress s=new StudentAddress(name,street,city,state,zip);                //向对象输出流写入对象                toServer.writeObject(s);            &#125;catch(IOException ex) &#123;                ex.printStackTrace();            &#125;        &#125;    &#125;&#125;\n","tags":["Java进阶"]},{"title":"12.1 反射概念，Class类学习","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-12-1-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%8F%8D%E5%B0%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E5%8F%8D%E5%B0%84%E4%BD%9C%E7%94%A8%EF%BC%8CClass%E7%B1%BB%EF%BC%8C%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%86%E6%9E%90%E7%B1%BB%E7%9A%84%E8%83%BD%E5%8A%9B/","content":"注意：本博客总结自《Java核心技术卷Ⅰ》\n1. 反射的概念\n1.1 什么是反射？\n在java核心技术中的定义是：使用反射机制编写的程序是能够分析类能力的程序。\nJava反射的内容主要在java.lang.reflect包中。\n1.2 我们可以用反射机制来做什么？（4点）\n\n在程序运行时分析类的能力：查看类方法，属性\n在程序运行时查看对象和操作对象：\n\n基于反射自由创建对象\n构建出无法直接访问的类\nset或者get到无法访问的成员变量\n调用不可访问的方法\n\n\n实现通用的数组操作代码，实现泛型数组操作代码\n利用Method对象实现类似函数指针的功能\n\n我们先了解上面反射机制能做什么，随着我们下面的学习，我们将逐步实现上面提到的点。\n我们要注意的是使用反射的主要人员是开发工具的构造者，而不是应用程序员。这意味着反射对于工具级别的开发人员是非常重要的。\n2.Class,Field,Method,Constructor,Modifier类学习\n对上面的定义总感觉有些云里雾里的感觉，似懂非懂，下面我们以实例出发来理解反射。\n2.1 Class类\n2.1.1 如何获得Class对象\n在程序运行期间，Java运行时系统始终为所有的对象保存了一个被称为运行时的类型标识信息，这个信息跟踪着每个对象所属的类，Java虚拟机就是根据这个类型标识信息选择要执行的方法。\n我们可以通过专门的Java类来访问这些类型标识信息，Class类就是其中之一。(Class保存这些信息)\n如何得到Class实例（三种方式）\n有以下三种方式：\n方式一：调用Object种的getClass()方法public Class&lt;?&gt; createClass1()&#123;    Object o = new Object();    return o.getClass();&#125;\n方式二：调用不可变类Class中的静态方法forName()public Class&lt;?&gt; createClass2() throws ClassNotFoundException &#123;    String className=&quot;java.util.Random&quot;;    Class&lt;?&gt; cl = Class.forName(className);//这里的className的内容必须类名或接口名才有效    return cl;&#125;\n方式三：直接Class cl=T.class;public Class&lt;?&gt; createClass3()&#123;    return Object.class;&#125;\n测试之：\npublic static void main(String[] args) throws ClassNotFoundException &#123;    System.out.println(createClass1().getName());    System.out.println(createClass2().getName());    System.out.println(createClass3().getName());&#125;\n\n2.1.2 虚拟机为每个类型管理一个唯一的Class对象\n由于每个类拥有的Class对象是唯一的，所以我们可以利用==运算符实现两个Class对象的比较。\n例如：e.getClass()==Employee.class 的结果，如果e是Employee实例，这个测试将通过，如果e是Employee某个子类的实例，则不通过，这与  instanceof 不同。\n例如：\npublic static void equalsClassTest()&#123;    Class&lt;?&gt; oneClass = Object.class;    Class&lt;?&gt; twoClass = Integer.class;    Class&lt;?&gt; three = new Object().getClass();    System.out.println(oneClass==twoClass);    System.out.println(oneClass==three);&#125;\n\n2.1.3 使用Class对象新建一个实例对象\npublic static void createInstance() throws InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;    Class cl = ArrayList.class;    ArrayList one = (ArrayList) cl.newInstance();    one.add(10);    ArrayList two = (ArrayList) cl.getConstructor().newInstance();    two.add(11);    System.out.println(one);    System.out.println(two);&#125;\n\n反射库提供了一个非常丰富且精心设计的工具集，以便能够动态操纵Java代码的程序。\n2.2 利用反射来分析类能力\n如果我们想要用反射机制来分析类的能力，我们除了需要Class类之外，还需要：\nField,Method,Constructor,Modifier四个类\n下面介绍这些类中的一些要用到的方法(先了解即可)：\n2.2.1 Class 中常用方法学习\n//返回一个包含Field对象的数组，这些对象记录了这个类或其父类的公有域。Field[] getFields();//返回包含Field对象的数组，这些对象记录了这个类的全部域。Field[] getDeclaredFields();//返回包含Method对象的数组，其包含所有的公有方法，包括父类的。Method[] getMethods();//返回包含Method对象的数组，其包含所有的方法，但不包括包括父类的。Method[] getDeclareMethods();//返回包含Constructor对象的数组，其中包含了Class对象所描述的所有公有构造方法。Constructor[] getConstructors();//返回包含Constructor对象的数组，其中包含了Class对象所描述的所有构造方法。Constructor[] getDeclaredConstructors();\n2.2.2 Field类\n包含类的属性定义信息并提供相应的操作。\n常用方法\n//获得Field描述的字段的名称定义public String getName()//从对象obj中获取变量名称为Filed.getName()的值public Object get(Object obj)  //将对象obj中变量名称为Filed.getName()的值设置为指定值public void set(Object obj, Object value)\n使用实例\npublic static void getFiled() throws IllegalAccessException &#123;    Class&lt;?&gt; cl = ArrayList.class;    ArrayList arrayList = new ArrayList();    Field [] fields = cl.getDeclaredFields();    AccessibleObject.setAccessible(fields,true);    for(Field field:fields)&#123;        System.out.println(field.getName()+&quot;:&quot;+ field.get(arrayList));        if(field.getName().equals(&quot;size&quot;))&#123;            System.out.println(&quot;修改size的值为12&quot;);            field.set(arrayList,12);            System.out.println(&quot;修改后的值&quot;+field.getName()+&quot;:&quot;+ field.get(arrayList));        &#125;    &#125;&#125;\n\n2.2.3 Method类\n包含类的方法定义信息，并提供相应的操作。\n常用方法\n//获得方法的名称public String getName()//获得方法参数的Class数组public Class&lt;?&gt;[] getParameterTypes()//获得方法返回类型Classpublic Class&lt;?&gt; getReturnType()//对对象obj执行名称为getName的方法public Object invoke(Object obj, Object... args)\n使用实例：\npublic static void MethodTest() throws InvocationTargetException, IllegalAccessException &#123;    Class&lt;?&gt; cl = ArrayList.class;    ArrayList arrayList = new ArrayList();    Method[] methods = cl.getDeclaredMethods();    for(Method method:methods)&#123;        System.out.println(&quot;方法名称&quot;+method.getName());        System.out.println(&quot;方法参数:&quot;);        Class[] params = method.getParameterTypes();        for(Class zl :params)&#123;            System.out.print(zl.getName()+&quot;,&quot;);        &#125;        System.out.println();        System.out.print(&quot;返回参数：&quot;);        System.out.println(method.getReturnType().getName());        if(method.getName().equals(&quot;add&quot;))&#123;            if(params.length==1)&#123;                System.out.println(&quot;执行add(E e)方法，向数组添加Test&quot;);                method.invoke(arrayList,&quot;Test&quot;);                System.out.println(&quot;查询数组的第一个元素&quot;+arrayList.get(0));            &#125;        &#125;    &#125;&#125;\n\n2.2.4 Constructor类\n包含类的构造器信息，并提供相应的操作。\n常用方法\n//获得方法的名称public String getName()//获得方法参数的Class数组public Class&lt;?&gt;[] getParameterTypes()//使用构造器创建对象public T newInstance(Object ... initargs)\n使用实例：\npublic static void constructorStudy() throws InvocationTargetException, InstantiationException, IllegalAccessException &#123;    Class&lt;?&gt; cl = ArrayList.class;    ArrayList arrayList = null;    Constructor[] constructors = cl.getConstructors();    for(Constructor constructor:constructors)&#123;        System.out.println(&quot;构造器名称：&quot;+constructor.getName());        Class[] classes = constructor.getParameterTypes();        System.out.println(&quot;构造器参数：&quot;);        for(Class zl:classes)&#123;            System.out.print(zl.getName()+&quot; , &quot;);        &#125;        if(classes.length==0)&#123;            System.out.println(&quot;使用ArrayList的无参构造方法创建对象&quot;);            arrayList = (ArrayList) constructor.newInstance();            arrayList.add(&quot;Test&quot;);            System.out.println(arrayList);        &#125;        System.out.println();    &#125;&#125;\n\n2.2.5 Modifier类\n可以通过此类获取类，属性，方法，构造器的访问修饰符\n具体用法如下：\npublic static void modifierTest()&#123;    Class cl = ArrayList.class;    System.out.println(&quot;该类的修饰符为：&quot;+Modifier.toString(cl.getModifiers()));    Field[] fields = cl.getDeclaredFields();    for(Field field:fields)&#123;        System.out.println(&quot;属性 &quot;+field.getName()+&quot;的修饰符为：&quot;+Modifier.toString(field.getModifiers()));    &#125;    Method[] methods = cl.getDeclaredMethods();    for(Method method:methods)&#123;        System.out.println(&quot;方法 &quot;+method.getName()+&quot;的修饰符为：&quot;+Modifier.toString(method.getModifiers()));    &#125;    Constructor[] constructors = cl.getConstructors();    for(Constructor constructor:constructors)&#123;        System.out.println(&quot;构造器 &quot;+constructor.getName()+&quot;的修饰符为：&quot;+Modifier.toString(constructor.getModifiers()));    &#125;&#125;\n\n2.2.6 综合Demo实例展示\n下面是用上面的类来写的一个反射Demo\nDemo的主要内容是在程序中分析java.util.Date类的能力。\n\n完整代码如下：\nimport java.util.*;import java.lang.reflect.*;public class ReflectionTest &#123;    public static void main(String[] args) &#123;        String name;//用于存储类名        if (args.length &gt; 0) &#123;            name = args[0];        &#125; else &#123;            Scanner in = new Scanner(System.in);            System.out.println(&quot;Enter class name (e.g：java.util.Date): &quot;);            name = in.next();        &#125;        try &#123;            Class cl = Class.forName(name);//得到此类的Class实例            Class supercl = cl.getSuperclass();//得到其父类的Class对象            /*返回cl修饰符的字符串表示              int getModifiers();返回一个整数，描述调用对象的修饰符              Modifier.toString(int modifiers);返回此修饰符的字符串表示             */            String modifiers = Modifier.toString(cl.getModifiers());            //打印出这个类的声明            if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;);            System.out.print(&quot;class &quot; + name);            //打印它继承的父类            if (supercl != null &amp;&amp; supercl != Object.class) System.out.print(&quot; extends &quot;                    + supercl.getName());            //打印花括号            System.out.print(&quot;\\n&#123;\\n&quot;);            //打印cl的构造方法            printConstructors(cl);            System.out.println();            //打印cl的其他方法            printMethods(cl);            System.out.println();            //cl中的所有域            printFields(cl);            System.out.println(&quot;&#125;&quot;);        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;        System.exit(0);    &#125;    /**     * 打印出参数cl中描述的构造器信息     * @param cl     */    public static void printConstructors(Class cl) &#123;        //得到包含cl中的全部构造器的一个Constructor对象数组        Constructor[] constructors = cl.getDeclaredConstructors();        for (Constructor c : constructors) &#123;            String name = c.getName();            System.out.print(&quot;   &quot;);            String modifiers = Modifier.toString(c.getModifiers());            if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;);            System.out.print(name + &quot;(&quot;);            // Class[] getParameterTypes(); 返回一个Class对象数组，其中各个对象表示参数的类型            Class[] paramTypes = c.getParameterTypes();            for (int j = 0; j &lt; paramTypes.length; j++) &#123;                if (j &gt; 0) System.out.print(&quot;, &quot;);                System.out.print(paramTypes[j].getName());            &#125;            System.out.println(&quot;);&quot;);        &#125;    &#125;    /**     * 打印出cl描述的类的方法信息     * @param cl     */    public static void printMethods(Class cl) &#123;        //得到这个类中的全部方法数组        Method[] methods = cl.getDeclaredMethods();        for (Method m : methods) &#123;            Class retType = m.getReturnType();//返回一个用于表示返回类型的Class对象            String name = m.getName();            System.out.print(&quot;   &quot;);            // 打印修饰符，返回类型和方法名            String modifiers = Modifier.toString(m.getModifiers());            if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;);            System.out.print(retType.getName() + &quot; &quot; + name + &quot;(&quot;);            // 打印参数部分            Class[] paramTypes = m.getParameterTypes();            for (int j = 0; j &lt; paramTypes.length; j++)            &#123;                if (j &gt; 0) System.out.print(&quot;, &quot;);                System.out.print(paramTypes[j].getName());            &#125;            System.out.println(&quot;);&quot;);        &#125;    &#125;    /**     * 打印出cl描述的类的属性信息     * @param cl     */    public static void printFields(Class cl)&#123;        Field[] fields = cl.getDeclaredFields();//返回包含Field对象的数组，这些对象对应这个类的全部字段        for (Field f : fields) &#123;            Class type = f.getType();            String name = f.getName();            System.out.print(&quot;   &quot;);            String modifiers = Modifier.toString(f.getModifiers());            if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;);            System.out.println(type.getName() + &quot; &quot; + name + &quot;;&quot;);        &#125;    &#125;&#125;\n3.项目代码地址\nJava基础学习/src/main/java/Progress/exa30_1 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"12.3 利用反射编写数组CopyOf方法，调用任意方法","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-12-3-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E7%BC%96%E5%86%99%E6%95%B0%E7%BB%84CopyOf%E6%96%B9%E6%B3%95%EF%BC%8C%E8%B0%83%E7%94%A8%E4%BB%BB%E6%84%8F%E6%96%B9%E6%B3%95/","content":"总结自《Java核心技术卷Ⅰ》\n1.使用反射编写泛型数组代码\njava.lang.reflect包中的Array类允许根据Class动态地创建数组。\n比如Array类中的copyOf方法实现就是用了这个类，这个copyOf方法可以用于扩展一个已经填满的数组。\n我们下面学习学习的是如何让一个特殊类型的数组转换成一个Object类型的数组的更加通用的copyOf方法。\n实现这一目的我们需要用到的方法有：\n\n1.1 学习例子\n\nimport java.lang.reflect.*;import java.util.*;public class CopyOfTest &#123;    public static void main(String[] args) &#123;        int[] a = &#123; 1, 2, 3 &#125;;        a = (int[]) goodCopyOf(a, 10);        System.out.println(Arrays.toString(a));        String[] b = &#123; &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot; &#125;;        System.out.println(&quot;好的copyOf实现方式：&quot;);        b = (String[]) goodCopyOf(b, 10);        System.out.println(Arrays.toString(b));        System.out.println(&quot;不好的copyOf实现方式访问数组：&quot;);        Object[] bad = badCopyOf(b, 10);        System.out.println(Arrays.toString(bad));    &#125;    /**     *  数组复制方法实现     * （并不推荐这种做法,因为这样创建的是Object的数组，不能进行数组类型强转操作，也就是说每次取出元素使用都要进行强转）     * @param a     * @param newLength     * @return     */    public static Object[] badCopyOf(Object[] a, int newLength)&#123;        Object[] newArray = new Object[newLength];        System.arraycopy(a, 0, newArray, 0, Math.min(a.length, newLength));        return newArray;    &#125;    /**     * 数组复制方法实现     * 这种方式的好处是可以对数组类型进行强转的     * @param a     * @param newLength     * @return     */    public static Object goodCopyOf(Object a, int newLength) &#123;        Class&lt;?&gt; cl = a.getClass();        if (!cl.isArray()) return null;        //获得数组元素类型        Class&lt;?&gt; componentType = cl.getComponentType();        int length = Array.getLength(a);//获得数组长度        Object newArray = Array.newInstance(componentType, newLength);        System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength));        return newArray;    &#125;&#125;\n2.使用反射调用任意方法\n反射机制允许我们能不通过调用对象的方法调用对象中我们想要调用的方法。\n在Method中有一个invoke的方法，它允许调用包装在当前Method对象中的方法。\n2.1 例子\n\nimport java.lang.reflect.*;public class MethodTableTest &#123;    public static void main(String[] args) throws Exception &#123;        //获取类MethodTableTest中定义的square(double x)方法对象        Method square = MethodTableTest.class.getMethod(&quot;square&quot;, double.class);        //获取类Math中定义的sqrt(double x)方法对象        Method sqrt = Math.class.getMethod(&quot;sqrt&quot;, double.class);        //通过反射执行        printTable(1, 10, 10, square);        printTable(1, 10, 10, sqrt);    &#125;    /**     * 定义计算一个数值的平方的方法     * @param x     * @return     */    public static double square(double x) &#123;        return x * x;    &#125;    /**     * 这个方法打印出区间 from-to 指定步长的值，并打印出其平方数     * @param from 小边界值     * @param to 大边界值     * @param n 个数     * @param f 方法对象     */    public static void printTable(double from, double to, int n, Method f) &#123;        //打印出Method所描述的方法        System.out.println(f);        //步长        double dx = (to - from) / (n - 1);        for (double x = from; x &lt;= to; x += dx) &#123;            try &#123;                //执行Method所描述的方法                double y = (Double) f.invoke(null, x);                System.out.printf(&quot;%10.4f | %10.4f%n&quot;, x, y);            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;\n3.代码仓库链接\nJava基础学习/src/main/java/Progress/exa30_3 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"12.2 利用反射查看属性信息，对象内部信息","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-12-2-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%8F%8D%E5%B0%84%E6%9F%A5%E7%9C%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC%EF%BC%8C%E6%9F%A5%E7%9C%8B%E4%BB%BB%E6%84%8F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E9%83%A8%E4%BF%A1%E6%81%AF/","content":"总结自《Java核心技术卷Ⅰ》\n1.通过反射机制查看对象属性的值\n利用反射机制可以查看在编译时还不清楚的对象域，就是具体运行时才能获取到的属性的值。\n可以再程序运行时获取对象属性值，其中的关键是Field类中的get方法。\n如果field是一个Field类型的对象，obj是某个包含field的类的对象，则field.get(obj)将返回一个对象，其就是obj名为field.getName()的属性的当前值。\n除此之外我们还可以调用field.set(obj,value)；将obj对象的名为field.getName()的属性设置成新值。\n1.1 实例演示\n1.1.1.Employee.java\npublic class Employee &#123;    private String name;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Employee(String name) &#123;        this.name=name;    &#125;&#125;\n1.1.2 ReflectionTest.java\nimport java.lang.reflect.Field;public class ReflectionTest &#123;    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123;        Employee harry = new Employee(&quot;Harry Hacker&quot;);        Class cl=harry.getClass();        Field f = cl.getDeclaredField(&quot;name&quot;);        //必须有，否则无法访问name的值会出错，作用是将所有域设置成可访问的        f.setAccessible(true);        Object v = f.get(harry);        //输出的是Harry Hacker        System.out.println(v);        f.set(harry,&quot;牧之&quot;);        System.out.println(f.get(harry));    &#125;&#125;\n\n2.编写toString方法来查看任意对象内部信息\n通过上面的学习，我们可以使用反射机制来写出通用的toString程序来打印出任意对象的所有的属性值信息。\n在学习例子之前我们应先了解相关方法：\n\n//此方法能获取当前类的父类的Class,可以用于访问定义在父类的属性public native Class&lt;? super T&gt; getSuperclass();\n2.1 ObjectAnalyzer.java\nimport java.lang.reflect.AccessibleObject;import java.lang.reflect.Array;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.ArrayList;public class ObjectAnalyzer&#123;    private ArrayList&lt;Object&gt; visited = new ArrayList&lt;&gt;();    /**     * 此方法利用放射将传入的对象toString化     * @param obj     * @return String     */    public String toString(Object obj)&#123;        //首先判断传入的对象是否空对象，如果是直接返回null        if (obj == null) return &quot;null&quot;;        //然后判断是否已经传入过相同的对象进来，如果是，返回 ...        if (visited.contains(obj)) return &quot;...&quot;;        //将obj对象加入全局变量visited中        visited.add(obj);        //获得传入对象的class实例        Class&lt;?&gt; cl = obj.getClass();        //判断传入的对象是否是字符串对象，如果是，强转后直接返回        if (cl == String.class)&#123;            return (String) obj;        &#125;        //基本数据类型直接返回其对应的基本类型数值描述//        if(cl==Integer.class||cl==Double.class||cl==Short.class||cl==Byte.class||cl==Float.class||cl==Long.class||cl==Boolean.class||cl==Character.class)&#123;//            return obj.toString();//        &#125;        //如果是数组类型，则        if (cl.isArray()) &#123;            String r = cl.getComponentType() + &quot;[]&#123;&quot;;            for (int i = 0; i &lt; Array.getLength(obj); i++) &#123;                if (i &gt; 0)&#123;                    r += &quot;,&quot;;                &#125;                //获得数组指定位置的元素                Object val = Array.get(obj, i);                //判断元素是不是基本类型                if (cl.getComponentType().isPrimitive()) &#123;                    r += val;                &#125; else &#123;                    r += toString(val);                &#125;            &#125;            System.out.println(r);            return r + &quot;&#125;&quot;;        &#125;        String r = cl.getName();        //将传入对象String化        do &#123;            r += &quot;[&quot;;            Field[] fields = cl.getDeclaredFields();            //这个操作可以让反射机制对私有属性也能进行操作            AccessibleObject.setAccessible(fields, true);            for (Field f : fields) &#123;                if (!Modifier.isStatic(f.getModifiers())) &#123;                    if (!r.endsWith(&quot;[&quot;)) r += &quot;,&quot;;                    r += f.getName() + &quot;=&quot;;                    try &#123;                        Class t = f.getType();                        Object val = f.get(obj);                        //判断属性是不是基本类型                        if (t.isPrimitive()) &#123;                            r += val;                        &#125;                        else r += toString(val);                    &#125;                    catch (Exception e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;            r += &quot;]&quot;;            //获得此类的父类型Class            cl = cl.getSuperclass();        &#125; while (cl != null);        return r;    &#125;&#125;\n2.2 ToStringTest.java\npublic static void main(String[] args) &#123;    Integer squares=new Integer(20);    System.out.println( new ObjectAnalyzer().toString(squares));&#125;\n\n3.代码仓库地址\nJava基础学习/src/main/java/Progress/exa30_2 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"13.1 Lambda表达式基本语法","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-13-1-Java%E8%BF%9B%E9%98%B6%E4%B9%8Blambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%8C%E8%AF%AD%E6%B3%95/","content":"学习总结自《java核心技术卷一》\n1.什么是lambda表达式？\nlambda表达式是一个可传递的代码块，可以在以后执行一次或多次，也就是说，它能让我们无需新建类就能定义方法并执行，得到我们想要的参数。\n其实我们已经接触过lambda表达式了，就是Thread的使用：\npublic static void main(String[] args) &#123;    new Thread(()-&gt;&#123;        for(int i=0;i&lt;10;i++)&#123;            System.out.println(&quot;hehehe&quot;);        &#125;    &#125;).start();&#125;\n\n其中\n()-&gt;&#123;        for(int i=0;i&lt;10;i++)&#123;            System.out.println(&quot;hehehe&quot;);        &#125;    &#125;\n这部分就是一个lambda表达式的代码块，他能直接作为参数传入方法中，而不用去建一个类，然后创建类的实例去传入方法中。lambda表达式能让编程更加简洁。\n2.为什么要引入lambda表达式？\n在引入lambda表达式之前，我们如果想用某一个方法，但这个方法在一个类里，所以我们不得不为了用那一个方法而实例化那个类，这不免让我们感觉有点大材小用。\n在有些其他语言中可以直接处理代码块，因为这个特性其他语言在某些方面比java更优秀。\n所以Java需要一个功能来实现代码块的传递而不需要新建一个实例的方法，于是lambda表达式被引入java中了。\n3.lambda表达式的语法\n下面学习lambda表达式的具体使用。\n3.1 lambda表达式的表现形式\n我们先来看下一个基本的lambda表达式：\n(String first,String second)-&gt;&#123;    return first.length()-second.length()&#125;\n从上面看我们可以了解到lambda表达式就是一个代码块，以及必须传入代码的变量规范。\n参数-&gt;以及一段代码块\n3.1.1 如果代码要完成的计算量无法放在一个表达式中，我们就可以像写方法一样把代码放在花括号里\n(String first,String second)-&gt;&#123; if(first.length()&lt;second.length()) return -1; else if(first.length()&gt;second.length()) return 1; else return 0;&#125;\n实例：\npublic static void lambdaTest1()&#123;    String[] strings = new String[4];    strings[0] = &quot;33123&quot;;    strings[1] = &quot;1&quot;;    strings[2] = &quot;813&quot;;    strings[3] = &quot;1823&quot;;    Arrays.sort(strings,(String first,String second)-&gt;&#123;        if(first.length()&lt;second.length())            return -1;        else if(first.length()&gt;second.length())            return 1;        else return 0;    &#125;);    System.out.println(strings[0]);&#125;\n\n3.1.2 即使lambda表达式没有参数，前面仍要提供小括号\n()-&gt;&#123;    for(int i=100;i&gt;=0;i--)         System.out.println(i);&#125;\n例如：\npublic static void ThreadLambda()&#123;    new Thread(()-&gt;&#123;        for(int i=100;i&gt;=0;i--)            System.out.println(i);    &#125;).start();&#125;\n\n3.1.3 如果可以推导出一个lambda表达式的参数类型，我们可以忽略其类型。\nComparator&lt;String&gt; comp = (first, second) -&gt;&#123;    if(first.length()&lt;second.length())        return -1;    else if(first.length()&gt;second.length())        return 1;    else return 0;&#125;;\n从这里可以看到，lambda表达式其实就是接口方法的快速实现，它能快速实现接口的指定方法而不用去新建类。\n例如：\npublic static void lambdaTest2()&#123;    Comparator&lt;String&gt; comp = (first, second) -&gt;&#123;        if(first.length()&lt;second.length())            return -1;        else if(first.length()&gt;second.length())            return 1;        else return 0;    &#125;;    String[] strings = new String[4];    strings[0] = &quot;33123&quot;;    strings[1] = &quot;1&quot;;    strings[2] = &quot;813&quot;;    strings[3] = &quot;1823&quot;;    Arrays.sort(strings,comp);    System.out.println(strings[0]);&#125;\n\n3.1.4 如果方法只有一个参数，而且这个参数的类型可以推导出，我们甚至可以省略小括号。\nActionListener listener = event-&gt;System.out.println(&quot;Hello&quot;);\n我们知道有着种写法就行，真实使用还是建议带上()\nActionListener listener = (event)-&gt;System.out.println(&quot;Hello&quot;);\n3.1.5 我们无需指定lambda表达式的返回类型。因为lambda表达式的返回类型总是会由上下文推导得出。\n(String first,String second)-&gt;first.length()-second.length()\n例如：\npublic static void lambdaTest1()&#123;    String[] strings = new String[4];    strings[0] = &quot;33123&quot;;    strings[1] = &quot;1&quot;;    strings[2] = &quot;813&quot;;    strings[3] = &quot;1823&quot;;    Arrays.sort(strings,(String first,String second)-&gt;&#123;        if(first.length()&lt;second.length())            return -1;        else if(first.length()&gt;second.length())            return 1;        else return 0;    &#125;);    System.out.println(strings[0]);&#125;\n中的\n(String first,String second)-&gt;&#123;        if(first.length()&lt;second.length())            return -1;        else if(first.length()&gt;second.length())            return 1;        else return 0;    &#125;\n实际上是对\nint compare(T o1, T o2);\n这个方法是实现，所以知道它的返回类型是int型。\n3.1.6 如果一个lambda表达式只在某些分支返回一个值，而在另外一些分支不返回值，这是不合法的。\n(int x)-&gt;&#123;  if(x&gt;=0) return 1;&#125;\n例如：\npublic static void lambdaTest3()&#123;    Comparator&lt;String&gt; comp = (first, second) -&gt;&#123;        if(first.length()&lt;second.length())            return -1;        else if(first.length()&gt;second.length())            return 1;    &#125;;&#125;\n\n上面的表述没有在x&lt;0时返回值，不严谨，所以是不合法的。\n这种情况在代码运行过程中基本不会出现，因为编译器会提示。\n4.代码地址\nJava基础学习/src/main/java/Progress/exa31_1 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"13.2 Lambda表达式函数式接口学习","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-13-2-Java%E8%BF%9B%E9%98%B6%E4%B9%8Blambda%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/","content":"学习总结自《java核心技术卷一》\n1.函数式接口\n我们前面已经说到，lambda表达式其实就是对接口方法的快速实现。\n那是不是所有的接口方法都能让lambda表达式快速实现呢？ 答案是否定的，lambda表达式只能对特殊的接口方法进行快速实现，那就是函数式接口，lambda表达式能对函数式接口的方法进行快速实现。\n1.1 什么是函数式接口？\n对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式替代对象，这样的接口我们称之为函数式接口（functional interface）。(有的接口可能重新声明Object类的方法，这些声明可能会让方法不再是抽象的，且在javaSE8中，接口可以声明非抽象方法)\n1.2 如何用lambda表达式替代？\n我们以下面的例子来理解：\nArrays.sort(words,(first,second)-&gt;first.length()-second.length());\n上面使用了Arrays.sort()方法，它的第二个参数需要一个Comparator的实例，而Comparator就是只有一个抽象方法的接口，\nint compare(T o1, T o2);\n所以我们可以用lambda表达式  (first,second)-&gt;first.length()-second.length() 替代它\n我们要记住：把lambda表达式看作是一个函数，而且lambda表达式可以传递到函数式接口中去\n实际上，在Java中lambda表达式所能做的也只能是转换为函数式接口：\n例如下面的函数式接口\npublic interface ActionListener extends EventListener &#123;    /**     * Invoked when an action occurs.     */    public void actionPerformed(ActionEvent e);&#125;\n使用它\nTimer t= new Timer(1000,(evnet)-&gt;&#123;  System.out.println(&quot;At the tone,the time is&quot;+new Date());  Toolkit.getDefaultToolkit().beep();&#125;);\n上面代码与使用实现了ActionListener接口的类相比，这个代码可读性要好很多。\n演示：\npublic static void main(String[] args) throws InterruptedException &#123;    Timer t = new Timer(1000, event-&gt;&#123;        System.out.println(&quot;At the tone,the time is&quot;+new Date());        Toolkit.getDefaultToolkit().beep();    &#125;);    t.start();    JOptionPane.showMessageDialog(null,&quot;要退出吗?&quot;);    System.exit(0);&#125;\n\n1.3 Java中常用函数式接口\nJava API在java.util.function包中定义了很多非常通用的函数式接口。\n\n1.3.1 Runnable接口\n@FunctionalInterfacepublic interface Runnable &#123;    //抽象方法    public abstract void run();&#125;\n这个接口典型的应用场景就是多线程编程，它没有出参和入参，也没有泛型参数。\n使用实例：\npublic void runnableStudy(Runnable runnable)&#123;    runnable.run();&#125;\n//测试functionStudy.runnableStudy(()-&gt;&#123;    System.out.println(&quot;使用Runnable的lambada表达式打印这句话的&quot;);&#125;);\n\n1.3.2 Supplier接口\n@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123;    T get();&#125;\n可以看到，这个接口没入参，定义了一个泛型出参，我们可以根据需求去使用它。\n例如：\npublic void supplierStudy(Supplier&lt;String&gt; stringSupplier)&#123;    System.out.println(stringSupplier.get());&#125;\n1.3.3 Consumer接口\n@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123;    /**     * Performs this operation on the given argument.     *     * @param t the input argument     */    void accept(T t);&#125;\n这个接口提供了一个泛型入参，无出参的方法。\npublic void consumerStudy(String param,Consumer&lt;String&gt; stringConsumer)&#123;    stringConsumer.accept(param);&#125;\n1.3.4 BiConsumer接口\n@FunctionalInterfacepublic interface BiConsumer&lt;T, U&gt; &#123;    /**     * Performs this operation on the given arguments.     *     * @param t the first input argument     * @param u the second input argument     */    void accept(T t, U u);&#125;\n此函数式接口提供了两个泛型入参，无出参。\n例如：\npublic void biConsumerStudy(String u, String t, BiConsumer&lt;String,String&gt; biConsumer)&#123;    biConsumer.accept(u,t);&#125;\n1.3.5 Function接口\n@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123;    /**     * Applies this function to the given argument.     *     * @param t the function argument     * @return the function result     */    R apply(T t);&#125;\npublic void functionStudy(String t,Function&lt;String,String&gt; function)&#123;    System.out.println(function.apply(t));&#125;\n1.3.6 BiFunction接口\n@FunctionalInterfacepublic interface BiFunction&lt;T, U, R&gt; &#123;    /**     * Applies this function to the given arguments.     *     * @param t the first function argument     * @param u the second function argument     * @return the function result     */    R apply(T t, U u);&#125;\npublic void biFunctionStudy(String t, String u, BiFunction&lt;String,String,String&gt; biFunction)&#123;    System.out.println(biFunction.apply(t,u));&#125;\n1.3.7 UnaryOperator接口\n@FunctionalInterfacepublic interface UnaryOperator&lt;T&gt; extends Function&lt;T, T&gt; &#123;    /**     * Returns a unary operator that always returns its input argument.     *     * @param &lt;T&gt; the type of the input and output of the operator     * @return a unary operator that always returns its input argument     */    static &lt;T&gt; UnaryOperator&lt;T&gt; identity() &#123;        return t -&gt; t;    &#125;&#125;\npublic void unaryOperatorStudy(String s,UnaryOperator&lt;String&gt; unaryOperator)&#123;    System.out.println(unaryOperator.apply(s));&#125;\n1.3.8 BinaryOperator接口\n@FunctionalInterfacepublic interface BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; &#123;&#125;\npublic void binaryOperatorStudy(String s,String t,BinaryOperator&lt;String&gt; binaryOperator)&#123;    System.out.println(binaryOperator.apply(s,t));&#125;\n1.3.9 Predicate接口\n@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123;    /**     * Evaluates this predicate on the given argument.     *     * @param t the input argument     * @return &#123;@code true&#125; if the input argument matches the predicate,     * otherwise &#123;@code false&#125;     */    boolean test(T t);&#125;\npublic void predicateStudy(String s,Predicate&lt;String&gt; predicate)&#123;    if(predicate.test(s))&#123;        System.out.println(&quot;正确！！！！&quot;);    &#125;&#125;\n1.3.10 BiPredicate接口\n@FunctionalInterfacepublic interface BiPredicate&lt;T, U&gt; &#123;    /**     * Evaluates this predicate on the given arguments.     *     * @param t the first input argument     * @param u the second input argument     * @return &#123;@code true&#125; if the input arguments match the predicate,     * otherwise &#123;@code false&#125;     */    boolean test(T t, U u);&#125;\npublic void biPredicateStudy(String t,String u,BiPredicate&lt;String,String&gt; biPredicate)&#123;    if(biPredicate.test(t,u))&#123;        System.out.println(&quot;正确！！&quot;);    &#125;&#125;\n1.3.11 测试实例\npublic static void main(String[] args) &#123;    FunctionStudy functionStudy = new FunctionStudy();    //无入参,出参lambda表达式    functionStudy.runnableStudy(()-&gt;&#123;        System.out.println(&quot;使用Runnable的lambada表达式打印这句话的&quot;);    &#125;);    //无入参,有出参lambda表达式    functionStudy.supplierStudy(()-&gt;&#123;        return &quot;使用Supplier的lambada表达式打印这句话的&quot;;    &#125;);    //一个入参,无出参lambda表达式    functionStudy.consumerStudy(&quot;consumerStudy&quot;,(s)-&gt;&#123;        if(s.contains(&quot;consumer&quot;))&#123;            System.out.println(s);        &#125;    &#125;);    //两个入参,无出参lambda表达式    functionStudy.biConsumerStudy(&quot;BiConsumerStudy&quot;,&quot;two&quot;,(s,t)-&gt;&#123;        System.out.println(s+t);    &#125;);    //一个入参,有出参lambda表达式    functionStudy.functionStudy(&quot;functionStudy&quot;,(s)-&gt;&#123;        return s+&quot;test&quot;;    &#125;);    //两个入参,一个出参lambda表达式    functionStudy.biFunctionStudy(&quot;bi&quot;,&quot;Function&quot;,(s,u)-&gt;&#123;        return s+u;    &#125;);    //一个入参，一个出参lambda表达式    functionStudy.unaryOperatorStudy(&quot;s&quot;,(s)-&gt;&#123;        return s;    &#125;);    //两个入参，一个出参lambda表达式    functionStudy.binaryOperatorStudy(&quot;binary&quot;,&quot;Operation&quot;,(s,v)-&gt;&#123;        return s+v;    &#125;);    //一个入参，指定boolean类型出参lambda表达式    functionStudy.predicateStudy(&quot;isGood&quot;,(s)-&gt;&#123;        return s.contains(&quot;ood&quot;);    &#125;);    //两个入参，指定boolean类型出参lambda表达式    functionStudy.biPredicateStudy(&quot;bi&quot;,&quot;Predicate&quot;,(t,u)-&gt;&#123;        if(t.equals(&quot;bi&quot;)&amp;&amp;u.contains(&quot;cate&quot;))&#123;            return true;        &#125;else            return false;    &#125;);&#125;\n\n1.4 如何使用函数式接口\n想要用lambda表达式做某些处理，还是要谨记表达式的用途，正确使用函数式接口，个人觉得Jdk中提供的一些函数式接口以及够用。\n例如：java.util.function包中有一个接口：\npublic interface Predicate&lt;T&gt;&#123; boolean test(T t);&#125;\nArrayList类有一个removeIf方法，它的参数就是一个Predicate。\npublic boolean removeIf(Predicate&lt;? super E&gt; filter)\n这个接口专门用来传递lambda表达式。如：\nlist.removeIf(e-&gt;e==null);\n上面的语句表示从一个数组列表删除所有的null值。\n2 完整代码仓库地址\nJava基础学习/src/main/java/Progress/exa31_2/FunctionStudy.java · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"13.3 Lambda方法引用","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-13-3-Java%E8%BF%9B%E9%98%B6%E4%B9%8Blambda%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/","content":"1.方法引用\n1.1 复用已有方法传递lambda\n有时我们可能已经有现成的方法可以完成你想要传递到其他代码的某个动作。\n例如：假设我们只希望只要出现一个定时器事件就打印这个事件的对象。\n为此我们可以调用：\nTimer t = new Timer(1000,event-&gt;System.out.println(event));\n但有咩有什么方法可以直接把println方法传递到Timer构造器呢？\n答案是有：\nTimer t = new Timer(1000,System.out::Println);//等价于上面的语句\n演示\n/** * 这里的：(event)-&gt;System.out.println(event) 等价于 * System.out::println */public static void methodReference()&#123;    Timer t = new Timer(1000, (event)-&gt;System.out.println(event));    t.start();    //这里我们看到了：：的使用    //等价于上面的语句,只不过是隐藏了参数    Timer t1 = new Timer(1000,System.out::println);    t1.start();    JOptionPane.showMessageDialog(null,&quot;要退出吗?&quot;);    System.exit(0);&#125;\n\n1.2 : :操作符\n从上面的例子我们可以看出，::操作符可以让我们调用已有的实现作为lambda表达式传入。\n：：操作符的使用场景主要有三种：\n1.2.1 object::instanceMethod\n其中object是类的实例，instanceMethod为实例方法。\n通过这种方式传入的lambda表达式等价于提供方法参数的的表达式\n例如：\nSystem.out::println等价于x-&gt;System.out.println(x)\n1.2.2 Class::staticMethod\n其中Class为类引用，staticMethod为静态方法。\n方法的引用等价于提供方法参数的lambda表达式,例如：\nSystem.out::println等价于x-&gt;System.out.println(x)Math::pow等价于(x,y)-&gt;Math.pow(x,y)\n1.2.3 Class::instanceMethod\n第三种情况中，第一个参数会成为方法的目标。\n例如：\nString::compareToIgnoreCase等价于(x,y)-&gt;x.compareToIgnoreCase(y)\n1.3 构造器引用\n构造器引用与方法引用很类似，只不过方法名为new。\n例如：Person::new 是Person构造器的引用。\n2.变量作用域\n有时候，我们希望能够在lambda表达式中访问外围方法或类中的变量。\n那么这个时候我们需要知道一些知识点。\n2.1 lambda表达式引用外围变量\n\n引用值是一直不会改变的变量。\n在lambda表达式中声明一个与局部变量同名的参数或局部变量是不合法的。\n\n2.2 在lambda表达式中使用this关键字时，是指创建这个lambda表达式的this参数。\n例如：\npublic class Application &#123; public void init()&#123;  ActionListener listener=event-&gt;&#123;    System.out.println(this.toString());  &#125; &#125;&#125;\n表达式this.toString()会调用的是Application对象的toString方法。\n3 代码仓库地址\nJava基础学习/src/main/java/Progress/exa31_3 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"14.1 注解机制概念，工作原理解析","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-14-1-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%B3%A8%E8%A7%A3%E6%A6%82%E5%BF%B5%EF%BC%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","content":"本篇文章学习总结自《Java核心技术卷二》\n1.什么是注解？\n如果使用过Spring做开发，相信对注解并不陌生，相信大家都用过@Resource，@Autowired注解，通过将@Resource这个注解修饰一个类，Spring会自动这个类进行对象创建，通过@Autowired修饰一个变量，Spring会将这个变量赋值为相应的类的对象引用。\n这样我们就能将类的对象的管理交给Spring来进行管理，方便自己的开发工作。\n所以，我们可以把注解看作一种标记工具，通过这种工具，我们能开发出一些框架级别的东西来帮助我们提高编程效率。 我们可以拿它和泛型进行类比。\n首先我们要知道和泛型一样，注解不会改变程序的编译方式，也就是Java编译器对于包含注解和不包含注解的代码会产生相同的虚拟机指令。但通过注解我们可以对一些开发进行简化。\n1.1.如何才能使用注解？\n为了我们能使用注解，我们需要选择一个处理工具，然后向我们的处理工具可以理解的代码中插入注解，之后运用该处理工具处理代码。例如Spring框架就是一个处理工具。\n所以，简单来说，注解就是那些插入到源代码中使用其他工具可以对其进行处理的标签。\n使用注解很简单，真正具有挑战性的是自己开发注解。\n2.注解的基本概念\n在Java中，注解是被当作一个修饰符来使用的，它被置于被注解项之前，中间没有分号，每一个注解的名称前面都加上了一个@符号，注解可以作为代码的一部分。 但是如果没有正确的工具去处理它，注解是不能生效的。\n例如：\npublic class MyClass&#123; @Test  public void checkRandomInsertions();&#125;\n上面代码中的 @Test自身不会做任何事，它需要工具的支持才会有用。（后面会讲到）\n2.1 包含元素的注解\n除了类似于@Test，有的注解中也允许包含参数，我们可以传入参数的值来控制注解的处理逻辑。\n例如：\n@Test(timeout=&quot;10000&quot;)\n包含的元素可以被读取这些注解的工具来处理，元素也允许有多种形式。\n2.2 注解的作用范围\n除方法外，我们还可以注解类，成员变量以及局部变量，我们还可以注解包，参数变量，类型参数以及类型用法，这些注解可以存在于任何可以放置像public ，static修饰符的地方。\n我们可以把注解合理的理解为一个修饰符。\n2.3 注解的定义\n每个注解都必须通过一个注解接口进行定义，这些接口中的方法与注解中的元素相对应。\n例如：\n@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface TestSelf&#123; long timeout() default 0L;&#125;\n其中 @Target 和 @Retention 是元注解，它们注解了TestSelf注解。（@Target将TestSelf注解标识成一个只能运用到方法上的注解,@Retention将TestSelf标识为当类文件载入到虚拟机的时候，仍可以保留下来）\n@interface 声明创建一个Java注解接口，处理注解的工具将接受那些实现这个注解接口的对象，这类工具可以调用timeout方法来检索某个特定Test注解的timeout元素。\n2.4 元注解\n元注解能让我们定义注解的作用范围，从上面我们可以知道的元注解有两个:@Target和@Retention\n2.4.1 @Target\n可以知道，它是定义注解的作用范围是方法级别，还是其他级别的，我们看一下ElementType类：\npublic enum ElementType &#123;    TYPE, //用于类、接口（包括注解类型）或 enum 声明 -ok        FIELD, //用于成员变量（包括枚举常量）-ok        METHOD,  //用于方法 -ok        PARAMETER, //用于参数 -ok        CONSTRUCTOR, // 用于构造方法 -ok       LOCAL_VARIABLE,  // 用于局部变量 -ok       ANNOTATION_TYPE,  // 用于注解类型 -ok       PACKAGE,  // 用于包,不常用      TYPE_PARAMETER, //用于类型参数   @since 1.8  -ok    TYPE_USE //使用一种类型 @since 1.8 -ok&#125;\n可以为指定注解定义多个作用范围,例如：\n@Target(&#123;ElementType.METHOD&#125;)@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)\n具体实例如下：\n//考虑到代码篇幅较大，完整代码在文章底部链接中@TypeTest@TypeUseTestpublic class GoodTest&lt;@TypeParameterTest V&gt; &#123;    @TypeUseTest    @FiledTest    private String field;    @MethodTest    public void doSomething()&#123;        System.out.println(&quot;哈哈哈&quot;);    &#125;    public void doSomething1(@TypeUseTest @ParameterTest String param1)&#123;        System.out.println(&quot;呵呵呵&quot;);    &#125;    @TypeUseTest    @ConstructorTest    public GoodTest()&#123;        System.out.println(&quot;这是构造方法&quot;);    &#125;    public void doSomething3()&#123;        @TypeUseTest        @LocalVariableTest        String local;    &#125;    @TypeUseTest    @AnnotationTypeTest    private @interface test&#123;    &#125;    @TypeUseTest    public int test()&#123;        return 1;    &#125;&#125;\n2.4.2 @Retention\n它是用来定义注解信息的保留级别，用于描述注解的生命周期，也就是该注解被保留的时间长短。@Retention 注解中的成员变量（value）用来设置保留策略，value 是 java.lang.annotation.RetentionPolicy 枚举类型，RetentionPolicy 有 3 个枚举常量，如下所示：\npublic enum RetentionPolicy &#123;    SOURCE, //在源文件中有效（即源文件保留）    CLASS, //在 class 文件中有效（即 class 保留）    RUNTIME //在运行时有效（即运行时保留）&#125;\n上面三者生命周期大小排序为 SOURCE &lt; CLASS &lt; RUNTIME。\n这个需要注解根据我们自定义注解的性质去使用：\n如果需要在运行时去动态获取注解信息，那只能用 RUNTIME\n如果只要在编译时进行一些预处理操作，比如生成一些辅助代码（比如一些脚本信息），就用 CLASS ；\n如果只是做一些检查性的操作，比如 @Override 和 @SuppressWarnings，则可选用 SOURCE 。\n例如下面定义了一个需要在程序运行时去获取注解信息的注解\n@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface TestSelf&#123; long timeout() default 0L;&#125;\n2.4.3 @Documented\n这个注解用来指定修饰的注解类会被javaDoc工具提取为文档。默认情况下javaDoc是不会将注解接口抽取为文档的。\n例如：\n@Documented@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)public @interface MyDocumented &#123;    public String value() default &quot;这是@Documented注解&quot;;&#125;\n@MyDocumentedpublic class DocumentedTest &#123;    /**     * 测试Documented注解知否生效     * @return     */    @MyDocumented    public String test()&#123;        return &quot;测试&quot;;    &#125;&#125;\n2.4.4 @Inherited\n@Inherited 是一个标记注解，用来指定该注解可以被继承。使用 @Inherited 注解的 Class 类，表示这个注解可以被用于该 Class 类的子类。就是说如果某个类使用了被 @Inherited 修饰的注解，则其子类将自动具有该注解。\n实例：\npublic class InheritedTest &#123;    /**     * 使用元注解Inherited     */    @Documented    @Retention(RetentionPolicy.RUNTIME)    @Target(ElementType.TYPE)    @Inherited    private @interface WithInherited &#123;    &#125;    /**     * 不使用元注解Inherited     */    @Documented    @Retention(RetentionPolicy.RUNTIME)    @Target(ElementType.TYPE)    private @interface NoInherited &#123;    &#125;    @WithInherited    @NoInherited    public static class SuperClass &#123;    &#125;    public static class ChildClass extends SuperClass &#123;    &#125;    public static void main(String[] args) &#123;        AnnotatedElement element = SuperClass.class;        System.out.println(&quot;SuperClass 是否被 @WithInherited 注解? &quot; + element.isAnnotationPresent(WithInherited.class));        System.out.println(&quot;SuperClass 是否被 @NoInherited 注解? &quot; + element.isAnnotationPresent(NoInherited.class));        AnnotatedElement childElement = ChildClass.class;        System.out.println(&quot;ChildClass 是否继承 SuperClass 中的 @WithInherited 注解? &quot; + childElement.isAnnotationPresent(WithInherited.class));        System.out.println(&quot;ChildClass 是否继承 SuperClass 中的 @NoInherited 注解? &quot; + childElement.isAnnotationPresent(NoInherited.class));    &#125;&#125;\n\n2.4.5 @Repeatable\n@Repeatable 注解是 Java 8 新增加的，它允许在相同的程序元素中重复注解，在需要对同一种注解多次使用时，往往需要借助 @Repeatable 注解。Java 8 版本以前，同一个程序元素前最多只能有一个相同类型的注解，如果需要在同一个元素前使用多个相同类型的注解，则必须使用注解“容器”。\n例如：\n/** * 注解类型 Repeatable 用于指明它作为元注解所声明的注解类型是可重复的. * 也就是用 @Repeatable 声明的注解 A, 可以作为容器注解, A 保证了被其注解的注解可以重复使用. */public class RepeatableStudy &#123;    /**     * 定义容器注解     */    @Target(ElementType.TYPE)    @Retention(RetentionPolicy.RUNTIME)    private @interface Container &#123;        //这里存储注解Element的参数组        Element[] value();    &#125;    /**     * 定义可复用注解并指向容器注解     */    @Repeatable(Container.class)    private @interface Element &#123;        String value() default &quot;&quot;;    &#125;    /**     * 这里的可复用注解的注解信息会被注解Container接收     * 我们可以通过得到Container信息来获取这里的注解信息     */    @Element(&quot;开始&quot;)    @Element(&quot;准备&quot;)    @Element(&quot;出发&quot;)    @Element(&quot;到达目的地&quot;)    private class Running &#123;    &#125;    public static void main(String[] args) &#123;        //判断Running是否存储了Container注解信息        if(Running.class.isAnnotationPresent(Container.class)) &#123;            Container c = Running.class.getAnnotation(Container.class);            System.out.println(&quot;Running&#x27;s Element:&quot;);            //遍历实际的Element注解中的信息            for(Element e: c.value())&#123;                System.out.println(e.value());            &#125;        &#125;    &#125;&#125;\n\n2.4.6 @Native\n使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可。\n3.了解注解基本工作原理\n3.1  下面我们通过一个例子来学习注解的基本工作原理\n下面有一个程序：\n3.1.1 首先定义注解ActionListernFor.java\n/** * 定义一个ActionListenerFor注解，用于监听方法的执行 * 这个注解只能修饰方法且能在运行时获取其信息 */@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface ActionListenerFor &#123;   String source();&#125;\n3.1.2 然后编写注解处理工具类（这是自定义注解的关键，没有它注解就是个摆设）\nActionListenerInstaller.java\n/** * ActionListener注解处理工具类 */public class ActionListenerInstaller &#123;   /**    * 这个方法为注解生效做好了前提条件    * 主要分为两步：1.扫描出注解修饰的方法 2.将指定方法和注解生效的对象进行绑定    * @param obj 目标对象    */   public static void processAnnotations(Object obj) &#123;      try &#123;         Class&lt;?&gt; cl = obj.getClass();//获取目标对象的Class对象         /*           遍历其方法信息,处理那些被ActionListener修饰的方法          */         for (Method m : cl.getDeclaredMethods()) &#123;            //检查使用ActionListenerFor注解的方法并将其加入监听列表中            ActionListenerFor a = m.getAnnotation(ActionListenerFor.class);            if (a != null) &#123;               //获取Class中名为source注解值的Field对象               Field f = cl.getDeclaredField(a.source());               f.setAccessible(true);               //将方法加入监听中               addListener(f.get(obj), obj, m);            &#125;         &#125;      &#125; catch(ReflectiveOperationException e)&#123;         e.printStackTrace();      &#125;   &#125;   /**    * 此方法将指定的方法和指定的组件进行绑定，已达到监听的效果    * 注意：此方法的实现用到了jdk的动态代理机制，看不懂的同学可以学习下动态代理原理    * @param source 属性对象    * @param param 目标对象    * @param m 方法对象    * @throws ReflectiveOperationException    */   public static void addListener(Object source, final Object param, final Method m) throws ReflectiveOperationException &#123;      //定义一个前置处理器,让按钮在执行完点击事件后执行指定的方法      InvocationHandler handler = new InvocationHandler() &#123;         final Method realM = m;         final Object realProxy = param;            public Object invoke(Object proxy, Method m1, Object[] args) throws Throwable &#123;               System.out.println(m1.getName());               if(m1.getName().equals(&quot;actionPerformed&quot;))&#123;                  System.out.println(&quot;执行actionPerformed!!&quot;);               &#125;               //这个操作就是将param参数传入并执行m方法               return realM.invoke(realProxy);            &#125;         &#125;;      // 获取监听器代理对象      Object listenerProxy = Proxy.newProxyInstance(null,new Class[] &#123; ActionListener.class &#125;, handler);      // 获取指定组件的指定方法对象      Method adder = source.getClass().getMethod(&quot;addActionListener&quot;, ActionListener.class);      //给指定按钮组件加入监听器      adder.invoke(source, listenerProxy);   &#125;&#125;\n3.1.3 应用代码\nButtonFrame.java\n/** * 一个验证ActionListenerFor注解的UI面板 */public class ButtonFrame extends JFrame &#123;   private static final int DEFAULT_WIDTH = 300;   private static final int DEFAULT_HEIGHT = 200;   private JPanel panel;   private JButton yellowButton;   private JButton blueButton;   private JButton redButton;   public ButtonFrame() &#123;      setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT);      panel = new JPanel();      add(panel);      yellowButton = new JButton(&quot;Yellow&quot;);      blueButton = new JButton(&quot;Blue&quot;);      redButton = new JButton(&quot;Red&quot;);      panel.add(yellowButton);      panel.add(blueButton);      panel.add(redButton);      //在这里使用注解处理器让被ActionListenerFor修饰的方法生效      ActionListenerInstaller.processAnnotations(this);   &#125;   /**    * 这里使用注解方法的方式为名为yellowButton的按钮添加监听器    */   @ActionListenerFor(source = &quot;yellowButton&quot;)   public void yellowBackground() &#123;      panel.setBackground(Color.YELLOW);   &#125;   @ActionListenerFor(source = &quot;blueButton&quot;)   public void blueBackground() &#123;      panel.setBackground(Color.BLUE);   &#125;   @ActionListenerFor(source = &quot;redButton&quot;)   public void redBackground() &#123;      panel.setBackground(Color.RED);   &#125;&#125;\n3.1.4 测试代码\n/** * 自定义注解效果测试 */public class ButtonTest &#123;   public static void main(String[] args) &#123;      EventQueue.invokeLater(() -&gt; &#123;            ButtonFrame frame = new ButtonFrame();            frame.setTitle(&quot;ButtonTest&quot;);            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);            frame.setVisible(true);         &#125;);   &#125;&#125;\n我们首先来运行一下上面程序可以看到下面结果：\n\n我们可以很清楚的知道上面的程序中主要有一个图形化的界面和三个按钮，我们每点击一个按钮界面的背景颜色会发生相应的改变。\n我们普通的做法是给每个按钮都注册一个事件监听器，但上面却不是，它是利用注解来完成事件响应的。\n3.2 代码解析\n下面我们分析下它是如何完成的\n3.2.1 首先我们要定义一个注解\n在上面程序中定义了一个名为ActionListenerFor的注解\npackage annotations;import java.lang.annotation.*;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface ActionListenerFor&#123;   String source();&#125;\n处理注解的工具可以调用source()方法来检索注解中的source元素值做处理。\n3.2.2 定义处理注解工具\n当我们定义好一个注解后，它本身是没任何功能的，它就是一个可以标注的注解。 但是如果我们编写了针对这个注解的处理工具，我们就可以让使用工具让这个注解发挥出它的作用。\n在上面的例子中ActionListenerInstaller.java 就是针对ActionListenerFor注解的一种处理工具。\n它的主要作用就是让注解发挥作用，它的真正的功能其实就是让注解了的方法和按钮事件相对应，从而使我们点击按钮会有效果。\n下面我们结合上面的使用注解的地方逐步分析：\n  /** * 这里使用注解方法的方式为名为yellowButton的按钮添加监听器 */@ActionListenerFor(source = &quot;yellowButton&quot;)public void yellowBackground() &#123;   panel.setBackground(Color.YELLOW);&#125;\n我们可以看到，上面的例子中，我们使用了ActionListenerFor修饰了方法yellowBacgroud,在这里我们只是标注了这个方法，那么如何让注解生效呢？\n通过分析代码我们可以知道，真正让注解生效的是：\nActionListenerInstaller.processAnnotations(this);\n**processAnnotations()方法的主要作用就是获取上面的三个注解了的方法，并且将这几个方法自动的注册到监听器中，从而实现了三个按钮的监听。**具体细节大家可以仔细看一下代码。\n下图展示了上面例子中注解是如何被处理的：\n\n可能大家不容易get到上面图的重点，下面是我针对上面图中程序运用API,反射机制处理注解的详细流程解释：\n\n4 完整代码地址\nJava基础学习/src/main/java/Progress/exa32_1 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"15 Scanner类学习","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-15-Java%E8%BF%9B%E9%98%B6%E4%B9%8BScanner%E7%B1%BB%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%8C%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%EF%BC%89/","content":"1.Scanner基础学习\n1.1 Scanner类是个什么类？\n其实这个类并不是一个输入类，只是我们初学的人把它的一种用法作为输入方法而已，从字面意思上来理解，它应该是个扫描类。\nJava 8 API这样解释Scanner类：\n一个简单的文本扫描器，可以使用正则表达式解析原始类型和字符串。\n1.2 构造方法学习\nhttps://www.matools.com/api/java8\n我们常用的Scanner in=new Scanner(System.in);调用的就是Scanner(InputStream source)构造方法。\n通过对Scanner构造方法的学习，我们可以知道Scanner对象能对那些形式的信息进行扫描, Scanner中定义了很多类型的构造器，我们了解其中具有代表性的。\n//这里表示能对Reader，Buffer的信息进行处理public Scanner(Readable source)//扫描器将可以的对指定输入流中的信息进行处理public Scanner(InputStream source)//扫描器将可以的对指定输入流中的信息以指定字符集进行处理public Scanner(InputStream source, String charsetName)//扫描器能对File对象描述的文件中的信息以指定字符集进行处理public Scanner(File source, String charsetName)//扫描器也能对指定路径描述的文件信息进行处理public Scanner(Path source)//扫描器也能对指定字符串进行处理public Scanner(String source)//扫描器能对指定可读通道的信息进行处理public Scanner(ReadableByteChannel source)\n1.3 其他重要方法学习\n\n\n\n方法\n描述\n\n\n\n\nString\tnext()\n查找并返回此扫描仪的下一个完成匹配项。\n\n\nvoid\tclose()\n关闭此扫描器。\n\n\nboolean\thasNext()\n如果此扫描器在其输入中有下一个匹配项，则返回true。默认情况下匹配空格\n\n\nboolean\thasNext(String pattern)\n如果下一个匹配项遵守指定字符串构造的模式，则返回true。\n\n\nint\tnextInt()\n扫描源的下一个int类型的数据\n\n\nint\tradix()\n返回此扫描器的默认基数。\n\n\nString\ttoString()\n返回此 Scanner的字符串表示 。\n\n\nScanner\tuseRadix(int radix)\n将此扫描器的默认基数设置为指定的基数。\n\n\n\n其他API方法大家可以查看API文档进行详细的学习。\n2.Scanner的用法\n2.1.常见用法\n2.1.1 输入流扫描\nScanner sc = new Scanner(System.in);int i = sc.nextInt();通过这种方式来实现数据的手动输入。/** * Scanner输入流构造器学习 */public static void scannerInputStream()&#123;    Scanner sc = new Scanner(System.in);    int i = sc.nextInt();    System.out.println(&quot;你输入了:&quot;+ i);&#125;\n\n通过查看构造方法我们知道它还可以用于文件扫描，路径扫描，字符串扫描，通道扫描。\n2.1.2 .文件扫描\n用法如下：\nFile test=new File(&quot;D:\\\\test.txt&quot;);//这里的路径就是文件的路径，可以用相对路径也可以用绝对路径 Scanner in = new Scanner(test);//这样in中存储的的就是test.txt文本的数据了 //我们可以调用下面方法来对它进行操作  while (in.hasNext())&#123;      String word = in.next();      System.out.println(word); &#125;\n示例：\n/** * 对File文件扫描 * @throws FileNotFoundException */public static void scannerFile() throws FileNotFoundException &#123;    //这里的路径就是文件的路径，可以用相对路径也可以用绝对路径    File test = new File(&quot;麻子.txt&quot;);    //这样in中存储的的就是麻子.txt文本的数据了    Scanner in = new Scanner(test);    //我们可以调用下面方法来对它进行操作    while (in.hasNext())&#123;        String word = in.next();        System.out.print(word);    &#125;&#125;\n\n2.1.3 路径扫描，Path的路径设置相对文件扫描的设置显得麻烦许多\n假设我们想要一个BufferedReader从文件test.txt中读取文件，该文件位于相对于当前工作目录的目录logs中，我们可以：\nPath path = FileSystems.getDefault().getPath(&quot;logs&quot;,&quot;test.txt&quot;);BufferedReader reader=Files.newBufferedReader(path);\n从上面我们看出，它要求把路径分开输入，比较麻烦，所以还是用上面的方式简单点。\n示例：\npublic static void scannerPath() throws IOException &#123;    Path path = FileSystems.getDefault().getPath(&quot;麻子.txt&quot;);    Scanner in = new Scanner(path);    //我们可以调用下面方法来对它进行操作    while (in.hasNext())&#123;        String word = in.next();        System.out.print(word);    &#125;    //BufferedReader reader = Files.newBufferedReader(path);&#125;\n\n2.1.4 字符串扫描\npublic static void scannerString()&#123;    Scanner in = new Scanner(&quot;we should working hard&quot;);    //我们可以调用下面方法来对它进行操作    while (in.hasNext())&#123;        String word = in.next();        System.out.println(word);    &#125;&#125;\n\n2.1.5 通道扫描\npublic static void scannerChannel() throws FileNotFoundException &#123;    File file = new File(&quot;麻子.txt&quot;);    FileInputStream fileInputStream = new FileInputStream(file);    Scanner in = new Scanner(fileInputStream.getChannel());    while (in.hasNext())&#123;        String word = in.next();        System.out.print(word);    &#125;&#125;\n\n3.代码地址\nJava基础学习/src/main/java/Progress/exa33 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"17 异常处理学习机制","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-17-Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%94%A8%E6%B3%95/","content":"1.异常概述\n程序员的理想世界中，用户输入的数据的格式永远都是正确的，选择文件都是存在的，代码永远不会出现bug。\n但在现实世界中，却往往充满了不良的数据和有问题的代码，而这些问题产生的结果我们称之为异常，\n英文名为Excepiton。\n1.1 遇到异常我们应该怎么做？\n我们首先需要明白异常会出现在那些地方？\n大致可以分为三个阶段：\n\n开发期 ： 在这个时期，我们应该尽可能的处理出现的异常，这个时期出现的异常风险最小，能够及时的被修复。\n测试期 ： 这个时期出现的异常往往是测试人员测试过程中出现的异常，这个异常根据类型可以分为：系统异常，业务异常，系统异常比较容易排查问题，修复，业务异常需要开发人员深入分析进行问题排查。\n运行期 ： 如果这个时期出现了异常，那么就意味着出大问题了！！！ 希望我们永远不要遇到。。。\n\n那么，我们该如何去让我们的系统不出现异常呢？\n这就是我们学习的重点了，Java提供了一个异常处理机制可以帮助我们尽可能的减少异常所带来的损失。\n2.异常处理机制学习\n2.1.处理错误\n一般对于用户而言，出现错误时，程序能够采取合理的行为，如果由于出现错误而使得某些操作没有完成，那么我们程序应该：\n返回到一种安全的状态，并能够让用户执行其他的命令。\n允许用户保存所有工作的结果，并以妥善的方式终止程序。\n异常处理的任务就是将控制权从产生错误的地方转移到能够处理这些错误的错误处理器中。\n2.2 常见的错误\n2.2.1 用户输入错误\n除了那些不可避免的键盘输入错误之外，有些用户不喜欢遵守要求输入。\n例如假设有一个用户请求连接一个URL，而这个URL语法却不正确，如果我们的代码中没有进行检查，那么网络层就会报错。(这种错误我们可以选择在前端过滤解决掉，也可以选择在后端过滤解决)\n2.2.2 设备错误\n当硬件出现问题时，我们会发生设备错误。（这种错误大部分无法解决，只能提示用户）\n2.2.3 物理限制\n比如磁盘已经满了。（这个问题采用动态内部处理，也可以提示用户）\n2.2.4 代码错误\n这个就是你的编程问题了。（这个问题的解决方案就是提高自己的编程水平）\n注意：在java中，如果某个方法不能够采用正确的方式完成它的任务，可以通过另外一个途径退出方法，在这种情况下，方法并不返回任何值，而是抛出一个封装了错误信息的对象，然后方法立即退出并不会返回任何值，此时程序也不会从调用这个方法的代码继续执行，而是异常处理机制开始搜索能够处理这种异常状况的异常处理器来处理异常，如果没有找到，此线程直接结束。\n2.3 异常分类\n我们通过前面的学习知道，程序发生异常时会抛出一个对象，我们称之为异常对象，异常对象分很多种，在Java程序设计语言中，异常对象都继承于Throwable类。\n结构图大致如下：\n\n从图中我们可以看出：所有的异常类都是由Throwable扩展而来。\n第二层分为Error和Exception类：\n2.3.1 Error类\nError类层次结构描述了java运行时系统的内部错误和资源耗尽错误。我们的应用程序不应该抛出这种错误，如果出现了这种错误，处理通知用户，并尽力妥善终止程序之外，我们几乎无能为力。\n2.3.2 Exception\n在设计java程序时，要重点关注Exception，我们看到它又被分为了两类：\n一般规则是：\n由编程错误导致的异常属于RuntimeException；\n如果程序没有问题，但由于像I/O错误这类问题导致的异常属于其他异常（IOException）\n\n\n继承于RuntimeException的异常例子：\n+错误的强制类型转换\n\n+数组访问越界\n\n+访问null指针\n\n\n\n其他异常例子：\n+试图打开一个不存在的文件\n\n\n\n+试图根据给定的字符串查找Class对象，而这个字符串表示的类不存在\n\n注意：如果出现了RuntimeException，那么就一定是我们代码的问题,这时我们就要检查代码是否编写正确。\n2.3.3 检查型异常和非检查型异常\n在Java语言中，将继承于Error类或RuntimeException的所有异常称之为非检查型异常（unchecked），对于非检查型异常，我们无法捕获。\n其他所有的异常称之为检查型异常（checked），对于检查型异常我们需要根据自己的需求去进行异常捕获处理。\n注意：编译器将会检查我们是否为所有的检查型异常提供了异常处理器。\n2.4 检查型异常\n如果遇到了无法处理的情况，Java方法可以抛出一个检查型异常来让调用者捕获。\n一个合格的方法不仅要告诉调用者将要返回什么值，还要能在必要的时候告诉调用者发生了什么错误。\n如何实现呢？ 对于返回值，我们都知道用个return 就可以了，那么对于检查型异常呢？\n要让方法抛出发生的错误，我们需要在方法的首部指出这个方法可能抛出的错误，所以要修改方法的首部，以反映这个方法可能抛出的异常：\n一个方法可以声明一个或多个异常\n像FileInputStream的构造方法声明了一个异常\npublic FileInputStream(String name) throws FileNotFoundException &#123;    this(name != null ? new File(name) : null);&#125;\n我们也可以为一个方法声明两个没有包含关系的异常\n例如：\n/** * 这个方法将在发生对应的异常时将其抛出 **/public static void IoException1() throws IOException, ClassNotFoundException &#123;    File file = new File(&quot;noEx&quot;);    InputStream inputStream = new FileInputStream(file);    inputStream.read();    Class cl = Class.forName(&quot;java&quot;);&#125;\n在编写方法时，不必声明这个方法的所有异常，至于什么时候需要在方法中用throws声明异常，以及要用throws子句声明那些异常，需要记住下面的4种情况：\n\n调用了一个抛出检查型异常的方法。\n检测到一个错误，并且利用throw语句抛出一个检查型异常。\n程序出现错误。\nJava虚拟机或运行库出现内部错误。\n\n如果遇到前两种情况，则必须告诉调用这个方法的调用者有可能抛出异常。\n对于后两种情况，我们需要去排查原因，然后优化代码去避免它。\n注意：不可以声明非检查型异常。 总之，一个方法必须声明所有可能抛出的的检查型异常，而非检查型异常要么在我们的控制外，要么从一开始就避免的\n2.5 抛出异常\n前面我们只在方法中声明了异常是不够的，还需要抛出它，这样异常处理器才能获取该异常并进行处理。\n抛出其实非常简单：在必要时刻抛出一个对象就可以了\n/** * 抛出异常 */public static void IoException2() throws IOException, ClassNotFoundException &#123;    File file = new File(&quot;noEx&quot;);    try &#123;        InputStream inputStream = new FileInputStream(file);        inputStream.read();    &#125;catch (FileNotFoundException fileNotFoundException)&#123;        throw new FileNotFoundException(&quot;未找到文件&quot;);    &#125;catch (IOException e)&#123;        e.printStackTrace();        throw new IOException(&quot;文件读取&quot;);    &#125;        try &#123;        Class cl = Class.forName(&quot;java&quot;);    &#125;catch (ClassNotFoundException e)&#123;        throw new ClassNotFoundException(&quot;未找到类文件java.class&quot;);    &#125;    &#125;\n通过前面我们可以看到，如果一个已有的异常类能够满足你的要求，抛出这个异常非常容易：\n\n找到一个合适的异常类\n创建这个类的对象\n将对象抛出\n\npublic static void main(String[] args) &#123;    try &#123;        IoException2();    &#125;catch (Exception e)&#123;        System.out.println(e.getMessage());    &#125;&#125;\n注意：一旦抛出了异常，这个方法就不会返回结果给调用者，而是将异常对象返回给调用者的异常处理器，如果调用者没有做异常捕获处理，则必须抛出这个异常给上层调用者。\n2.6 创建异常类\n如果没有合适的异常类满足我们的要求呢？这时我们可以自己创建一个异常类来满足我们的需求。\n我们的代码可能会遇到任何异常类都无法描述的问题，这时，我们就可以定义一个继承于Exception的类或继承于它的任何子类的类即可。\n例如：\nclass FileFormatException extends IOException&#123;  public FileFormatException() &#123; &#125;  public FileFormatException(String gripe)&#123;    super(gripe);  &#125;&#125;\n创建自定义异常类的习惯做法是，包含两个构造器：一个是默认的构造器，另一个是包含详细信息的构造器（超类Throwable的toString方法会返回一个字符串，其中包含这个详细信息，这在调试中非常有用）\n演示Demo:\nimport java.io.IOException;public class FileFormatException extends IOException &#123;    public FileFormatException()&#123;&#125;    public FileFormatException(String s)&#123;        super(s);    &#125;    public static void main(String[] args) &#123;        try&#123;            throwFiledFormatException(&quot;File:fff&quot;);        &#125;catch (IOException e)&#123;            e.printStackTrace();        &#125;    &#125;    public static void throwFiledFormatException(String file) throws FileFormatException &#123;        if(file.contains(&quot;:&quot;))&#123;            throw new FileFormatException(&quot;file 不能包含：字符&quot;);        &#125;    &#125;&#125;\n\n2.7 捕获异常\n如果发生了异常，但没有任何地方捕获这个异常，程序就会终止，并在控制台上打印一个消息，其中包括这个异常的类型和一个堆栈轨迹。\n如果我们想让我们的程序不随意强退，我们就要捕获检查型异常来避免非正常终止。\n2.7.1 捕获一个异常\ntry&#123;   执行代码&#125;catch(异常类型 e)&#123;   如何处理异常&#125;\n如果try语句块中的任何代码抛出了catch子句中指定的一个异常类，那么：\n\n程序将跳过try语句块的其余代码\n程序将执行catch子句中的处理器代码\n如果try语句块中的代码没有抛出任何异常，那么程序将跳过catch子句。\n\n注意：如果方法中的任何代码抛出了catch子句中没有声明的一个异常类型，那么这个方法就会立即退出（这时我们只能希望它的调用者为这种类型提供了catch子句）\n2.7.2 捕获多个异常\n例子：\ntry&#123;&#125;catch(FileNotFoundException e)&#123;&#125;catch(IOException e)&#123;&#125;\n一般来说，捕获多个异常时，范围小的异常在前面。\n异常对象可能包含有关异常性质的信息，要想获得这个对象的更多信息，我们可以尝试使用：\ne.getMessage();得到详细的错误信息，或者可以使用e.getClass().getName();来获得异常对象的实际类型。\n2.7.3 并列异常捕获(要求catch里的异常不可有包含关系)\ntry&#123;&#125;catch(FileNotFountException | UnknownHostException e)&#123; &#125;\n2.7.4 异常链\ntry&#123;&#125;catch(SQLException e)&#123;  throw new ServletException(&quot;database error &quot; + e.getMessage());&#125;\n然后更外层的方法捕获抛出的这个异常从而形成异常链。\n对于异常链有一种更好的方法，可以把原始异常设置为新异常的 “原因” ：\ntry&#123;&#125;catch(SQLException original)&#123;  Exception e = new ServletException(&quot;datebase error&quot;);  e.initCause(original);  throw e;&#125;\n捕获到这个异常时，可以使用下面的这条语句获取原始异常：\nThrowable original = caughtException.getCause();\n注意：如果在一个方法中发生了一个检查型异常，但这个方法不允许抛出检查型异常，那么包装技术也很有用，我们可以捕获这个检查型异常，并将它包装成一个运行时异常。\n总结：正确认识异常类型，以及定义异常，声明异常，捕获异常的意义。\n3.代码地址\nJava基础学习/src/main/java/Progress/exa35 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"16 字符串的码点，代码单元","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-16-Java%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E7%A0%81%E7%82%B9%E5%92%8C%E4%BB%A3%E7%A0%81%E5%8D%95%E5%85%83/","content":"1.码点与代码单元\n1.1 我们是否真的理解char？\n在我们通常的认知中，char用来表示字符，一个char占两个字节，两个字节可以表示一个字符，所以一个char可以表示一个字符，这似乎没什么毛病。\n但是随着时间的推移，技术不断的发展，有些Unicode字符可以用一个char值表示，但另外有些Unicode字符则需要用超过两个字节才可以表示，即一些Unicode需要用两个char表示。\n这时问题就出现了，一个Unicode字符是否等价一个char字符？\n1.2 什么是码点和代码单元？\n1.2.1 Java字符串由char值序列组成\n其实在Java中String类中维护的是一个char类型的数组，就是说字符串底层上来说还是char序列，也就是字符序列。\n1.2.2 char指的是代码单元\nchar数据类型是一个采用UTF-16编码表示Unicode码点的代码单元，故从上面可知，最常用的Unicode字符使用一个代码单元就可以表示，而辅助字符则需要一对代码单元表示即用两个char表示。\n所以代码单元指的是一个char字符，码点指的是实际的一个具有现实意义的字符。\n我们可以这样认为：一个char字符我们可以称之为代码单元，一个Unicode字符我们称之为码点。\n下面我们通过下面代码来理解：\npublic static void test1()&#123;    //🍷Hello 需要7个char字符进行存储，其中🍷占两个    String test=&quot;🍷Hello&quot;;    //得到的是代码单元的数量 7 🍷占两个代码单元(两个char)    System.out.println(test.length());    // String.codePointCount用来计算字符串中的真实Unicode的数量，也就是码点数量    // 所以它的结果应该是6    System.out.println(test.codePointCount(0,test.length()));&#125;\n\n1.3 String中相关的操作方法\n1.3.1 charAt(n);\n将返回位置n的代码单元 n介于0~test.length()-1之间\npublic static void test2()&#123;    //🍷Hello 需要7个char字符进行存储，其中🍷占两个    String test=&quot;🍷Hello&quot;;    System.out.println(test.charAt(0));    System.out.println(test.charAt(2));&#125;\n\n可以看到，charAt无法正确获取字符串中的码点。\n1.3.2 如果我们想要得到第i个码点\n我们可以：\nint index = test.offsetByCodePoints(0,i);\nint cp = test.codePointAt(index);\n例子\npublic static void test3()&#123;    //🍷Hello 需要7个char字符进行存储，其中🍷占两个    String test=&quot;🍷Hello&quot;;    int index = test.offsetByCodePoints(0,0);    int first = test.charAt(0);    int second = test.charAt(1);    System.out.println(first);    System.out.println(second);    String res = &quot;&quot;+(char)first+(char)second;    System.out.println(res);    int cp = test.codePointAt(index);    System.out.println(cp);&#125;\n\n所以说在字符串中如果有一些非常规字符的话，使用charAt会导致结果不正确。\n1.3.3 如果想要遍历一个字符串\n对于普通的字符串，我们可以使用charAt来遍历（代码单元遍历）。\n例如：\npublic static void test4()&#123;    String test=&quot;Hello&quot;;    for(int i=0;i&lt;test.length();i++)&#123;        System.out.print(test.charAt(i));    &#125;&#125;\n\n对于有非常规字符的字符串，我们就只能遍历码点来实现了。\n例如：\n/** * 遍历带有码点的字符串 */public static void test5()&#123;    String test=&quot;🍷Hello&quot;;    for(int i=0;i&lt;test.length();) &#123;        int[] cp = new int[1];        cp[0] =  test.codePointAt(i);        if(Character.isSupplementaryCodePoint(cp[0])) &#123;            i+=2;            System.out.print(new String(cp,0,1));        &#125; else &#123;            i++;            System.out.print((char)cp[0]);        &#125;    &#125;&#125;\n\n还有一种方法：\npublic static void test6()&#123;    String test=&quot;🍷Hello&quot;;    int [] codePoints = test.codePoints().toArray();    for(int i=0;i&lt;codePoints.length;i++)&#123;        if(Character.isSupplementaryCodePoint(codePoints[i]))&#123;            System.out.print(new String(new int[]&#123;codePoints[i]&#125;,0,1));        &#125;else&#123;            System.out.print((char)codePoints[i]);        &#125;    &#125;&#125;\n\n1.3.4  将码点数组转为字符串\n反之，如果我们要把码点数组转换成一个字符串我们可以\n/** * 码点数组转为字符串 */public static void test7()&#123;    String test=&quot;🍷Hello&quot;;    int [] codePoints=test.codePoints().toArray();    //错误的转换方式    for(int i=0;i&lt;codePoints.length;i++)&#123;        System.out.print((char)codePoints[i]);    &#125;    System.out.println();    //将码点数组转换成字符串    String str=new String(codePoints,0,codePoints.length);    System.out.println(str);&#125;\n\n总结：在做字符串操作的时候一定要注意代码单元与码点之间的区别。\n2 代码地址\nJava基础学习/src/main/java/Progress/exa34 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java进阶"]},{"title":"18 Object类的equals,toString源码解析","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-18-Object%E4%B8%ADequals%E5%92%8CtoStirng-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","content":"我们都知道Object是所有类的父类，那么它里面的一些方法你是否真的理解了呢？\n下面我们就以源码为基础来学习这些看似简单的方法吧！！\n1.equals方法\n我们都知道String中的equals是比较两个字符串对象内容是否相同，但你知道吗，String中的equals其实是对Object中的equals方法的重写，那么equals本来的面目是什么呢？\n请看下面代码，在Object类中，equals的实现如下：\npublic boolean equals(Object obj) &#123;    return (this == obj);&#125;\n从源码看很明显，他其实是判断两个对象的引用是不是同一个。也就是是说，在Object中的equals比较的并不是内容，而是引用，所以，在定义我们自己的类的时候，如果有必要，可以对这个方法进行重写来实现比较内容。\n2.重写equals方法为何一定要重写hashCode方法？\n这个主要是有些处理逻辑需要用到hashCode方法生成的值作为判断两个对象是否相等的依据。\n在通常的认知中，对hashCode的定义是：\n如果两个对象的HashCode相等，则这两个对象不一定相等，如果两个对象的HashCode不相等，那么这两个对象一定不相等。\n反过来说，就是如果两个对象相等，他们的HashCode一定相等，如果两个对象不相等，他们的HashCode可能相等。\n为了遵循这个机制，我们需要重写**。因为如果不进行重写，内容相等的对象计算出来的hashCode也是不相等的。**\n2.1 反例演示\n假如我们新建一个类，对equals进行了重写，但是没有对hashCode进行重写：\npublic class HashCodeStudy &#123;    int i;    @Override    public int hashCode() &#123;        return super.hashCode();    &#125;    @Override    public boolean equals(Object obj) &#123;        if (this == obj) &#123;            return true;        &#125;        try &#123;            if(this.i== obj.getClass().getField(&quot;i&quot;).getInt(obj))&#123;                return true;            &#125;        &#125; catch (IllegalAccessException | NoSuchFieldException e) &#123;            e.printStackTrace();        &#125;        return false;    &#125;    public static void main(String[] args) &#123;        HashCodeStudy obj1 = new HashCodeStudy();        obj1.i = 1;        HashCodeStudy obj2 = new HashCodeStudy();        obj2.i = 1;        System.out.println(&quot;obj1和obj2的内容是否相等？&quot;);        System.out.println(obj1.equals(obj1));        System.out.println(&quot;obj1和obj2的hashCode是否相等？&quot;);        System.out.println(obj1.hashCode()==obj2.hashCode());    &#125;&#125;\n\n我们可以看到，当我们没有对hashCode进行重写时，就会发生两个对象内容相等，但是他们hashCode不相等的情况。这就导致我们不能用HashCode判断两个对象是否相等。\n从另一个角度上看：\n我们不能仅仅通过对象的hashCode去判断两个对象是否相等，还需要根据equals去比较内容。\n例如HashMap的putVal中存在这样一段逻辑：\nif (p.hash == hash &amp;&amp;    ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))    e = p;\n它用来判断两个对象是否相等，可以看到只有在他们hashCode相等时才会进入内容的比较，如果我们不重写hashCode方法，如果两个内容相等的对象的内存地址不同，产生的hashCode是不一样的，就无法通过这段逻辑去判断两个对象是否相等。\n所以为了我们能正常使用集合对对象进行处理，在重写equlas后，想通过equals机制比较对象时，需要重写hashCode方法。\n3.toString方法\n先看一下源码，Object.toString():\npublic String toString() &#123;    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125;\n我们先来调用下，看到底打印出什么信息：\npublic static void main(String[] args) &#123;    Object obj = new Object();    System.out.println(obj.toString());&#125;\n\n从结果来看我们知道前面的java.lang.Object打印的是getClass().getName()的结果，就是这个类的名称，以@为一个分隔符，后面的一串数字是Integer.toHexString(hashCode())的结果，\n前面的getClass().getName()我们容易理解，就是打印出这个类的完整的类名。\n那后面的Integer.toHexString(hashCode());呢？我们先看看hashCode()这个方法：\npublic native int hashCode();\n它是个本地方法，用于生产一个hash码，然后以生产的hash码作为参数来执行Integer类中的toHexString 静态方法，\n//这个方法其实就是讲十进制的数转化为16进制的数的字符串表示public static String toHexString(int i) &#123;    return toUnsignedString0(i, 4);&#125;\n然后以hash码和4作为参数执行toUnsignedString方法返回它执行完成后的结果，这个方法其实就是讲十进制的数转化为16进制的数。\n所以后面的一串数字其实就是生产的hash码的16进制的字符串表示。\n我们可以进入toUnsignedString方法看看：\n这个方法的作用是将整数转换成无符号数。\n/** * Convert the integer to an unsigned number. */private static String toUnsignedString0(int val, int shift) &#123;    // assert shift &gt; 0 &amp;&amp; shift &lt;=5 : &quot;Illegal shift value&quot;;    int mag = Integer.SIZE - Integer.numberOfLeadingZeros(val);    int chars = Math.max(((mag + (shift - 1)) / shift), 1);    char[] buf = new char[chars];    formatUnsignedInt(val, shift, buf, 0, chars);    // Use special constructor which takes over &quot;buf&quot;.    return new String(buf, true);&#125;\n下面我们来分析下这个方法的执行逻辑：\n首先定义一个局部变量mag，他的值是本不变类中常量SIZE（32）和numberOfLeadingZeros(val)的和：（val就是hash码）\npublic static int numberOfLeadingZeros(int i) &#123;    // HD, Figure 5-6    if (i == 0)        return 32;    int n = 1;    if (i &gt;&gt;&gt; 16 == 0) &#123; n += 16; i &lt;&lt;= 16; &#125;    if (i &gt;&gt;&gt; 24 == 0) &#123; n +=  8; i &lt;&lt;=  8; &#125;    if (i &gt;&gt;&gt; 28 == 0) &#123; n +=  4; i &lt;&lt;=  4; &#125;    if (i &gt;&gt;&gt; 30 == 0) &#123; n +=  2; i &lt;&lt;=  2; &#125;    n -= i &gt;&gt;&gt; 31;    return n;&#125;\n这个方法用于返回指定int值的二补二进制表示中最高(“最左”)位之前的零位数。\n然后定义一个局部变量chars，它的值是前面算出来的mag和4通过后面的式子计算出来的值。\n然后定义一个char数组buf，其大小就是chars。\n然后以hash码，4，buf，0，chars作为参数执行formatUnsignedInt方法：\n这个方法用于将一个长字符(视为无符号)格式化到字符缓冲区中\n static int formatUnsignedInt(int val,  int shift, char[] buf,  int offset, int len) &#123;    int charPos = len;    int radix = 1 &lt;&lt; shift;    int mask = radix - 1;    do &#123;        buf[offset + --charPos] = Integer.digits[val &amp; mask];        val &gt;&gt;&gt;= shift;    &#125; while (val != 0 &amp;&amp; charPos &gt; 0);    return charPos;&#125;\n所以这个方法主要会给buf进行赋值。\n最后返回以buf为内容的字符串对象打印出来也就是hash码的16进制表示。\n4. 整型转二进制\n说到整型转16进制，下面我们来了解下整型如何转二进制：\npublic static void main(String[] args) &#123;    byte a = -100;    byte b = 100;    //算法1    String bri = Integer.toBinaryString((a &amp; 0xFF) + 0x100).substring(1);    //算法2,负数的二进制为正数的反码+1    String bri1 = Integer.toBinaryString(~b+1);    System.out.println(bri1.substring(bri1.length()-8));    System.out.println(bri);&#125;\n对于正数，我们可以直接调用Integer.toBinaryString(int n),但是对于负数，它得出的结果是错误的。\n那么我们如何去得到一个负数的二进制表示呢？ 实际上我们只要知道负数的二进制存储形式是：\n对应正数的反码+1 , 然后根据这个规则进行计算即可。\n\n","tags":["Java进阶"]},{"title":"19 Java进阶之动态编译","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-19-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91/","content":"1. 作为程序员的最高追求\n当我们习惯了编写重复的业务代码，是否有时候会感觉到无聊至极！！\n有时候，作为程序员，是否脑子中会不时的闪现出一个想法，如果我能写一个程序让系统能自动的写代码，\n然后再自动的装载到系统中实时编译运行就好了。\n实际上，这并不是不能实现，在JDK8中提供了编译相关的API供我们使用，\n通过JDK8,我们可以实现程序自动生成源代码 ，然后自动进行编译加载，在不停掉系统的前提下新增类并使用它！！\n这就是动态编译。\n2.如何实现动态编译\n简单来说分为四步：\n生成源码–&gt;编译源码生成字节码文件–&gt;加载字节码得到Class对象–&gt;使用Class对象创建对象并使用\n2.1 生成源码\n这一步就是根据业务的不同，我们可以灵活处理，是我们自由发挥的关键。\n我们先写一个例子，加入我们打算在系统编译这个源文件并加载它，我们应该怎么做？\nTest.java\npackage Progress.exa37.complier;public class Test &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;这是要用Java编译器Api进行编译的java源文件&quot;);    &#125;    public void printInfo()&#123;        System.out.println(&quot;成功加载并生成对象,执行printInfo完成&quot;);    &#125;&#125;\n2.2 调用编译器API对Test源码文件进行编译生成字节码\n这一步我们需要详细学习，这是实现源码到字节码的关键，我们先按简单的来，怎么简单怎么来，\n我们可以用JavaCompiler这个类对指定源文件进行编译：\npublic class Test&#123;    public static void main(String[] args) throws FileNotFoundException &#123;        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();        OutputStream outputStream = new FileOutputStream(&quot;output.txt&quot;);        OutputStream errStream = new FileOutputStream(&quot;error.txt&quot;);        //注意这里的路径就是源文件的路径        int result = compiler.run(null,outputStream,errStream,                &quot;../study/Java基础学习/src/main/java/Progress/exa38/complier/Test.java&quot;);        if(result==0)&#123;            System.out.println(&quot;编译成功！！！&quot;);        &#125;    &#125;&#125;\n当运行完成后，会打印出下面的内容，并在程序同级目录下生成一个class文件：\nTest.class\n//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//package Progress.exa37.complier;public class Test &#123;    public Test() &#123;    &#125;    public static void main(String[] var0) &#123;        System.out.println(&quot;这是要用Java编译器Api进行编译的java源文件&quot;);    &#125;    public void printInfo() &#123;        System.out.println(&quot;成功加载并生成对象,执行printInfo完成&quot;);    &#125;&#125;\n到这里，我们已经完成了源码的编译。\n2.3 调用类加载器对字节码进行加载得到Class对象\n这一步非常关键，这一步的成功与否标志着我们能否顺利的创建对象。\n一般用类加载器对字节码进行加载，\n我们一般都选择自己写一个自定义加载器, 实现findClass方法用来得到此类的Class对象.\npackage Progress.exa37.loader;import java.io.IOException;import java.net.URI;import java.net.URISyntaxException;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;public class MyClassLoader extends ClassLoader&#123;    /**     * 根据路径和类全名对字节码文件进行读取并加载     * @param pathName 字节码文件路径     * @param className 类包名     * @return 返回这个类的Class对象     */    protected Class&lt;?&gt; findClass(String pathName,String className) &#123;        // 声明字节码数组        byte[] cLassBytes = null;        Path path = null;        try &#123;            path = Paths.get(new URI(pathName));            // 读取字节码文件的字节码            cLassBytes = Files.readAllBytes(path);        &#125; catch (IOException | URISyntaxException e) &#123;            e.printStackTrace();        &#125;        // 根据类的包名，字节码数组构建class对象        Class&lt;?&gt; clazz = defineClass(className, cLassBytes, 0, cLassBytes.length);        return clazz;    &#125;&#125;\n通过上面的方法我们可以获取到Class对象：\npackage Progress.exa37.loader;import java.lang.reflect.Method;import java.net.MalformedURLException;/** * 使用自定义的类加载器对class文件加载并创建实例使用之 */public class LoaderStudy &#123;    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, MalformedURLException &#123;        MyClassLoader loader = new MyClassLoader();        Class&lt;?&gt; aClass = loader.findClass(&quot;file:///E:/Personal/MyRepository/study/Java基础学习/src/main/java/Progress/exa37/complier/Test.class&quot;,&quot;Progress.exa37.complier.Test&quot;);    &#125;&#125;\n2.4 使用Class对象创建对象进行使用\n通过上面的一步，我们获取到Test.class字节码对应的Class对象后，我们就可以使用Class来创建实例对象了：\npackage Progress.exa37.loader;import java.lang.reflect.Method;import java.net.MalformedURLException;/** * 使用自定义的类加载器对class文件加载并创建实例使用之 */public class LoaderStudy &#123;    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, MalformedURLException &#123;        MyClassLoader loader = new MyClassLoader();        Class&lt;?&gt; aClass = loader.findClass(&quot;file:///E:/Personal/MyRepository/study/Java基础学习/src/main/java/Progress/exa37/complier/Test.class&quot;,&quot;Progress.exa37.complier.Test&quot;);        try &#123;            Object obj = aClass.newInstance();            Method method = aClass.getMethod(&quot;printInfo&quot;);            method.invoke(obj);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n执行结果：\n控制台打印： 成功加载并生成对象,执行printInfo完成\n到这里，我们应该大概明白如何利用java编译器api和类加载器实现动态编译了。\n那么对于类加载器，我们为何要去自定义一个呢？ 难道不能使用Jdk原有的api去实现相应的功能吗？\n要理解这一点，我们就得学习一些Java中的类加载机制。\n3. Java编译API学习\n通过上面的动手，我们可以发现在Java程序中对某个源文件进行编译可以这样：\nJavaCompiler compiler = ToolProvider.getSystemJavaCompiler();//注意这里的路径就是源文件的路径int result = compiler.run(null,outputStream,errStream,    &quot;../study/Java基础学习/src/main/java/Progress/exa38/complier/Test.java&quot;);if(result==0)&#123;    System.out.println(&quot;编译成功！！！&quot;);&#125;\n通过JavaCompiler对象的run方法可以对指定路径的源文件进行编译为字节码文件。\n4. 类加载机制\n下面了解Java的类加载机制。\n我们知道Java程序的执行流程是先将Java源文件编译成字节码文件(存储虚拟机代码)，\n然后由虚拟机去加载这些字节码文件将其转换为对应平台的机器码进行执行。\n而这个虚拟机加载字节码文件的过程，我们有必要进行了解\n2.1 类加载过程\n虚拟机只加载程序执行时所需要的类文件。\n我们假设程序从MyProgram.class开始运行，那么虚拟机的执行步骤如下：\n\n\n虚拟机有一个用于加载类文件的机制，例如从磁盘中读取文件或者请求Web上的文件，虚拟机会使用该机制来加载MyProgram类文件中的内容。\n一个类的加载流程如下：\n\n如果MyProgram类拥有类型为另一个类的域，或者超类，那么这些类文件也会被加载，这一过程被称为类的解析(加载某个类所依赖的所有类的过程被称为类的解析)\n接着，虚拟机执行MyProgram中的静态的main方法\n如果main方法或者main方法调用的方法要用到更多的类，那么接下来就会加载这些类.\n\n\n\n然而，类加载机制并非只使用单个的类加载器，每个Java程序至少拥有三个类加载器：\n\n\n系统类加载器(BootStrap)：\n系统类加载器负责加载系统类(对rt.jar中的类进行加载，为java程序运行时必须的类)。系统类时虚拟机不可分隔的一部分，通常是一些有C语言是实现的底层类。系统类加载器没有对应的ClassLoader对象，它是虚拟机的一部分。\n\n\n扩展类加载器(ExtClassLoader)： \n扩展类加载器用于从jre/lib/ext目录加载 ”标准的扩展“。 我们可以将Jar文件放到该目录下，这样即使没有任何类路径，扩展类加载器也能找到其中的各个类。\n\n\n应用类加载器(AppClassLoader)：\n应用类加载器用于加载应用类。 它由CLASSPATH环境变量或者-classpath命令行选项设置的类路径中的目录里或者jar/zip文件里找到这些类。\n\n\n\n\n注意：在Java中，扩展类加载器和系统类加载器都是用Java实现的，他们都是URLClassLoader类的实例。\n2.2 类加载器的层次结构\n类加载器有一种父/子关系。除了系统类加载器外，其他的每个类加载器都有一个父类加载器。\n根据虚拟机规定，类加载器会为它的父类加载器提供一个机会，以便加载任何给定的类，并且只有在其父类\n加载器加载失败时，它才会加载给定的类。\n例如：当要求应用类加载器加载一个类(例如java.util.ArrayList)时，应用类加载器会先去请求扩展类加载器\n对ArrayList进行加载，然后扩展类会再去请求系统类加载器进行加载，系统类加载器会对其进行加载，如果加载\n失败，则扩展类加载器会对其进行加载，如果扩展类加载器加载失败，则应用类加载器会对其进行加载并返回。\n(有点类似责任链模式)\n2.2.1 使用URLClassLoader加载jar包中的类\n某些程序具有插件架构，其中代码的某些部分是作为可选的插件打包的。\n如果插件被打包为JAR文件，那就可以直接用URLClassLoader类的实例去加载这些类。\nURL url = new URL(&quot;file:///path/to/plugin.jar&quot;);URLClassLoader loader = new URLClassLoader(new URL[]&#123;url&#125;);Class&lt;?&gt; cl = loader.loadClass(&quot;mypackage.myClass&quot;);Object obj = cl.newInstance();\n由于在URLClassLoader构造器中没有指定父类加载器，所以loader的父类加载器就是应用类加载器。\n在Java中，所有的类加载器都应该继承ClassLoader抽象类。\n大多数的时候，我们不需要去干预类加载的层次结构，通常，类是由于其他的类需要它而被加载的，这个过程对我们是透明的。\n2.2.2 干涉类加载过程\n偶尔，有时需要干涉指定类的加载过程。\n思考下面例子：\n应用的代码包含一个help方法，它需要调用Class.forName(classNameString), 而这个方法是从一个插件类中被调用的，\n更巧的是，classNameString指定的正是一个包含在这个插件的Jar包的类。\n插件的作者很合理的期望这个类应该被加载，但是，help方法是由应用类加载器加载的，而classNameString对于应用类\n加载器是不可视的，这个类无法被正常的加载！！\n要解决这个问题，help方法在调用Class.forName(classNameString)之前需要用恰当的类加载器先将这个类加载。\n解决方案：\n每个线程都有一个类加载器的引用，这个引用被称之为上下文类加载器。\n主线程的上下文类加载器是应用类加载器。 当新线程创建时，它的上下文类加载器会被设置为创建该线程的上下文类加载器。\n因此，如果不做额外的操作，那么所有的线程就都会将自己的上下文类加载器设置为应用类加载器！！\n\n所以我们可以这样做：\nThread t = Thread.currentTherad();t.setContextClassLoader(selfloader);\n然后help这个方法就能用自定义的类加载器进行类加载了：\nThread t = Thread.currentThread();ClassLoader loader = t.getContextClassLoader();Class cl = loader.loadClass(className);\n那么问题来了，我们该如何去编写自定义的类加载器呢？\n2.2.3 自定义类加载器\n我们可以编写自己的用于特殊目的的类加载器，这使得我们可以在向虚拟机传递字节码之前执行定制的检查。\n例如我们可以编写一个类加载器，它可以拒绝加载没有标记为 piadfor的类。\n如果要编写自己的类加载器，只需要继承ClassLoader类，然后覆盖这个类的findClass方法:\nClassLoader的loadClass方法用于将类的加载操作委托给其父类加载器进行，\n只有当该类尚未加载并且父类加载器也无法加载该类时，才调用findClass方法。\nprotected Class&lt;?&gt; loadClass(String name, boolean resolve)    throws ClassNotFoundException&#123;    synchronized (getClassLoadingLock(name)) &#123;        // First, check if the class has already been loaded        Class&lt;?&gt; c = findLoadedClass(name);        if (c == null) &#123;            long t0 = System.nanoTime();            try &#123;                //如果类加载器存在父类，先让父类加载                if (parent != null) &#123;                    c = parent.loadClass(name, false);                &#125; else &#123;                    // 如果所有的父类都加载失败，调用rt加载器加载                    c = findBootstrapClassOrNull(name);                &#125;            &#125; catch (ClassNotFoundException e) &#123;                // ClassNotFoundException thrown if class not found                // from the non-null parent class loader            &#125;            // 如果父类加载器和rt加载器都加载失败，则直接调用自己的类加载器加载            if (c == null) &#123;                // If still not found, then invoke findClass in order                // to find the class.                long t1 = System.nanoTime();                // 这里是最后的防线                c = findClass(name);                // this is the defining class loader; record the stats                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                sun.misc.PerfCounter.getFindClasses().increment();            &#125;        &#125;        if (resolve) &#123;            resolveClass(c);        &#125;        return c;    &#125;&#125;\nfindClass方法的实现前提是：\n\n\n为来自本地文件系统或者其他源的类加载其字节码\n\n\n调用ClassLoader的defineClass方法向虚拟机提供字节码\n这样我们就能使用自定义加载器顺利加载自定义类，\n示例：\n\n\npublic class MyClassLoader extends ClassLoader &#123;    /**     * 根据路径和类全名对字节码文件进行读取并加载     * @param pathName 字节码文件路径 file:///E:/Personal/MyRepository/study/Java基础学习/src/main/java/Progress/exa37/complier/Test.class     * @return 返回这个类的Class对象     */    @Override    protected Class&lt;?&gt; findClass(String pathName)  throws ClassFormatError &#123;        // 声明字节码数组        byte[] cLassBytes = null;        Path path = null;        try &#123;            path = Paths.get(new URI(pathName));            // 读取字节码文件的字节码            cLassBytes = Files.readAllBytes(path);        &#125; catch (IOException | URISyntaxException e) &#123;            e.printStackTrace();        &#125;        String className = pathName.substring(pathName.indexOf(&quot;java&quot;)+5,pathName.indexOf(&quot;.class&quot;)).replace(&quot;/&quot;,&quot;.&quot;);        // 根据类的包名，字节码数组构建class对象        Class&lt;?&gt; clazz = defineClass(className, cLassBytes, 0, cLassBytes.length);        return clazz;    &#125;&#125;\n","tags":["Java进阶"]},{"title":"20 i=i++问题解析","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-20-i-i-%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/","content":"看到++i和i++的题目，我们都知道他们是加操作先后的差别，但是仔细想想，我们是否真的懂了？\n思考一个问题：下面代码的运行结果为什么是这样？\npublic static void main(String[] args) &#123;    int i = 10;    int n = 15;    i = i++;    System.out.println(i);&#125;\n想要弄清楚程序的输出结果为什么为10，我们需要对代码执行步骤进行解析：\n首先，主方法栈帧初始化内存，然后给i赋值10，给n赋值15\n然后进行i=i++;的操作，重点就是这里\n我们都知道i=i++;是个复合操作，我们先试着将它分开，可能的计算有两种情况：\n\ni=i; i=i+1;\ni=i+1; i=i;\n这时候就有同学有疑惑了，无论是那种情况，i最后的值都应该是11啊，怎么会输出10呢？\n其实，我们看看字节码的逻辑，Java源文件编译为class文件，Java虚拟机实际执行的是class文件\n上面代码编译后的字节码如下：\n\n   public static void main(String[] args) &#123;    int i = 10;    int n = true;    byte var10000 = i;    int var3 = i + 1;    i = var10000;    System.out.println(i);&#125;\n可以看到它里面使用了var10000来作为一个中间变量存储i开始的值（10），最后赋给i的还是是中间变量的值，它相当于一个缓存吧。\n至于为啥会编译成这样，想要研究的同学可以研究下编译器的相关机制。\n我们都知道CPU每次运算后的值不会直接写到主存中，而是先存放再Cache中再写入主存，这里类似，每条语句的运算结果其实都不会直接赋给那个变量，而是先通过一种中间缓存机制存放，然后赋给相应的变量。\n类似的，i=++i；的问题也就一目了然了\n同理我们看一下i=++i编译成calss码后是什么样子的：\n源码：\npublic static void main(String[] args) &#123;    int i = 10;    int n = 15;    i = i++;    System.out.println(i);    int j = 9;    j = ++j;    System.out.println(j);&#125;\n字节码：\npublic static void main(String[] args) &#123;    int i = 10;    int n = true;    byte var10000 = i;    int var4 = i + 1;    i = var10000;    System.out.println(i);    int j = 9;    int j = j + 1;    System.out.println(j);&#125;\n这时，我们是不是能理解为啥i=i++问题了呢？\n","tags":["Java进阶"]},{"title":"21 ArrayList源码解析","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-21-JDK%E6%BA%90%E7%A0%81%E4%B9%8BArrayList/","content":"一.ArrayList基本属性\n\n\n\n数据类型\n命名\n默认值\n描述\n\n\n\n\nint\nDEFAULT_CAPACITY\n10\n数组默认大小\n\n\nObject[]\nEMPTY_ELEMENTDATA\n{}\n空数组\n\n\nObject[]\nDEFAULTCAPACITY_EMPTY_ELEMENTDATA\n{}\n默认空数组\n\n\nObject[]\nelementData\nnull\n用于存储数组元素数组\n\n\nint\nsize\n0\n元素个数\n\n\n\n二. ArrayList构造方法解析\n1.ArrayList()\n此构造方法很简单，直接将elementData置为{},也就是一个空数组.\n2.ArrayList(int initalCapacity)\n此构造方法将判断initalCapacity是否合法，如果不合法(小于0)，则抛出非法异常。\n合法则正常构建数组：\n当initalCapacity==0 , elementData = { }\n当initalCapacity&gt;0 ,  elementData = new Object[initalCapacity]\n3.ArrayList(Collection c)\n此构造方法会将集合c中的元素复制一份存入elementData中。\n逻辑如下：\n首先将c转化为数组（调用toArray方法）并赋给elementData\n然后判断c的大小是否不等于0，如果不等于0，则将其大小值赋给size，然后调用Arrays.copyOf方法重新开辟相同大小的Object数组空间，将elementData中的值复制到新Object数组中，并赋给elementData.\n如果等于0，则还是elementData = { }\n三.ArrayList常用方法解析\n1.add(Object obj)方法解析\n每次进入add方法，都会为修改记录变量modCount增1，然后判断elementData的长度是否等于size（满了）\n如果满了则需要进行扩容，扩容原则如下：\n如果使用的是默认无参构造方法，size1.5&lt;=size+1，则为elementData开辟10个对象空间。\n如果使用的是指定数量的构造方法，size1.5&lt;=size+1，则为elementData开辟size+1个对象空间。\n如果在原数组的基础上增加了一半后大于size+1且小于MAX_ARRAY_SIZE,则将数组扩容至150%大小。\n然后将就原数组里的元素移到新的大数组中，最后进行赋值操作，size加一。\n2.get(int index)方法解析\nget方法根据index,得到elementData指定位置上的元素。\n进入get方法，首先检查index, 如果index&lt;0或者index&gt;=size,则抛出数组越界异常。\n如果正常，则返回elementData[index]元素的引用。\n3.remove(int index)方法解析\n进入此方法首先进行index的合法性检查，检查没问题进入下一步，否则抛出异常。\n然后把elementData的引用赋给临时不可变变量es上，接着取出index位置上的元素赋给oldValue\n接着进入删除操作中，首先将修改次数modCount加一，然后声明一个newSize = size-1\n如果要删除的位置小于size-1位置，则进行下面操作：将i+1到size-1的一组数移到i到size-2上，否则啥都不做\n接着es[newSize] = null , size = newSize，这样就完成了删除指定位置的元素的操作。\n4.add(int index,Object obj)\n首先对index进行合法性检查。\n然后对修改记录数modCount进行加一操作。\n然后判断当前elementData的size是否等于它的长度，如果等于，则进行扩容。\n接着把index到size-1位置上的数往后移一位，紧接着 elementData[index] = obj\n最后将size加一。\n","tags":["Java进阶"]},{"title":"22 HashMap源码解析","url":"/article/JavaPrograming-Java%E8%BF%9B%E9%98%B6-22-JDK%E6%BA%90%E7%A0%81%E4%B9%8BHashMap/","content":"一.HashMap属性了解\n\n\n\n属性类型\n属性名称\n属性默认值\n属性说明\n\n\n\n\nlong\nserialVersionUID\n362498820763181265L\n序列化编号\n\n\nint\nDEFAULT_INITIAL_CAPACITY\n16\n默认初始化大小\n\n\nint\nMAXIMUM_CAPACITY\n2^30\n最大容量大小\n\n\nfloat\nDEFAULT_LOAD_FACTOR\n0.75f\n默认加载因子\n\n\nint\nTREEIFY_THRESHOLD\n8\n树化临界值\n\n\nint\nUNTREEIFY_THRESHOLD\n6\n非树化临界值\n\n\nint\nMIN_TREEIFY_CAPACITY\n64\n最小树容量\n\n\nNode&lt;K,V&gt;[]\ntable\nnull\n用于存储键值对节点的数组\n\n\nSet&lt;Map.Entry&lt;K,V&gt;&gt;\nentrySet\nnull\n暂时未知其作用\n\n\nint\nsize\n0\nmap中的元素个数\n\n\nint\nmodCount\n0\n操作数\n\n\nfloat\nloadFactor\n0f\n加载因子\n\n\nint\nthreshold\n0\n数组扩容临界值：比如它等于2，则当size=2时，会进行扩容操作\n\n\n\n二. 构造方法解析\n1.HashMap()\n此构造方法只是给HashMap中的加载因子loadFactor进行赋值为默认值 0.75f\n2.HashMap(int initialCapacity)\n此构造方法，以initialCapacity, 0.75f为参数调用第三个构造方法。\n3.HashMap(int initialCapacity,float loadFactor)\n此构造方法存在逻辑：\n如果initialCapacity小于0，抛出非法参数异常\n如果initialCapacity大于2^30，将其修正为2^30\n如果加载因子loadFactor不大于0或者是NaN(类似1/0)，抛出非法参数异常\n将实例的加载因子赋值：this.loadFactor = loadFactor\n计算出下次扩容临界值并给下次扩容临界值赋值：this.threshold = tableSizeFor(initialCapacity);\n计算方法：就是计算出cap的对应的二次方的值，比如当cap = 2时， 返回 2\n当cap = 3 ,返回4， 返回的数肯定大于或等于cap\nstatic final int tableSizeFor(int cap) &#123;    int n = cap - 1;    n |= n &gt;&gt;&gt; 1;    n |= n &gt;&gt;&gt; 2;    n |= n &gt;&gt;&gt; 4;    n |= n &gt;&gt;&gt; 8;    n |= n &gt;&gt;&gt; 16;    return (n &lt; 0) ? 1 : (n &gt;= (1 &lt;&lt; 30)) ? (1 &lt;&lt; 30) : n + 1;&#125;\n4.HashMap(Map m)\n此构造方法的逻辑是先给加载因子赋值： this.loadFactor = 0.75f\n然后判断m的大小是否大于0，\n如果不是，什么都不做，结束。\n如果是\n则判断table是否为空：\n如果是： 计算出map的容量大小(m的大小/加载因子 + 1)t，然后进行检查修正。如果t&gt;threshold , 给threshold赋值。\n如果table不为空，判断m的大小是是否大于了threshold,如果大于了，则进行扩容。\n然后循环m, 取出key,value进行putVal操作。\n三.常用方法解析\n1.resize() 扩容方法\nfinal Node&lt;K, V&gt;[] resize() &#123;    Node&lt;K, V&gt;[] oldTab = table;    int oldCap = (oldTab == null) ? 0 : oldTab.length;    int oldThr = threshold;    int newCap, newThr = 0;    if (oldCap &gt; 0) &#123;        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            return oldTab;        &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; 1; // double threshold    &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold        newCap = oldThr;    else &#123;               // zero initial threshold signifies using defaults        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (int) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;    if (newThr == 0) &#123;        float ft = (float) newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float) MAXIMUM_CAPACITY ?                (int) ft : Integer.MAX_VALUE);    &#125;    threshold = newThr;    Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) new Node[newCap];    table = newTab;    if (oldTab != null) &#123;//这里的操作是将旧的table的数据复制到新的table中    &#125;    return newTab;&#125;\n2.put(K key, V value)\n首先，计算key的hash值，计算逻辑如下：\n如果key==null,则其hash = 0, 否则\nh = key.hashCode()   其中key.hashCode()得到的是一个伪随机数。\nhash = h^(h&gt;&gt;&gt;16)\n然后将，hash, key,value,false,true作为入参调用putVal方法。\n3.putVal(int hash, K key, V value,boolean OnlyIfAbsent，\nboolean evict) 存储方法\n首先声明下面几个变量：\n类型名称描述Node&lt;K,V&gt;[]tab节点数组Node&lt;K,V&gt; p指定位置的节点int n,in存储数组大小，i存储索引\n在进行逻辑学习之前，有必要学习下其中Node数据结构：\nstatic class Node&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; &#123;    final int hash;//hash码，构造时指定    final K key; //键    V value;//值    Node&lt;K, V&gt; next;//出现hash冲突时链接法下一个冲突节点    Node(int hash, K key, V value, Node&lt;K, V&gt; next) &#123;        this.hash = hash;        this.key = key;        this.value = value;        this.next = next;    &#125;&#125;\nputVal方法正式逻辑如下：\n","tags":["Java进阶"]},{"title":"1.汇编理论基础","url":"/article/AssemblyLanguage-1-%E6%B1%87%E7%BC%96%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/","content":"1.汇编语言是如何产生的？\n由于机器语言的复杂性（难于辨别和记忆）给整个产业的发展带来了障碍，于是汇编语言产生了。\n汇编语言的主体是汇编指令，汇编指令相比于机器指令显得更通俗易懂，所以汇编语言替代了机器语言进行CPU编程。\n汇编程序运行过程如下：\n\n2.汇编语言的组成\n汇编语言有三类指令：\n1）汇编指令：它是机器码的助记符，有对应的机器码\n2）伪指令：它没有对应的机器码，有编译器执行，计算机不执行\n3）其他符号：+,-,*,/等符号，没有对应的机器码，由编译器识别\n可想而知，是编译器大大简化了我们对cpu的编程，让我们从复杂难懂的机器语言编程走向更加人性化的编程，所以说编译器是个好东西。\n3.在汇编编程中必须理解的计算机名词\n1）存储器（内存）\nCPU是计算机的核心部件，它控制着整个计算机的运行并进行运算，要想让一个CPU进行工作，我们必须向它提供指令和数据。\n而这个指令和数据就是在存储器中存放的（也就是我们平时理解的内存）。\n我们可以这样理解：\nCPU是计算机的大脑，而存储器就是计算机的记忆了，再聪明的大脑没了记忆也发挥不了作用。\n很多个存储器构成了内存，一个存储器可以分为多个存储单元，一个存储单元一个字节，也就是8bit\n2）指令和数据\n我们要知道，指令和数据是应用上的概念。再内存或磁盘中，指令和数据没有任何区别，都是二进制信息。CPU在工作的时候把有的信息当作指令，有的信息看作数据。\n3）存储单元\n一个存储器可以分为多个存储单元，每个存储单元从0开始编号。 一个存储单元或内存单元中可以存储8bit，也就是1字节。\n4）CPU对存储器的读写\nCPU要想对器件进行数据的读写，必须和外部器件进行下面三类信息交换：\n存储单元的地址（地址信息）通过地址总线传输\n器件的选择，读或写的命令（控制信息） 通过控制线传输\n读或写的数据（数据信息） 通过数据总线传输\n5）地址总线\n一个CPU有N根地址总线，这个CPU的地址总线的宽度为N，这样的CPU最多可以寻找2的N次方个存储单元，所以地址总线的作用就是用于寻找存储单元的。\n6）数据总线\n8根数据总线可以一次传送8bit数据，16根可以一次传输16bit数据，N根可以一次传送 N bit数据。\n7）控制总线\n控制总线的宽度决定了CPU对外部器件的控制能力。\n8）内存地址空间\n什么是内存地址空间呢？\n假设一个CPU的地址总线的宽度为10，那么可以寻址1024个内存单元，这1024个可寻到的内存单元就构成这个CPU的内存地址空间。\n9）主板\n在每一台pc机中，都有一个主板，主板上都有核心器件和一些主要器件，这些器件通过总线（地址总线，数据总线，控制总线）相连。\n这些器件有CPU，存储器，外围芯片组，扩展插槽等等，扩展插槽上一般插有RAM内存条和各类接口卡。\n10）接口卡\n在计算机系统中，所有可用程序想要控制其工作的设备，必须由CPU进行控制。\nCPU对外部设备不能直接控制，比如显示器，音响，打印机等，直接控制这些外设的是插在扩展插槽的接口卡。\n扩展插槽通过总线和CPU相连，所以接口卡也通过总线同CPU相连，CPU可以通过控制这些接口卡从而实现CPU对外设的间接控制。\n简单来说，就是CPU通过总线向接口卡发送命令，然后接口卡将CPU的命令转换成外设的工作命令从而控制外设。\n11）各类存储器芯片\n在一台PC机中，装有多个存储器芯片，这些芯片从物理连接上看是独立的，不同的器件。\n从读写属性上来看存储器分为两类：随机存储器（RAM）和只读存储器（ROM）。随机存储器可读可写，只读存储器只可读不可写。\n其中，随机存储器必须带电存储，关机后存储的内容丢失。只读存储器关机后内容不丢失。\n\n12）内存地址空间\n上述存储器在物理上是独立的器件，但是在以下两点是相同的：\n都和CPU的总线相连\nCPU对他们进行读写的时候都通过控制线发出内存读写命令。\n也就是说，CPU在操控他们的时候把他们都当作内存看待，把他们总的看作一个由若干个存储单元组成的逻辑存储器。\n\n在上图中所有的物理存储器被看作一个由若干个存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一段地址空间，\nCPU在这段地址空间中读写数据实际上就是在相对应的物理存储器中读写数据。\n我们可以根据内存的地址信息来推断出具体的器件。\n内存地址的格式为：段地址：偏移地址\n","tags":["汇编语言"]},{"title":"2.汇编语言Debug使用基础","url":"/article/AssemblyLanguage-2-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80Debug%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/","content":"1.什么是Debug？\nDebug是DOS，Windows都提供的实模式（8086方式）程序的调试工具。使用它，我们可以查看CPU各种寄存器中的内容，内存的情况和在机器码级别的跟踪程序的运行。\n2.Debug命令概述\n1）R命令用来查看，改变CPU寄存器的内容。\n2）D命令用来查看内存中的内容。\n3）E命令用来改写内存中的内容。\n4）U命令用来将内存中的机器指令翻译成汇编指令。\n5）T命令用来执行一条机器指令。\n6）A命令以汇编指令的格式在内存中写入一条机器指令。\n等等，Debug的命令比较多，共有20多个，但上面的6个命令和汇编语言的学习密切相关。\n3.实战Debug命令\n1）点击进入\n\n2）输入debug回车之，进入debug\n\n3）使用R命令查看CPU寄存器的内容\n\n4）使用R命令来改变寄存器的内容\n若要修改一个寄存器中的值，比如我们要修改AX中的值，可用R命令后加寄存器名来进行，输入“r ax” 然后回车，将出现“：”,然后输入数字然后回车就实现了修改寄存器的值\n\n对其他的寄存器同理。\n5）使用D命令查看内存中的内容\n如果我们想知道内存10000H处的内容，我们可以用“d 段地址:偏移地址” 的格式来查看。\n\n6）使用E命令来改写内存中的内容\n比如我们要将内存1000：0~1000：9存储单元中的数据写为0，1，2，3，4，5，6，7，8，9我们可以这样做：\n\n7）用E命令向内存中写入机器码，用U命令查看内存中机器码的含义，用T命令执行内存中的机器码。\n\n然后用R命令将CS:IP指向指令内存地址，然后执行三次T即可\n\n\n8）使用A命令以汇编指令的形式在内存中写入机器指令\n前面我们可以使用E命令来写入机器指令，这样做虽然可以但是非常的不方便，希望最好能以汇编指令的形式写入指令。\n为此，Debug提供了A命令，A命令的使用方法如下：\n\n然后使用T指令来执行即可。\n","tags":["汇编语言"]},{"title":"3.CPU基础知识","url":"/article/AssemblyLanguage-3-CPU%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"1.CPU概述\n一个典型的CPU主要由三部分组成：运算器，控制器，寄存器，这些器件的信息传递主要靠CPU的内部总线进行（不同于外部总线）。\n简单的说，在CPU中：\n运算器进行信息处理\n寄存器进行信息存储\n控制器控制各个器件进行工作\n内部总线连接CPU各内部器件，在它们之间进行数据的传送\n对于一个程序员来说，CPU的主要部件就是寄存器。寄存器是CPU中程序员可以用指令进行控制的部件。\n2.寄存器概述\n不同的CPU寄存器的个数，结构是不一样的。\n8086CPU有14个寄存器，每个寄存器都有一个名称，分别是：\nAX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW.\n我个人将他们分为四类：X结尾的，I结尾的，P结尾的，S结尾的，W结尾的。每一类寄存器的用途不一，下面进行详细学习。\n3.通用寄存器\n在8086cpu中所有寄存器都是16位的，其中AX,BX,CX,DX用来存放一般性数据，被称为通用寄存器，其结构如下：\n\n但是为了兼容上一代的程序，又可以将AX分为AH,AL：\n\n我们可以根据我们的用途来对它们进行灵活使用。\n4.段寄存器\n我们前面学习到，8086CPU在访问内存时要由相关部件提供内存单元的段地址和偏移地址送入地址加法器合成物理地址。\n这里我们需要了解是什么部件提供段地址，段地址在8086CPU的段寄存器中存放:CS,DS,SS,ES.\n1)CS代码段寄存器\nCS:IP两个寄存器决定了CPU当前要读取指令的地址，CS为代码段寄存器，IP为指令指针寄存器（偏移地址）。\n在8086CPU中，任意时刻，设CS中的内容是M，IP中的内容是N，8086CPU将从内存M*16+N单元开始读取一条指令并执行。\n简单来说：任意时刻，CPU将CS:IP指向的内容当作指令执行。\n\n8086CPU的工作流程可以简述为：\n1 从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器。\n2 IP=IP+所读取指令的长度，从而指向下一条指令。\n3 执行指令，转到步骤1，重复这个过程。\n2）修改CS,IP的指令\n如果想同时修改CS,IP的内容，我们可以用\njmp 段地址：偏移地址  来更改，例如：\n1 jmp 2AE3:3 执行后，CS=2AE3H ,IP=0003H\n如果只想更改IP的内容，我们可以用：\n1 jmp 某一合法寄存器\n2 mov ax 0001H\n3 jmp ax 这里ip=0001H了\n3）DS数据段寄存器\nCPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086PC中，内存地址由段地址和偏移地址组成。\nDS寄存器通常用来存放要访问的数据的段地址。比如我们如果要读取10000H单元的内容，我们可以：\n1 MOV BX,1000H\n2 MOV DS,BX\n3 MOV AD,[0]//这里的[0]中的0指的是偏移地址，在执行这条指令是DS被自动取出使用\n这里注意DS不可直接赋值，而是用过一般寄存器间接赋值的，其他的段寄存器也是如此。\n4）SS栈段寄存器\n在cpu栈结构使用中，CPU如何知道栈顶的位置？\n在8086CPU中有两个寄存器，段寄存器SS和就寄存器SP，栈顶的段地址存放在SS中，偏移地址存放在SP中。\n任意时刻，SS:SP指向栈顶元素。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的位置。\n栈又叫先进后出表或后进先出表，现在的CPU中都有栈的设计，所以我们需要了解CPU中的栈。\n8086CPU提供相关的指令来以栈的方式访问内存空间这就意味着我们可以将一段内存当作栈来使用。\n8086提供入栈和出栈指令，最基本的两个就是PUSH入栈，POP出栈。\n1 push ax 表示将寄存器ax中的数据送入栈\n2 pop ax 表示从栈顶取出数据送入ax\n在8086中的入栈和出栈操作都是以字为单位进行的。\n\n看完上面的例子我们知道，在上面我们将10000H~1000FH这段内存当作栈来使用，CPU在执行push和pop指令时将对这段空间\n按照栈的后进先出的规则进行访问的，但是：\nCPU如何知道10000H~1000FH这段内存空间被当作栈呢？\n在执行push和pop的时候CPU又是如何知道那个是栈顶单元？\n在这里SS:SP的作用就出现了，SS段寄存器用来存放栈顶段地址，SP寄存器用于存放栈顶偏移地址，任意时刻，SS:SP指向栈顶元素。\nCPU根据栈段地址：偏移地址的范围就可以推断出栈的内存空间有哪些，这里是可以人为控制的。\n注意：我们在编程的时候要自己操心栈顶越界的问题，要根据可能用到的最大栈空间来安排栈的大小，防止入栈的数据太多而导致的越界，执行出栈操作的时候也要注意。\n","tags":["汇编语言"]},{"title":"4.寄存器学习","url":"/article/AssemblyLanguage-4-%E5%AF%84%E5%AD%98%E5%99%A8%E5%AD%A6%E4%B9%A0/","content":"程序员通过改变各种寄存器中的内容来实现对CPU的控制！！\n1.通用寄存器\n在8086cpu中所有寄存器都是16位的，其中AX,BX,CX,DX用来存放一般性数据，被称为通用寄存器，其结构如下：\n\n但是为了兼容上一代的程序，又可以将AX分为AH,AL：\n\n我们可以根据我们的用途来对它们进行灵活使用来达到存储数据的目的。\n8086CPU中的AX,BX,CX,DX这四个寄存器都可分为两个独立使用的8位寄存器来用：\nAX可分为AH，AL；\nBX可分为BH，BL；\nCX可分为CH，CL；\nDX可分为DH，DL；\n注意，寄存器中没有符号位之说，所以16位寄存器能存储的最大数值为：2^16-1   ，8位寄存器能存储的最大数为：2^8-1\n2.字在寄存器中的存储\n我们知道，出于对兼容性的考虑，8086CPU可以一次性处理以下两种尺寸的数据：\n1）字节（byte）：一个字节由8个bit组成，它可以存放在一个8位寄存器中。\n2）字（word）：一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节。\n汇编中关于数制的讨论：\n任何数据，到了计算机中都是以二进制的形式存放的。为了描述不同的问题，又经常将他们用其他的进制（16进制，10进制）来表示。\n当然，二进制数本身也是表示一个数值的大小，但我们习惯用十进制，所以做这个数制的转换更方便理解其逻辑含义。\n由于一个内存单元可存放8位数据，CPU中的寄存器又可以存放n个8位数据，也就是说，计算机中的数据大多是由1–N个8位数据构成的。\n很多时候，需要直观的看出组成数据的各个字节数据的值，用十六进制来表示数据可以直观的看出这个数据是由哪些8位数据构成的。比如2000\n写成4E20就可以直观的看出，这个数据由4E和20两个8位数据构成的，如果AX中存放4E20那么，AH中存放的就是4E，AL中存放的就是20.\n在后面的学习中，为了区分不同的进制，在十六进制表示的数据的后面加H，在二进制表示的数据后加B,十进制后面什么也不加。\n3.几条汇编指令\n\n\n\n汇编指令\n控制CPU完成的操作\n用高级语言的语法描述\n\n\n\n\nmov ax,18\n将18送入寄存器AX\nAX=18\n\n\nmov ah,78\n将78送入寄存器AH\nAH=78\n\n\nadd ax,8\n将寄存器AX中数值上加8\nAX=AX+8\n\n\nmov ax,bx\n将BX中的数值送入AX中\nAX=BX\n\n\nadd ax,bx\n将AX,BX数值相加，结果存在AX中\nAX=AX+BX\n\n\n\n从上面的表格我们可以总结出：mov是赋值关键字  add是增操作关键字。\n注意：在进行数据传送或运算时，一定要保证两个操作对象的位数要一致！！！ 否则会出错。\n4.物理地址\n我们知道，CPU访问内存时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个唯一的线性空间，\n每一个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址。\nCPU通过地址总线送入存储器的必须是一个内存单元的物理地址，在CPU向地址总线上发出物理地址之前，必须要在内部线形成这个物理地址，不同的CPU可以有不同的形成物理地址的方式。\n5.16位结构的CPU\n概况的说，16位结构描述了一个CPU具有下面几方面的结构特性：\n1）运算器一次最多可以处理16位的数据\n2）寄存器的最大宽度为16位\n3）寄存器和运算器之间的通路为16位。\n6.8086CPU给出物理地址的方法\n8086CPU有20位地址总线，它可以传送20位地址，达到1MB的寻址能力。\n它又是16位的结构，在内部可以一次性处理，传输，暂时存储的地址为16位。从其内部结构来看，它的寻址能力只有64kb。\n8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。\n其相关部件的逻辑结构如下图：\n\n如上图所示，当8086CPU要读写内存时：\n1）CPU中的相关部件提供两个16位的地址，一个称为段地址，一个称为偏移地址。\n2）段地址和偏移地址通过内部总线送入一个称为地址加法器的部件中。\n3）地址加法器将两个16位地址合成为一个20位的物理地址。\n4）地址加法器通过内部总线将20位物理地址送入输入输出控制电路。\n5)输入输出控制电路将20位物理地址送上地址总线。\n6）20位物理地址被地址总线传送到存储器中。\n其中物理地址的算法为：段地址x16+偏移地址\n实例如下：\n\n7.段地址x16+偏移地址=物理地址 的本质含义\n此算法诞生于CPU本身内部 寄存器宽度的局限性。\n段地址x16+偏移地址=物理地址 的本质含义是：CPU在访问内存时，用一个基础地址（段地址x16）和一个相对与基础地址的偏移地址相加，给出内存单元的物理地址。\n这样所无非是想让总线宽度的得到充分利用。增加CPU控制内存的能力。\n8.段的概念\n其实内存并没有分段，段是一种相对的概念，我们可以使用任何一个内存地址作为段地址，而不是每个段都是固定的，相反，段是由我们自己定义的。\n\n如上图，我们既可以将10000H~100FFH分为一段，也可以将其分为两段。\n","tags":["汇编语言"]},{"title":"Git常用命令","url":"/article/Git-1-Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"1.创建仓库\ngit init\n创建本地仓库，这个命令在那个目录中执行，本地仓库就建在哪儿。\n2.添加文件到缓存区\ngit add readme.txt\n将文件readme.txt添加到本地仓库缓存区中，缓存区用于存放需要提交的文件。\n3.提交文件到仓库\ngit commit -m &quot;修改信息&quot;\n将添加到缓存区中的文件提交到仓库中，将文件提交到仓库后，意味着本地这部分代码已经完成，接下来的操作就是与远程文件进行冲突解决和推送。\n4.查看修改了的文件\ngit status\n执行这个命令可以查看到本地未提交的项目和上次对比是否做了修改，并可以看到修改的文件。\n5.查看修改文件修改了那些部分\ngit diff 文件名\n执行此命令可以看到文件修改的具体位置和内容。\n6.查看历史操作记录\ngit log\n此命令可以查看所有的历史操作记录。\n7.回退到上一版本\ngit reset --hard HEAD^\n执行此命令，可以将项目直接回退到上一提交版本。\n8.前进到前一版本\n$ git reset --hard commitid\n我们只需要记住前一个版本的commitid号，然后执行这个命令就可以了。\n但是记不住咋办，这是，我们可以使用下面命令查看：\ngit reflog````执行这个命令我们可以查看到我们执行的所有历史命令。# 9.撤销工作区的修改```shellgit checkout -- readme.txt\n命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：\n一种是readme.txt自修改后还没有被放到暂存区（未进行commit操作），现在，撤销修改就回到和版本库一模一样的状态；\n一种是readme.txt已经添加到暂存区后（进行了commit操作），又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n总之，就是让这个文件回到最近一次git commit或git add时的状态。\n10.撤销添加到暂存区的修改\ngit reset HEAD readme.txt\n用命令git reset HEAD 可以把暂存区的修改撤销掉（unstage），重新放回工作区\n11.从项目中删除文件\nrm 文件名git rm 文件名git commit -m &quot;remove a file&quot;\n然后在仓库中删除文件，最后提交。\n12.误删工作区文件，从仓库中恢复之\ngit checkout -- 文件名\n如果我们在工作区误删了文件，可以通过此命令进行恢复。\n","tags":["Git"]},{"title":"SSH秘钥添加到github","url":"/article/Git-2-%E6%B7%BB%E5%8A%A0SSH-key%E5%88%B0github/","content":"如何将本地的仓库和远程仓库进行同步呢？\n第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，\n再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。\n如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：\n$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;\n你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。\n如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。\n第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：\n然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：\n\n\n为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，\n所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。\n当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，\n就可以在每台电脑上往GitHub推送了。\n最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。\n如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。\n确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。\n","tags":["Git"]},{"title":"新建远程库连接本地库","url":"/article/Git-3-%E6%96%B0%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%9C%AC%E5%9C%B0%E5%BA%93/","content":"1.我们先在github上新建一个仓库，然后赋值它的SSH地址：\n\n2.接着在本地工作目录下打开git执行下面命令：\ngit remote add origin git@github.com:michaelliao/learngit.git\n这时我们可以执行下面命令查看是否连接成功：\ngit remote -v\n\n3.将本地仓库同步至远程仓库\n当我们执行将工作区的文件添加并提交后，我们可以执行下面命令：\ngit push -u origin master\n然后输入 yes即可同步。\n从现在起，只要本地作了提交，就可以通过命令：\ngit push origin master\n把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！\n4.假如我们开始把远程库地址弄错了\n这时我们可以执行下面命令更改和本地仓库同步的远程仓库：\n第一种：使用 git remote set-url 命令，更新远程仓库的\nurlgit remote set-url origin \ngit remote 命令的用法 - 枫飞飞 - 博客园 (cnblogs.com)\n","tags":["Git"]},{"title":"新建本地库克隆远程库","url":"/article/Git-4-%E6%96%B0%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%85%8B%E9%9A%86%E8%BF%9C%E7%A8%8B%E5%BA%93/","content":"首先，我们新建了本地仓库后，然后复制远程仓库的地址：\n\n在本地仓库目录下执行下面命令：\ngit clone git@github.com:michaelliao/gitskills.git\n\n即可。\n","tags":["Git"]},{"title":"了解Maven","url":"/article/Maven-1-%E4%BA%86%E8%A7%A3Maven/","content":"","tags":["Maven"]},{"title":"UML基础","url":"/article/DesignPattern-UML%E5%9F%BA%E7%A1%80/","content":"","tags":["UML语言"]},{"title":"HTML学习","url":"/article/ViewFramework-1-HTML%E5%9F%BA%E7%A1%80/","content":"","tags":["前端基础"]},{"title":"CSS基础","url":"/article/ViewFramework-2-CSS%E5%9F%BA%E7%A1%80/","content":"","tags":["前端基础"]},{"title":"JavaScript学习","url":"/article/ViewFramework-3-JavaScript%E5%9F%BA%E7%A1%80/","content":"","tags":["前端基础"]},{"title":"安全加密算法","url":"/article/%E5%8A%A0%E5%AF%86-1-%E5%AE%89%E5%85%A8%E4%BC%A0%E8%BE%93%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/","content":"一.何为安全传输？\n安全传输就是，即使人家从网络监听到我们发送的数据包，也无法破译我们的信息，或者破译的机会十分渺茫。\n那么这是如何实现的呢？ 毕竟，我们想要传输加密信息，接收者解密的话则需要密钥，而密钥也是需要通过网络传输的啊！！\n1.非对称加密\n密钥的安全传输需要用到一种特殊的加密技术： 非对称加密。\n1.1 何为非对称加密？\n一次非对称加密信息传输包含三个要素： 公钥，私钥，传输报文\n公钥： 源服务器生成，通过网络传输到目标服务器\n私钥： 源服务器生成，绝对保存在本地，不经过任何传输到任何地方，只存在源服务器本地。\n传输报文： 通过公钥或私钥进行加解密\n非对称加密运行流程如下：\n首先，源服务器生成一对密钥： 公钥，私钥。 公钥通过网络明文发送给目标服务器，然后源服务器将要发送的报文用私钥加密后发送给目标服务器，目标服务器拿到密文用公钥解密(这个过程不安全，因为如果其他人监听到公钥了，那么他就可以用公钥对源服务器发出的报文进行解密) ，接着目标服务器用公钥对要发送的报文进行加密，发送到源服务器，源服务器用私钥进行解密即可(这个过程是安全的，因为私钥只有源服务器拥有)\n1.2 非对称加密算法RSA实例\n典型的非对称加密算法RSA应用实例：\npackage RSA;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.nio.charset.Charset;\nimport java.security.*;\nimport java.security.interfaces.RSAPrivateKey;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Arrays;\nimport java.util.Base64;\npublic class RSADemo {\nprivate static final String ENCODE = “UTF-8”;\nprivate static final String AES = “AES”;\nprivate static final String CIPHER_ALGORITHM = “AES/CBC/PKCS5Padding”;\n/**\n* AES加密\n* @param content 加密内容\n* @param AES_IV 加密偏移量\n* @param AES_KEY 加密密钥\n* @return 密文\n* @throws Exception 加密过程中出现的异常\n*/\npublic static String AESEncryptEncode(String content,String AES_IV,String AES_KEY) throws Exception{\nBase64.Decoder decoder = Base64.getDecoder();\nbyte[] keyByte = decoder.decode(AES_KEY);\nint base = 16;\nif (keyByte.length % base != 0) {\nint groups = keyByte.length / base + 1;\nbyte[] temp = new byte [groups * base ];\nArrays.fill(temp, (byte) 0);\nSystem.arraycopy(keyByte, 0, temp, 0, keyByte.length);\nkeyByte = temp;\n}\nSecretKeySpec secretKeySpec = new SecretKeySpec(keyByte,AES);\nCipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\ncipher.init(Cipher.ENCRYPT_MODE,secretKeySpec,new IvParameterSpec(decoder.decode(AES_IV)));\nbyte[] result = cipher.doFinal(content.getBytes(ENCODE));\nreturn Base64.getEncoder().encodeToString(result);\n}\n/**\n* AES解密\n* @param content 密文\n* @param AES_IV 解密偏移量\n* @param AES_KEY 解密密钥\n* @return 解密后明文\n* @throws Exception 异常\n*/\npublic static String AESDecodeDecrypt(String content,String AES_IV,String AES_KEY) throws Exception{\nBase64.Decoder decoder = Base64.getDecoder();\nbyte[] keyByte = decoder.decode(AES_KEY);\nint base = 16;\nif (keyByte.length % base != 0) {\nint groups = keyByte.length / base + 1;\nbyte[] temp = new byte [groups * base ];\nArrays.fill(temp, (byte) 0);\nSystem.arraycopy(keyByte, 0, temp, 0, keyByte.length);\nkeyByte = temp;\n}\nSecretKeySpec secretKeySpec = new SecretKeySpec(keyByte,AES);\nCipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\ncipher.init(Cipher.DECRYPT_MODE,secretKeySpec,new IvParameterSpec(decoder.decode(AES_IV)));\nbyte[] base64 = decoder.decode(content);\nbyte[] result = cipher.doFinal(base64);\nreturn new String(result, Charset.forName(ENCODE));\n}\n/**\n* Rsa生成公钥，密钥\n* @return 返回公钥，密钥字符串数组 0–密钥 1–公钥\n* @throws NoSuchAlgorithmException 异常信息\n*/\npublic static String[] RsaGenera() throws NoSuchAlgorithmException {\n// 1.初始化发送方密钥\nKeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(“RSA”);\nkeyPairGenerator.initialize(512);\nKeyPair keyPair = keyPairGenerator.generateKeyPair();\nRSAPublicKey rsaPublicKey = (RSAPublicKey) keyPair.getPublic();\nRSAPrivateKey rsaPrivateKey = (RSAPrivateKey) keyPair.getPrivate();\nString[] results = new String [2 ];\nresults [0 ] = Base64.getEncoder().encodeToString(rsaPrivateKey.getEncoded());\nresults [1 ] = Base64.getEncoder().encodeToString(rsaPublicKey.getEncoded());\nreturn results;\n}\n/**\n* Rsa私钥加密\n* @param privateKey 私钥\n* @param content 明文\n* @return 返回密文\n* @throws Exception 异常\n*/\npublic static String RsaPrivateEncrypt(String privateKey,String content) throws Exception {\nPKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(Base64.getDecoder().decode(privateKey));\nKeyFactory keyFactory = KeyFactory.getInstance(“RSA”);\nPrivateKey privateKey1 = keyFactory.generatePrivate(pkcs8EncodedKeySpec);\nCipher cipher = Cipher.getInstance(“RSA”);\ncipher.init(Cipher.ENCRYPT_MODE, privateKey1);\nbyte[] result = cipher.doFinal(content.getBytes(ENCODE));\n//System.out.println(“私钥加密、公钥解密 ---- 加密:” + Arrays.toString(result));\nreturn Base64.getEncoder().encodeToString(result);\n}\n/**\n* Rsa公钥解密\n* @param publicKey 公钥\n* @param content 密文\n* @return 明文\n* @throws Exception 异常\n*/\npublic static String RsaPublicUnEncrypt(String publicKey,String content) throws Exception{\nX509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(Base64.getDecoder().decode(publicKey));\nKeyFactory keyFactory = KeyFactory.getInstance(“RSA”);\nPublicKey publicKey1 = keyFactory.generatePublic(x509EncodedKeySpec);\nCipher cipher = Cipher.getInstance(“RSA”);\ncipher.init(Cipher.DECRYPT_MODE, publicKey1);\nbyte[] result = cipher.doFinal(Base64.getDecoder().decode(content));\n//System.out.println(“私钥加密、公钥解密 ---- 解密:” + Base64.getEncoder().encodeToString(result));\nreturn Base64.getEncoder().encodeToString(result);\n}\n/**\n* Rsa公钥加密\n* @param publicKey 公钥\n* @param content 明文\n* @return 密文\n* @throws Exception 异常\n*/\npublic static String RsaPublicEncrypt(String publicKey,String content) throws Exception{\nX509EncodedKeySpec x509EncodedKeySpec2 = new X509EncodedKeySpec(Base64.getDecoder().decode(publicKey));\nKeyFactory keyFactory = KeyFactory.getInstance(“RSA”);\nPublicKey publicKey1 = keyFactory.generatePublic(x509EncodedKeySpec2);\nCipher cipher = Cipher.getInstance(“RSA”);\ncipher.init(Cipher.ENCRYPT_MODE, publicKey1);\nbyte[] result = cipher.doFinal(content.getBytes(ENCODE));\n//System.out.println(&quot;公钥加密、私钥解密 ---- 加密: &quot;+Base64.getEncoder().encodeToString(result2));\nreturn Base64.getEncoder().encodeToString(result);\n}\n/**\n* Rsa私钥解密\n* @param privateKey 私钥\n* @param content 密文\n* @return 解密后明文\n* @throws Exception 异常\n*/\npublic static String RsaPrivateUnEncrypt(String privateKey,String content) throws Exception{\nPKCS8EncodedKeySpec pkcs8EncodedKeySpec5 = new PKCS8EncodedKeySpec(Base64.getDecoder().decode(privateKey));\nKeyFactory keyFactory = KeyFactory.getInstance(“RSA”);\nPrivateKey privateKey1 = keyFactory.generatePrivate(pkcs8EncodedKeySpec5);\nCipher cipher = Cipher.getInstance(“RSA”);\ncipher.init(Cipher.DECRYPT_MODE, privateKey1);\nbyte[] result = cipher.doFinal(Base64.getDecoder().decode(content));\n//System.out.println(“公钥加密、私钥解密 ---- 解密:” + new String(result));\nreturn new String(result);\n}\npublic static void main(String[] args) throws Exception {\nString[] keys = RsaGenera();\nSystem.out.println(“RSA生成密钥对:”);\nSystem.out.println(“公钥：”+keys [1 ]);\nSystem.out.println(“私钥：”+keys [0 ]);\nString test = RsaPublicEncrypt(keys [1 ],“今天打老虎”);\nSystem.out.println(“公钥加密：今天打老虎–&gt;”+test);\nString test2 = RsaPrivateUnEncrypt(keys [0 ],test);\nSystem.out.println(“私钥解密：”+test+“–&gt;”+test2);\n}\n}\n运行结果：\n\n2.对称加密\n对称加密技术是一种很广泛的加密技术。\n2.1 何为对称加密\n对称加密的元素主要有两个： 密钥，报文\n密钥： 通信双方提前约定好的密钥\n报文： 用相同的密钥进行加密和解密的报文\n对称加密的运行流程如下：\n首先通信双方约定好密钥，然后源服务器发送到目标服务器的密文用密钥加密，目标服务器用密钥解密密文即可。（如果密钥还是通过网络传输，则这种通信还是不安全的，除非双方线下约定且保证没有第三个人知道）\n2.2 对称加密AES/CBC加密实例\npackage RSA;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.Base64;\npublic class AESDemo {\nprivate static final String ENCODE = “UTF-8”;\nprivate static final String AES = “AES”;\nprivate static final String AES_IV = “49U2GlzcrBmS9UVz+mEE3Q==”;\nprivate static final String AES_KEY = “D8M1+eb6mzq0Oc23K+YQYQ==”;\nprivate static final String CIPHER_ALGORITHM = “AES/CBC/PKCS5Padding”;\n/**\n* AES加密\n* @param content 加密内容\n* @param AES_IV 加密偏移量\n* @param AES_KEY 加密密钥\n* @return 密文\n* @throws Exception 加密过程中出现的异常\n*/\npublic static String AESEncryptEncode(String content,String AES_IV,String AES_KEY) throws Exception{\nBase64.Decoder decoder = Base64.getDecoder();\nbyte[] keyByte = decoder.decode(AES_KEY);\nint base = 16;\nif (keyByte.length % base != 0) {\nint groups = keyByte.length / base + 1;\nbyte[] temp = new byte [groups * base ];\nArrays.fill(temp, (byte) 0);\nSystem.arraycopy(keyByte, 0, temp, 0, keyByte.length);\nkeyByte = temp;\n}\nSecretKeySpec secretKeySpec = new SecretKeySpec(keyByte,AES);\nCipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\ncipher.init(Cipher.ENCRYPT_MODE,secretKeySpec,new IvParameterSpec(decoder.decode(AES_IV)));\nbyte[] result = cipher.doFinal(content.getBytes(ENCODE));\nreturn Base64.getEncoder().encodeToString(result);\n}\n/**\n* AES解密\n* @param content 密文\n* @param AES_IV 解密偏移量\n* @param AES_KEY 解密密钥\n* @return 解密后明文\n* @throws Exception 异常\n*/\npublic static String AESDecodeDecrypt(String content,String AES_IV,String AES_KEY) throws Exception{\nBase64.Decoder decoder = Base64.getDecoder();\nbyte[] keyByte = decoder.decode(AES_KEY);\nint base = 16;\nif (keyByte.length % base != 0) {\nint groups = keyByte.length / base + 1;\nbyte[] temp = new byte [groups * base ];\nArrays.fill(temp, (byte) 0);\nSystem.arraycopy(keyByte, 0, temp, 0, keyByte.length);\nkeyByte = temp;\n}\nSecretKeySpec secretKeySpec = new SecretKeySpec(keyByte,AES);\nCipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\ncipher.init(Cipher.DECRYPT_MODE,secretKeySpec,new IvParameterSpec(decoder.decode(AES_IV)));\nbyte[] base64 = decoder.decode(content);\nbyte[] result = cipher.doFinal(base64);\nreturn new String(result, Charset.forName(ENCODE));\n}\npublic static void main(String[] args) throws Exception {\nString m = AESEncryptEncode(“今天打老虎”,AES_IV,AES_KEY);\nSystem.out.println(&quot;AES对称加密： &quot;+m);\nSystem.out.println(“AES对称解密：”+AESDecodeDecrypt(m,AES_IV,AES_KEY));\n}\n}\n\n3. 通过非对称+对称加密实现网络安全传输\n通过前面的学习我们知道，安全传输的关键在于密钥不能被泄露，我们可以试想一下，我们能不能先用非对称加密传输密钥，然后用对称加密进行报文传输，这样的话不久实现了，加密传输。\n流程如下：\n首先源服务器生成私钥，公钥，将公钥发送给目标服务器，然后目标服务器用公钥加密对称密钥发送给源服务器，接着源服务器将密文解密得到对称密钥，这样就只有双方知道对称密钥了，不存在第三方知道了。\n然后以后的信息传输就用对称密钥加解密即可。\n3.1 结合RSA和AES/CBC实现安全传输Demo\n非对称加密进行对称密钥传输，对称加密实现报文安全传输。\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.security.*;\nimport java.security.interfaces.RSAPrivateKey;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Arrays;\nimport java.util.Base64;\npublic class EncryptUtil {\nprivate static final String ENCODE = “UTF-8”;\nprivate static final String AES = “AES”;\nprivate static final String AES_IV = “49U2GlzcrBmS9UVz+mEE3Q==”;\nprivate static final String AES_KEY = “D8M1+eb6mzq0Oc23K+YQYQ==”;\nprivate static final String CIPHER_ALGORITHM = “AES/CBC/PKCS5Padding”;\n/**\n* AES加密\n* @param content 加密内容\n* @param AES_IV 加密偏移量\n* @param AES_KEY 加密密钥\n* @return 密文\n* @throws Exception 加密过程中出现的异常\n*/\npublic static String AESEncryptEncode(String content,String AES_IV,String AES_KEY) throws Exception{\nBase64.Decoder decoder = Base64.getDecoder();\nbyte[] keyByte = decoder.decode(AES_KEY);\nint base = 16;\nif (keyByte.length % base != 0) {\nint groups = keyByte.length / base + 1;\nbyte[] temp = new byte [groups * base ];\nArrays.fill(temp, (byte) 0);\nSystem.arraycopy(keyByte, 0, temp, 0, keyByte.length);\nkeyByte = temp;\n}\nSecretKeySpec secretKeySpec = new SecretKeySpec(keyByte,AES);\nCipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\ncipher.init(Cipher.ENCRYPT_MODE,secretKeySpec,new IvParameterSpec(decoder.decode(AES_IV)));\nbyte[] result = cipher.doFinal(content.getBytes(ENCODE));\nreturn Base64.getEncoder().encodeToString(result);\n}\n/**\n* AES解密\n* @param content 密文\n* @param AES_IV 解密偏移量\n* @param AES_KEY 解密密钥\n* @return 解密后明文\n* @throws Exception 异常\n*/\npublic static String AESDecodeDecrypt(String content,String AES_IV,String AES_KEY) throws Exception{\nBase64.Decoder decoder = Base64.getDecoder();\nbyte[] keyByte = decoder.decode(AES_KEY);\nint base = 16;\nif (keyByte.length % base != 0) {\nint groups = keyByte.length / base + 1;\nbyte[] temp = new byte [groups * base ];\nArrays.fill(temp, (byte) 0);\nSystem.arraycopy(keyByte, 0, temp, 0, keyByte.length);\nkeyByte = temp;\n}\nSecretKeySpec secretKeySpec = new SecretKeySpec(keyByte,AES);\nCipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\ncipher.init(Cipher.DECRYPT_MODE,secretKeySpec,new IvParameterSpec(decoder.decode(AES_IV)));\nbyte[] base64 = decoder.decode(content);\nbyte[] result = cipher.doFinal(base64);\nreturn new String(result, Charset.forName(ENCODE));\n}\n/**\n* Rsa生成公钥，密钥\n* @return 返回公钥，密钥字符串数组 0–密钥 1–公钥\n* @throws NoSuchAlgorithmException 异常信息\n*/\npublic static String[] RsaGenera() throws NoSuchAlgorithmException {\n// 1.初始化发送方密钥\nKeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(“RSA”);\nkeyPairGenerator.initialize(512);\nKeyPair keyPair = keyPairGenerator.generateKeyPair();\nRSAPublicKey rsaPublicKey = (RSAPublicKey) keyPair.getPublic();\nRSAPrivateKey rsaPrivateKey = (RSAPrivateKey) keyPair.getPrivate();\nString[] results = new String [2 ];\nresults [0 ] = Base64.getEncoder().encodeToString(rsaPrivateKey.getEncoded());\nresults [1 ] = Base64.getEncoder().encodeToString(rsaPublicKey.getEncoded());\nreturn results;\n}\n/**\n* Rsa私钥加密\n* @param privateKey 私钥\n* @param content 明文\n* @return 返回密文\n* @throws Exception 异常\n*/\npublic static String RsaPrivateEncrypt(String privateKey,String content) throws Exception {\nPKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(Base64.getDecoder().decode(privateKey));\nKeyFactory keyFactory = KeyFactory.getInstance(“RSA”);\nPrivateKey privateKey1 = keyFactory.generatePrivate(pkcs8EncodedKeySpec);\nCipher cipher = Cipher.getInstance(“RSA”);\ncipher.init(Cipher.ENCRYPT_MODE, privateKey1);\nbyte[] result = cipher.doFinal(content.getBytes(ENCODE));\n//System.out.println(“私钥加密、公钥解密 ---- 加密:” + Arrays.toString(result));\nreturn Base64.getEncoder().encodeToString(result);\n}\n/**\n* Rsa公钥解密\n* @param publicKey 公钥\n* @param content 密文\n* @return 明文\n* @throws Exception 异常\n*/\npublic static String RsaPublicUnEncrypt(String publicKey,String content) throws Exception{\nX509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(Base64.getDecoder().decode(publicKey));\nKeyFactory keyFactory = KeyFactory.getInstance(“RSA”);\nPublicKey publicKey1 = keyFactory.generatePublic(x509EncodedKeySpec);\nCipher cipher = Cipher.getInstance(“RSA”);\ncipher.init(Cipher.DECRYPT_MODE, publicKey1);\nbyte[] result = cipher.doFinal(Base64.getDecoder().decode(content));\n//System.out.println(“私钥加密、公钥解密 ---- 解密:” + Base64.getEncoder().encodeToString(result));\nreturn Base64.getEncoder().encodeToString(result);\n}\n/**\n* Rsa公钥加密\n* @param publicKey 公钥\n* @param content 明文\n* @return 密文\n* @throws Exception 异常\n*/\npublic static String RsaPublicEncrypt(String publicKey,String content) throws Exception{\nX509EncodedKeySpec x509EncodedKeySpec2 = new X509EncodedKeySpec(Base64.getDecoder().decode(publicKey));\nKeyFactory keyFactory = KeyFactory.getInstance(“RSA”);\nPublicKey publicKey1 = keyFactory.generatePublic(x509EncodedKeySpec2);\nCipher cipher = Cipher.getInstance(“RSA”);\ncipher.init(Cipher.ENCRYPT_MODE, publicKey1);\nbyte[] result = cipher.doFinal(content.getBytes(ENCODE));\n//System.out.println(&quot;公钥加密、私钥解密 ---- 加密: &quot;+Base64.getEncoder().encodeToString(result2));\nreturn Base64.getEncoder().encodeToString(result);\n}\n/**\n* Rsa私钥解密\n* @param privateKey 私钥\n* @param content 密文\n* @return 解密后明文\n* @throws Exception 异常\n*/\npublic static String RsaPrivateUnEncrypt(String privateKey,String content) throws Exception{\nPKCS8EncodedKeySpec pkcs8EncodedKeySpec5 = new PKCS8EncodedKeySpec(Base64.getDecoder().decode(privateKey));\nKeyFactory keyFactory = KeyFactory.getInstance(“RSA”);\nPrivateKey privateKey1 = keyFactory.generatePrivate(pkcs8EncodedKeySpec5);\nCipher cipher = Cipher.getInstance(“RSA”);\ncipher.init(Cipher.DECRYPT_MODE, privateKey1);\nbyte[] result = cipher.doFinal(Base64.getDecoder().decode(content));\n//System.out.println(“公钥加密、私钥解密 ---- 解密:” + new String(result));\nreturn new String(result);\n}\npublic static void main(String[] args) throws Exception {\nString[] keys = RsaGenera();\nString aes_key = RsaPublicEncrypt(keys [1 ],AES_KEY);\nString aes_iv = RsaPublicEncrypt(keys [1 ],AES_IV);\nString AES_KEY = RsaPrivateUnEncrypt(keys [0 ],aes_key);\nString AES_IV = RsaPrivateUnEncrypt(keys [0 ],aes_iv);\nString m = AESEncryptEncode(“今天打老虎”,AES_IV,AES_KEY);\nSystem.out.println(&quot;AES对称加密： &quot;+m);\nSystem.out.println(“AES对称解密：”+AESDecodeDecrypt(m,AES_IV,AES_KEY));\n}\n}\n\n","tags":["加密"]},{"title":"Docker安装MySQL并使用","url":"/article/LinuxServer-docker-2-Docker%E5%AE%89%E8%A3%85mysql%E5%B9%B6%E4%BD%BF%E7%94%A8/","content":"1.拉取镜像\ndocker pull mysql:latest\n运行容器\ndocker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql\n3、进入容器\nsudo docker exec -it mysql-test /bin/bash\n4、登陆容器内数据库\nmysql -u root -p 设置的密码\n5.然后外部主机安装mysql客户端\n安装mysql客户端命令：\nsudo yum install mysql --nogpgcheckinstall mysql -ymysql -h 127.0.0.1 -P 3306 -u root -p\n然后就可以使用了。\n","tags":["Docker"]},{"title":"Vue入门","url":"/article/ViewFramework-Vue-1-Vue%E5%85%A5%E9%97%A8/","content":"","tags":["Vue"]},{"title":"5.构造方法,示例方法,类方法","url":"/article/JavaPrograming-JavaBase-5-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%8C%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%8Cstatic/","content":"1.Java中的方法\n在Java中有三种类型的方法：构造方法，实例方法和类方法\n1.2.构造方法\n如果我们要搞清楚构造方法为什么存在？那么首先我们得搞清楚构造方法的一切，不是吗？\n如果你要打败一个人，首先不是锻炼自己，而是了解对手，知己知彼，百战不殆。\nclass Computer&#123;    /**     * 构造方法     */    public Computer()&#123;    &#125;&#125;\n首先我们来看一下构造方法的特点：\n\n构造方法没有类型，这就意味着它不能返回值\n构造方法的名字必须与它所在的类的名字完全相同，这间接说明它和它的类是绑定的关系\n一个类中必须存在构造方法，如果没声明，编译器会自动的添加一个空的构造方法，\n这更加说明了它和类的绑定关系\n构造方法只能通过new调用\n\n可以总结出：构造方法是类中一种特殊的方法，当创建实例化一个对象时需要用它的构造方法，\n可以间接的得出构造方法是创建一个实例对象时一定要用的用来获取内存空间的方法。\n1.2.实例方法\nclass Computer&#123;    int add(int x,int y) &#123;        return x+y;    &#125;&#125;\n有返回类型，可以通过实例对象引用，它可以操作类变量，简单来说实例方法在类实例化为对象后才能使用。\n示例：\npublic class ObjectStudy &#123;    public static void main(String args[])&#123;        //通过调用构造方法将类Computer实例化        Computer com = new Computer();        int m = 100;        int n = 200;        //通过对象调用实例方法        int result = com.add(m,n);        result = com.add(120+m,n*10+8);        System.out.println(result);    &#125;&#125;class Computer&#123;    /**     * 构造方法     */    public Computer()&#123;    &#125;    int add(int x,int y) &#123;        return x+y;    &#125;&#125;\n1.3.类方法/静态方法\n类方法是用static修饰的实例方法，也叫静态方法。\nclass Computer &#123;    /**     * 类方法     * @param x     * @param y     * @return     */    public static int mul(int x,int y)&#123;        return x*y;    &#125;&#125;\n静态方法只初始化一次，它的作用是可以直接通过类名直接引用类方法，类方法只能操作类变量，\n类方法可以通过类名直接使用。\n示例：\npublic class ObjectStudy &#123;    public static void main(String args[])&#123;        int mulRes = Computer.mul(3,4);    &#125;&#125;class Computer&#123;     /**     * 类方法     * @param x     * @param y     * @return     */    public static int mul(int x,int y)&#123;        return x*y;    &#125;&#125;\n1.4.static关键字\n由关键字static修饰的变量，方法，代码块，\n类称之为静态变量，静态方法，静态代码块，静态类。\nstatic属性属于类级别的，即由该类创建的所有实例对象共享同一个static属性。\n对于静态属性， 我们可以通过两种方式访问：\n\n直接通过类名.属性来使用\n通过对象名.属性来使用\nstatic方法只能访问static变量，非static方法可以访问static变量。\n\nstatic变量和普通成员变量的区别：\n\n\n不管有多少对象，static变量只有一份。对于每个对象操作的static变量都是同一个，\n但是普通的成员变量随着对象的建立，它也会被建立。\nstatic变量在对象建立之前就被分配内存空间并被初始化了（第一次使用类的时候）\n\n\nstatic变量是属于整个类的，也称之为类变量，而非静态变量是属于实例对象的，因此也称之为实例变量。\n\n\n静态代码块无法通过类名调用，所以static代码块当类被第一次使用时(首次被加载)会被执行且只被执行一次，\n主要作用是实现static属性的初始化。\n\n\nstatic内部类：属于整个外部类，而不是属于外部类的每个对象，\n它不能访问外部类的非static成员但可以访问外部类的static成员。\n\n\n","tags":["Java基础"]},{"title":"6.参数传值","url":"/article/JavaPrograming-JavaBase-6-%E5%8F%82%E6%95%B0%E4%BC%A0%E5%80%BC%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88/","content":"1.参数传值\n参数传值是什么意思？ 顾明思意，就是把一个变量的数值传给另一个变量。\n比如：\nint x = 10;int y = x;y = 20;\n上面的操作是，首先给x赋值，然后将x的值赋给变量y。最后x=10,y=20;\n那其中到底是怎么回事呢？\n其实在这里的传值（即赋值）所用的值不是x的本值，而是它的拷贝(copy)。\n所以不会影响x本来的值。参数y得到的值相当于生活中的”原件“”的“复印件“。\n上面的操作其实就是给y开辟了新的内存空间然后将x的值复制到y的内存空间里，所以对y的操作不会对x有影响，\n这就是参数的传值原理。\n同理，引用类型的参数的传的值是地址,地址的数值也是拷贝来的。但是对地址指向的内存空间并没有拷贝。\n所以对这个引用类型进行操作会改变其属性，例如：\npublic class Main &#123;        public static void main(String[] args) &#123;        Person p = new Person();        p.age = 10;        System.out.println(p.age);        Person m = p;        m.age = 100;        System.out.println(&quot;m.age: &quot;+m.age);        System.out.println(&quot;p.age: &quot;+p.age);    &#125;&#125;class Person&#123;    public int age;&#125;\n运行结果：\np.age: 10m.age: 100p.age: 100Process finished with exit code 0\n因为引用类型的值是一个地址，它指向的是同一个内存空间,所以在对它的字段进行修改时，\n实际上是修改了一处位置。\n2.对象的组合\n首先我们知道一个类可以把某个对象引用变量作为自己的一个成员变量，若用这样的类创建一个对象，\n那么这个对象中就会包含其他的对象，也就是说这个的对象将其他的对象作为自己的组成部分。\n这就是类与类的 Has-A.\n如果对象a组合了对象b，就相当于，对象a包含了对象b，对象b是对象a的有一个属性，\n那么对象a就可以委托对象b调用其方法，就是对象a以组合的方式复用对象b的方法。\n虽然听起来有些云山雾绕的感觉，但是，\n简单来说：就是通过组合的方式来复用其他类的定义达到复用其他对象的功能的方法。\n2.1 对象组合的示例\npublic class ObjectCombination &#123;    public static void main(String[] args) &#123;        TV haierTV = new TV();        haierTV.setChannel(5);        System.out.println(&quot;haierTV的频道是： 频道&quot;+haierTV.getChannel());        //新建一个Family对象        Family zhangSanFamily = new Family();        //将之前新建的TV对象组合进Family        zhangSanFamily.buyTV(haierTV);        System.out.println(&quot;张三Family开始看电视节目:&quot;);        zhangSanFamily.seeTV();//通过Family对象使用TV对象的方法        int m = 2;        System.out.println(&quot;张三Family将电视更换到&quot;+m+&quot;频道&quot;);        zhangSanFamily.remoteControl(m);        System.out.println(&quot;haierTV的频道是: 频道&quot;+haierTV.getChannel());        System.out.println(&quot;张三Family在看电视节目&quot;);        zhangSanFamily.seeTV();    &#125;&#125;/** * Family类，其中属性是引用类型TV */class Family &#123;    TV homeTV;    void buyTV(TV tv) &#123;        homeTV = tv;    &#125;    void remoteControl(int m) &#123;        homeTV.setChannel(m);    &#125;    void seeTV() &#123;        homeTV.showProgram();    &#125;&#125;/** * TV类，里面的属性是基本类型 */class TV &#123;    int channel;    void setChannel(int m) &#123;        if(m&gt;=1) &#123;            channel = m;        &#125;    &#125;    int getChannel() &#123;        return channel;    &#125;    void showProgram() &#123;        switch(channel) &#123;            case 1 : System.out.println(&quot;综合频道&quot;);                break;            case 2 : System.out.println(&quot;经济频道&quot;);                break;            case 3 : System.out.println(&quot;文艺频道&quot;);                break;            case 4 : System.out.println(&quot;国际频道&quot;);                break;            case 5 : System.out.println(&quot;体育频道&quot;);                break;            default : System.out.println(&quot;不能收看&quot;+channel+&quot;频道&quot;);        &#125;    &#125;&#125;\n执行结果：\nhaierTV的频道是： 频道5张三Family开始看电视节目:体育频道张三Family将电视更换到2频道haierTV的频道是: 频道2张三Family在看电视节目经济频道Process finished with exit code 0\n这个例子很好的说明了对象的组合复用。\n代码地址：\nhttps://gitee.com/yan-jiadou/study/tree/master/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/src/main/java/exa06\n","tags":["Java基础"]},{"title":"7.方法重载","url":"/article/JavaPrograming-JavaBase-7-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%EF%BC%8C%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%EF%BC%8Cthis%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8Csuper%E5%85%B3%E9%94%AE%E5%AD%97/","content":"1.方法重载\n1.1. 什么是方法重载？\n在Java程序中，当一个类的定义中，两个方法具有相同的名称且参数不同，我们就称这两个方法重载了。\npublic class Person &#123;        int add(int x,int y)&#123;        return x+y;    &#125;        int add(int x)&#123;        System.out.println(&quot;我会加法&quot;);        return x+1;    &#125;&#125;\n如上所示，在Person类中，有两个名为add的方法， 这两个方法就重载了。\n1.2. 为什么会出现这样的情况？\n在java中我们允许多个方法有相同的名字，是因为：\n为了增强我们项目代码的稳定性，我们可能对一种业务有多种不同入参的组合，\n当我们需要对这一种情况进行应对，这时方法重载起到了作用，\n方法重载让我们在不改变业务含义的情况下进行不同的处理。\n注意：重载方法的参数必须不同（就像我们人一样，名字可以相同，但长相一定不同），\n参数不同是指：参数的个数不同，参数的个数相同的情况下，这些参数至少有一个的参数类型不同。\n注意：方法的返回类型和参数的名称不参与比较。（不影响重载）\n2.方法重写\n2.1.什么是方法重写\n在Java程序中，有两个类Person,Student，其中Student是Person的子类，\n如果这两个类有一个相同的方法，我们就认为Student重写了Person的这个方法。\n这就是方法重写。（也称方法覆盖）\n总结：方法重写出现在父类和子类之间，子类可以覆盖父类的方法，这就叫重写。\n例子：\npublic class Person &#123;    int add(int x,int y)&#123;        return x+y;    &#125;&#125;class Student extends Person&#123;    /**     * 子类Student重写父类Person的方法：     * int add(int x,int y)     * @param x     * @param y     * @return     */    int add(int x,int y)&#123;        return x+y+y;    &#125;&#125;\n2.2.为什么会出现这样的情况？\n在编写代码的过程种，如果一个子类继承了父类的方法后，父类的方法不能应对子类的所有需求，\n子类也可以对这个方法进行重写，使之满足自己的业务需求。\n3.重载和重写的差别\n\n\n\n类型\n位置不同\n作用不同\n\n\n\n\n重载\n同一个类中\n在一个类中提供一种业务处理的多种实现实现多态\n\n\n重写\n父子类之间\n子类可以选择覆盖父类的同一个方法的实现来达到自己的目的\n\n\n\n4.this关键字\n我们知道类中有局部变量和成员变量两个类型的变量，\n如果在一个类的一个方法中有着一个和方法外完全相同的变量。\n比如：\npublic class A&#123;  int x = 10;  void f()&#123;    int x = 5;    x = x+5;    System.out.println(x);  &#125;&#125;\n我们知道它输出的是10（局部优先），但我们是不是就不能在f方法中用外面的x？当然不是，this在这里的作用就出来了\npublic class A&#123;  int x = 10;  void f()&#123;    int x = 5;    x = this.x+5;    System.out.println(x);  &#125;&#125;\n这样我们输出的x就是15了\n方法的调用也是如此\n其实this是实例对象内部指代自身的引用，它可以解决成员变量和局部变量的同名问题，\nthis可以调用成员变量/方法，无法调用局部变量，在普通方法中可以省略this。\n但一般不建议省略，因为this相当于成员变量的标志，有助于代码的可读性。\n注意：静态方法中不允许使用this,this引用的是这个对象本身\n5.super关键字\nsuper关键字代表对当前实例对象的父类的实例对象的引用,\nsuper可以直接调用父类的成员变量（非private的）super也可以调用父类的成员方法（非private的），\nsuper可以调用直接父类的构造方法，但只限在子类的构造方法中使用且必须是第一条语句。\n例如：\nclass Person1 &#123;    int add(int x,int y)&#123;        return x+y;    &#125;&#125;class Student1 extends Person1&#123;    /**     * 子类Student重写父类Person的方法：     * int add(int x,int y)     * @param x     * @param y     * @return     */    int add(int x,int y)&#123;        //通过super调用父类的add方法        super.add(1,2);        return x+y+y;    &#125;&#125;\n代码地址：\nhttps://gitee.com/yan-jiadou/study/tree/master/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/src/main/java/exa07\n","tags":["Java基础"]},{"title":"8.包的概念,import关键字","url":"/article/JavaPrograming-JavaBase-8-%E5%8C%85%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8Cimport%E5%85%B3%E9%94%AE%E5%AD%97/","content":"1.什么是包？（package）\n包是java语言管理类很有效的一个机制。\n当两个源文件里包含名字相同的类，我们怎样才能区分这样的类，这就需要包了，\n包名的目的就是有效的区分名字相同的类，当不同的源文件中的两个类名字相同时，\n它们就可以通过隶属不同的包来相互区分。所以我认为包的主要作用是实现对类的分类。\n包有助于我们项目的结构化，规范化。\n因为如果一个复杂的项目的源代码文件都放在一个文件夹下，可控性会变得非常差。\n2.如何使用包（import关键字）\n下面我使用IDEA演示：\n首先写两个名字相同内容不同的类：\npublic class People&#123;    void f()&#123;        System.out.println(&quot;我是bao1的people&quot;);    &#125;&#125;public class People&#123;    void f()&#123;        System.out.println(&quot;我是bao2的people&quot;);    &#125;&#125;\n我们知道这两个类不能放在同一个包中（否则编译器会报错）\n下面我们分别创建两个包，名字分别为bao1,bao2并且把这两个类分别放在两个包中：\n于是问题又来啦，我们该如何使用它们呢？\n3.import关键字\n这里就出现了一个import语句，这个语句可以让一个包中的类中可以使用另一个包中的类，怎么操作呢？下面继续：\n我们在bao1中创建一个主类，在这个类中我们要对这两个名字相同的类操作的代码如下：\npublic class Test &#123;    public static void main(String[] args) &#123;        Base.exa08.bao1.People speak = new Base.exa08.bao1.People();        speak.f();        Base.exa08.bao2.People speaks = new Base.exa08.bao2.People();        speaks.f();    &#125;&#125;\n结果如下：\n我是bao1的people我是bao2的peopleProcess finished with exit code 0\n对于import的用法是：\nimport 包路径.要引用的类;\n如果要引用某个包中的全部类，可以用*来表示， *  代表全部。\n","tags":["Java基础"]},{"title":"9.四种访问权限","url":"/article/JavaPrograming-JavaBase-9-%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/","content":"1.访问权限从何而来？\n我们已经知道当一个类创建了一个对象后，该对象可以通过  .  操作符访问自己的变量，使用其中的方法。\n实际上在Java中我们通过对象操作的变量和使用类中的方法是有限制的，\n我们并不是能随心所欲的访问一个对象的所有变量或所有方法的。\n其限制的主要原因是在声明变量和方法时的修饰符，访问权限修饰符大概分为四个：\n私有（private）,友好（无修饰符）,保护(protected),公有(public)\n1.1.私有(private)\n1.1.1私有变量和私有方法\n在定义的类的时候在声明变量/方法前加上private修饰符，表示声明的是私有变量或方法，\n其访问权限是只能在自己类中被访问。当在另外一个类中用一个类创建了一个该类的对象后，\n该对象不能访问自己的私有变量，调用类中的私有方法。\n想要对数据的操作只能在本类中处理，就可以使用private这个关键字。\n1.1.2 例子\npublic class PersonPrivate &#123;    private int x;    private int getX() &#123;        return x;    &#125;    private void setX(int x) &#123;        this.x = x;    &#125;&#125;\n下面尝试创建PersonPrivate对象并调用它的方法：\n\n我们可以看到，在另一个类中创建PersonPrivate对象后，无法通过该对象调用其中定义的private变量或方法。\n1.2.公有(public)\n1.2.1 公有变量和方法\n用public修饰的成员变量和方法我们称之为公有变量和方法。\n在任何一个类中用另一个类创建了一个对象，可以通过该对象访问其中的共有变量和方法。\n1.2.2 例子\npublic class PersonPublic &#123;    public int x;    public int getX() &#123;        return x;    &#125;    public void setX(int x) &#123;        this.x = x;    &#125;&#125;\n\n我们可以看到，在另一个类中创建该类的对象后，可以直接访问该类定义的public方法和变量。\n1.3.友好(无修饰符)\n1.3.1 友好变量和方法\n不用private，public，protected修饰符修饰的成员变量和方法被称为友好变量和友好方法。\n这种变量和方法的可见性只允许同一包的其他类创建对象后可以用对象进行访问。\n在同一包中的前提下 在任何一个类中用一个类创建了一个对象，该对象能访问该类中的友好变量和方法，\n否则不可见。\npublic class PersonFriend &#123;        int x;    void set(int x)&#123;        this.x = x;    &#125;    int getX()&#123;        return x;    &#125;    &#125;\n当在同一个包里的时候，可见\n\n下面再另一个包中创建PersonFriend对象并试图访问：\n\n可以发现，无法进行访问。\n1.4.受保护(protected)\n1.4.1 受保护的变量和方法\n用protected修饰的成员变量和方法被称为受保护的成员变量和方法。\n当在另外一个类中用一个类创建了一个对象后，如果两个类在同一包中，\n那么该对象可以访问该类的protected变量和方法，否则不可见。\n大家可能会有一个疑惑：友好和受保护的用法好像相同，其实他们还是有差别的\n\n子类和父类在同一包中的继承性：除了private成员变量和方法，其他的都继承了。\n\npublic class PersonExtend &#123;    public int x;    private int y;    int z;    protected int n;&#125;public class PersonSon extends PersonExtend&#123;    public int name;&#125;\n\n可以看到，除了私有变量y，其他的都继承了。\n\n子类和父类不在同一包中：子类只继承父类的protected和public成员，友好成员不继承了。\n（这里protected和友好类的差别出现了）\n\n这里将父类和子类放在不同的包中：\npackage exa09;public class PersonExtend &#123;    public int x;    private int y;    int z;    protected int n;&#125;\npackage exa08;import exa09.PersonExtend;public class PersonSon extends PersonExtend &#123;    public int name;&#125;\n\n这里可以看到，这时只继承了protected和public的变量。\n2.四种修饰符的差异\n类声明时，如果在关键字class前加上public关键字，我们称为public类，不加则是友好类。\n我们可以在任何另外一个类中使用public类创建对象，但要在另一个类中用友好类创建对象时，\n必须要保证它们在同一包中。\n下面是访问修饰符修饰的变量或方法在不同范围的权限列表：\n\n\n\n关系\npublic\nprotected\ndefault\nprivate\n\n\n\n\n同一个类\n允许\n允许\n允许\n允许\n\n\n同一个包\n允许\n允许\n允许\n不允许\n\n\n父子类\n允许\n允许\n不允许\n不允许\n\n\n不同包\n允许\n不允许\n不允许\n不允许\n\n\n\n代码地址：\nhttps://gitee.com/yan-jiadou/study/tree/master/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/src/main/java/exa09\n","tags":["Java基础"]},{"title":"10.JRE扩展和Jar文件以及文档生成器","url":"/article/JavaPrograming-JavaBase-10-JRE%E6%89%A9%E5%B1%95%E5%92%8Cjar%E6%96%87%E4%BB%B6%E4%BB%A5%E5%8F%8A%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90%E5%99%A8/","content":"1.JRE扩展和jar文件\n很显然java运行环境提供的类库并不能满足我们的全部需求，因此它必须可扩展，路径为\\jre\\lib\\ext  我们只要将自己写的类打包为jar格式文件放在ext中，我们就可以用import语句使用。\n演示链接：https://www.cnblogs.com/blog5277/p/5920560.html\n2.文档生成器\nJDK提供的javadoc.exe可以制作源文件类结构的html文档，我们可以通过查看这些文档了解文件中类的组成结构。\n演示链接：https://www.cnblogs.com/toutou/p/javadoc.html\n","tags":["Java基础"]},{"title":"11.父类和子类","url":"/article/JavaPrograming-JavaBase-11-%E7%88%B6%E7%B1%BB%E5%92%8C%E5%AD%90%E7%B1%BB-Object%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","content":"1.如何定义父类和子类？\n简单来说，当存在一个类Father，当我们使用关键字extends,class写出下面语句：\nclass Son extends Father{.....}\n我们就定义了Son和Father之间的父子关系。\n上面定义的是一个名为Son的新类，和直接用class Son{}不同，它使用extends继承了Father类。\n类Son和Father的关系是: Son是Father的子类，Father是Son的父类。\n2.子类继承了父类的什么？\n子类继承了父类一部分的变量和方法。\n我们知道类的两个重要的成员：变量和方法。\n父类有自己的变量和方法，子类继承了父类的一些成员，所以子类不仅拥有自己的变量和方法，而且子类也可以拥有父类定义的一些变量和方法。\n子类可以直接使用它继承的父类中的成员和方法。\n我们都知道类是通过它的构造方法来为自己分配变量内存空间的， 由于子类继承了父类，\n所以子类的构造方法默认会先调用父类的构造方法，然后再用自己的构造法方法。（但这并不是继承，即子类不继承父类的构造方法）\n继承很好的解决了代码复用以及功能纵向扩展。\n例子：\npublic class Father{    int money = 1000000;    void fight(){    System.out.println(\"I will kill you\")    }}class Son extends Father{     int weight = 10;}\n在这一段代码中，Son继承了Father的money变量和fight方法。相当于Son的实际定义是：\nclass Son{int money = 1000000;int weight=10; void fight(){    System.out.println(\"I will kill you\")  } }\n3.继承的限制\n子类并不能继承父类的所有变量和方法，它是有限制的。\n\n子类和父类在同一包中的继承性：除了private成员变量和方法，其他public,protected,无修饰符的变量和方法都继承了。\n子类和父类不在同一包中：子类只继承父类的protected和public成员。（这里protected和友好类的差别出现了）\n\n4.类的树形结构\nObject是所有的类的祖先类，系统默认。\n类似于：\ngraph TB\nObject--&gt; Son1\nObject--&gt; Son2\nSon1--&gt; grandSon1\nSon1--&gt; grandSon2\nSon2--&gt; grandSon3\nSon2--&gt; grandSon4\n其中Object是系统默认的祖先类，即它是任何一个类的祖先类,祖先类和孙子类之间也存在继承关系。\n5.Object类中的方法（先了解需要了解的）\n5.1 protected Object clone()\n5.1.1 方法介绍\n创建并返回此对象的克隆副本。（副本和本体是两个独立的对象）\n注意：这个方法是用protected修饰符修饰的。\n用protected修饰的成员变量和方法被称为受保护的成员变量和方法。\n当在另外一个类中用一个类创建了一个对象后，\n如果两个类在同一包中，那么该对象可以访问该类的protected变量和方法，否则不可见。\n所以，当我们在自己的包中新建一个类并使用Object创建对象的时候，我们是不能直接使用其clone方法的。\n5.1.2 使用教程\n既然我们知道Object是所有类的父类，那么我们就可以通过super关键字来调用啊。\npublic class ObjectStudy {    public static void main(String[] args) throws CloneNotSupportedException {        ObjectStudy objectStudy = new ObjectStudy();        System.out.println(objectStudy.Test().toString());    }    public Object Test() throws CloneNotSupportedException {        return super.clone();    }}\n当我们运行上面的示例时，我们看到程序运行抛出了一个异常：\nCloneNotSupportedException\n通过查看源码我发现了下面这段话：\nif the object’s class does not support the Cloneable interface. Subclasses that override the clone method can also throw this exception to indicate that an instance cannot be cloned\n翻译过来就是：\n如果对象的类不支持Cloneable接口。重写克隆方法的子类也可以抛出此异常，以表明无法克隆实例\n通过这里我们得知，想要实现对一个对象的克隆，其类定义需要实现Cloneable接口。\npublic class ObjectStudy implements Cloneable{    public static void main(String[] args) throws CloneNotSupportedException {        ObjectStudy objectStudy = new ObjectStudy();        System.out.println(objectStudy.Test().toString());    }    public Object Test() throws CloneNotSupportedException {        return super.clone();    }}\n运行结果：\nBase.exa11.ObjectCloneStudy@677327b6Process finished with exit code 0\n再运行的时候，发现成功了。\n5.2 public boolean equals(Object obj)\n5.2.1 方法介绍\n通过名称我们可以知道，这个方法用来判断对象本身和另一个对象是否相等。\n通过查看方法体:\npublic boolean equals(Object obj) {    return (this == obj);}\n我们知道在Object中，此方法在Object的默认实现是通过比较对象引用的值来判断两个对象是否相等。\n5.2.2 使用教程\npublic class ObjectEqualsStudy {    public static void main(String[] args) {        Object ojb = new Object();        Object ojb2 = new Object();        System.out.println(\"ojb: \"+ojb);        System.out.println(\"ojb2: \" +ojb2);        System.out.println(ojb.equals(ojb2));        System.out.println(ojb.equals(ojb));    }}\n运行结果：\nojb: java.lang.Object@677327b6ojb2: java.lang.Object@14ae5a5falsetrueProcess finished with exit code 0\n5.3  int hashCode()\n5.3.1 方法介绍\n这个方法的作用就是返回对象的唯一哈希码值（理论上）\n5.3.2 使用教程\npublic class ObjectHashCodeStudy {    public static void main(String[] args) {        Object obj = new Object();        System.out.println(obj.hashCode());    }}\n运行结果：\n1735600054Process finished with exit code 0\n5.4 String toString()\n5.4.1 方法介绍\n返回此对象的字符串表示\npublic String toString() {    //这个Integer.toHexString()是十进制转为无符号的16进制字符串表示    return getClass().getName() + \"@\" + Integer.toHexString(hashCode());}\n5.4.2 使用教程\npublic class ObjectToStringStudy {    public static void main(String[] args) {        Object o = new Object();        System.out.println(o.toString());    }}\n运行结果：\njava.lang.Object@677327b6Process finished with exit code 0\n代码地址：\nJava基础学习/src/main/java/exa11 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java基础"]},{"title":"12.子类对象的特性","url":"/article/JavaPrograming-JavaBase-12-%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%8Cinstanceof%EF%BC%8Csuper-this/","content":"1.子类对象的特点\n当使用子类的构造方法创建一个子类的对象时，不仅子类中的声明的成员变量被分配了内存，\n而且父类的成员变量也都分配了内存空间。\n但是，子类只能访问它继承的变量和方法。\n那为什么要将未继承的变量分配内存呢？相信大家会有这个疑问。\n因为，子类也许有一部分方法从父类继承，而这部分方法却可以操作未继承的变量。\n所以我们也需要为其分配内存空间防止出错。\n实例：\npublic class Human &#123;    public static void main(String args[])&#123;        //这条语句的执行意味着，money，leg，height，        //action都被分配了空间        Man you = new Man();        you.action();//这条语句的执行说明了子类可以通过继承的方法来操作没继承来的变量        System.out.println(you.getLeg());    &#125;&#125;class People&#123;    private int leg = 2;    int money;    void action()&#123;        leg = 5;        System.out.println(&quot;I am a man&quot;);    &#125;    public int getLeg()&#123;        return leg;    &#125;&#125;class Man extends People&#123;    int height;&#125;\n运行结果：\nI am a man5Process finished with exit code 0\n2.instanceof运算符（它实际上就是一个判断符）\ninstanceof运算符是java独有的双目运算符，其左面的操作元是对象，右面的操作元是类，\n当左面的操作元是右面的类或其子类创建的对象时,instanceof的运算结果是true,否则是false.\n实例：\npublic class InstanceofStudy &#123;    public static void main(String[] args) &#123;        /*这条语句的执行意味着，money，leg，height，action都被分配了空间*/        Man1 you = new Man1();        if(you instanceof Man1)&#123;            System.out.println(&quot;I am a man&quot;);        &#125;        System.out.println(you instanceof People1);    &#125;&#125;class People1&#123;    private int leg = 2;    int money;    void action()&#123;        leg = 5;        System.out.println(&quot;I am a man&quot;);    &#125;&#125;class Man1 extends People1&#123;    int height;&#125;\n运行结果：\nI am a mantrueProcess finished with exit code 0\n3.成员变量的隐藏\n当所声明的成员变量的名字和从父类继承来的成员变量的名字相同（声明的类型可以不同），在这种情况下，\n子类就会隐藏所继承的父类的成员变量（这并不意味着被隐藏的成员不能用了，我们仍然可以用super关键字来使用）\n子类隐藏继承的成员变量的特点如下：\n\n子类对象以及子类自己定义的方法操作与父类同名的成员变量，是指子类重新声明的这个成员变量。\n子类对象仍然可以调用从父类的继承的方法操作被子类隐藏的成员变量，也就是说，子类继承的方法所操作的成员变量一定是被子类继承或隐藏的成员变量。\n\npublic class Human3 &#123;    public static void main(String[] args) &#123;        /*这条语句的执行意味着，money，leg，height，         action都被分配了空间*/        Man3 man3 = new Man3();        //这条语句的执行说明了子类可以通过继承的方法来操作没继承来的变量或隐藏的成员变量        man3.action();        //People里的变量money被隐藏        System.out.println(man3.money);    &#125;&#125;class People3&#123;    private int leg = 2;    int money;    void action()&#123;        leg = 5;        money = 10;        System.out.println(&quot;I am a man&quot;);    &#125;&#125;class Man3 extends People3&#123;    int height;    int money = 5;&#125;\n运行结果：\nI am a man5Process finished with exit code 0\n4.方法重写（method overriding）\n子类可以通过重写可以隐藏已继承的父类的同名方法。\n如果子类可以继承父类的某个方法，那么就有权利重写这个方法，子类通过方法的重写建立一套不同于父类的业务逻辑。\npublic class Human4 &#123;    public static void main(String[] args) &#123;        Man4 you = new Man4();        you.action();        System.out.println(you.money);    &#125;&#125;class People4&#123;    private int leg = 2;    int money;    void action()&#123;        leg = 5;        money = 10;        System.out.println(&quot;I am a People&quot;);    &#125;&#125;class Man4 extends People4&#123;    int height;    int money = 5;    /**     * 重写从父类继承的方法     */    void action()&#123;        money = 15;        System.out.println(&quot;I am a Man&quot;);    &#125;&#125;\n运行结果：\nI am a Man15Process finished with exit code 0\n5.super关键字\n5.1用super操作父类的成员变量和方法\npublic class SuperStudy &#123;    public static void main(String[] args) &#123;        Man5 me = new Man5();        me.action();        System.out.println(me.money);    &#125;&#125;class People5&#123;    private int leg = 2;    int money;    void action()&#123;        leg = 5;        money = 100;        System.out.println(&quot;I am a people&quot;);    &#125;&#125;class Man5 extends People5&#123;    int height;    int money ;    void action()&#123;        super.action();        money = super.money;        System.out.println(&quot;I am a Man&quot;);    &#125;&#125;\n运行结果：\nI am a Man100Process finished with exit code 0\n5.2 使用super调用父类的构造方法\n当用子类的构造方法创建一个对象时，子类的构造方法总是先调用父类的某个构造方法，也就是说，\n如果子类的构造方法没有明显的指明使用父类的那个构造方法，子类就调用父类不带参数的构造方法。\n由于子类不继承父类的构造方法，\n所以，子类在其构造方法中需使用super来调用父类的构造方法，\n而且super必须是子类构造方法中的第一条语句，如果在子类的构造方法中没有写super语句，编译器会默认有。\npublic class SuperStudy &#123;    public static void main(String[] args) &#123;        Man5 me = new Man5();        me.action();        System.out.println(me.money);    &#125;&#125;class People5&#123;    private int leg = 2;    int money;    public People5()&#123;        money = 100;    &#125;    void action()&#123;        leg = 5;        money = 100;        System.out.println(&quot;I am a people&quot;);    &#125;&#125;class Man5 extends People5&#123;    int height;    int money ;    void action() &#123;        money = super.money;        System.out.println(&quot;I am a Man&quot;);    &#125;&#125;\n运行结果：\nI am a Man100Process finished with exit code 0\n6.final关键字\nfinal的意思是不可更改的。顾名思义，用此关键字修饰的类和变量或方法不可被更改。\n也就是说，用final修饰的任何东西都必须在声明是定义好。\n所以：final类不能被继承，final变量就是常量，final方法不可被覆盖，由于常量在运行期间不允许再发生变化，所以常量在声明是必须要给它值。\nJava基础学习/src/main/java/exa12 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java基础"]},{"title":"13.抽象类学习","url":"/article/JavaPrograming-JavaBase-13-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%AD%A6%E4%B9%A0-%E4%B8%8A%E8%BD%AC%E5%9E%8B%E6%A6%82%E5%BF%B5/","content":"1.什么是面向抽象编程\n所谓面向抽象编程，是指当设计某种重要的类时，不让该类面向具体的类，而是抽象的类，即所设计的类中的重要数据是抽象类声明的对象，\n而不是具体类声明的对象。\n抽象类只关心操作，并不关心这些操作的具体算法，这样就可以让设计者将更多的精力投入到整体的设计中，而无需关心具体的实现。\n面向抽象设计将程序设计的层次提高到系统整体设计的层次。 通过这样的设计，我们可以设计出低耦合，高扩展的系统。（现在了解即可）\n1.1 抽象类\n设计出面向抽象的程序，我们需要掌握抽象类和接口的概念。\n1.1.1 如何定义一个抽象类\n使用abstract关键字修饰类和方法即可。\n在抽象类里，我们除了可以定义不同的变量和方法外，还可以定义抽象方法，这样的方法不能有方法体，它的实现应该交由其子类完成。\n如下所示：\nabstract class Skills{    private int num;    protected int age;    public int num2;    static int num4 = 2200;    public Skills(){        num = 100;        age = 20;        num2 = 300;    }    public abstract void eat();    public abstract void say();    public void sayOne(){        System.out.println(\"I said: \"+num);    }}\n上面代码定义了一个抽象类，我们可以看到抽象类和普通类的差别并不大，就是多个一个修饰符，\n然后抽象类的能力更强（允许定义抽象方法）而已。\n1.1.2 如何使用抽象类\n因为抽象类可以定义的抽象的概念。\n所以我们的具体的实现类需要继承它，然后实现它的抽象方法即可。\nclass ChinesePeople extends Skills{    @Override    public void eat() {        System.out.println(\"can eat chili\");    }    @Override    public void say() {        System.out.println(\"can say chinese\");    }}\n1.1.3 展示示例\npublic class AbstractClassStudy {    public static void main(String[] args) {        Skills skills = new ChinesePeople();        skills.eat();        skills.say();        Skills skills1 = new EnglishPeople();        skills1.eat();        skills1.say();    }}abstract class Skills{    public abstract void eat();    public abstract void say();}class ChinesePeople extends Skills{    @Override    public void eat() {        System.out.println(\"can eat chili\");    }    @Override    public void say() {        System.out.println(\"can say chinese\");    }}class EnglishPeople extends Skills{    @Override    public void eat() {        System.out.println(\"can eat hamburger\");    }    @Override    public void say() {        System.out.println(\"can say english\");    }}\n运行结果：\ncan eat chilican say chinesecan eat hamburgercan say englishProcess finished with exit code 0\n2.对象向上转型\n当用子类创建一个实例对象，并把这个对象的引用赋给父类的声明变量，我们称此时得到的对象是子类对象的上转型对象。\n假设Animal类是Tiger类的父类，有：\nAnimal a;a = new Tiger();\n或\nAnimal a;Tiger b = new Tiger();a = b;\n这时称对象a是对象b的上转型对象。上转型对象的存在帮助我们避免使用非抽象类型的方法。\n对象和对象的上转型对象的操作权限如下图：\nObjectB是ObjectA的上转型对象\ngraph LR\n\nObjectB--&gt;hide_param\n\nObjectB--&gt;extend_param\n\nObjectB--&gt;extend_or_override_param\n\nObjectA--&gt;extend_param\n\nObjectA--&gt;new_param\n\nObjectA--&gt;extend_or_override_param\n\nObjectA--&gt;new_method\n大家自己可以写例子验证一下，通过这个上转型和非上转型对象的权限，我们可以操作我们想要操作的变量或方法，\n当然，也可以直接使用非上转型(通过super关键字在子类定义可以未被继承的变量)\n2.多态，封装，继承\n2.1 多态\n其实多态性并不难理解,其含义大概就是说同一种概念的事物可以有不同的描述。\n比如：\n\n重载：同一个类中可以写多个同名的方法。\n重写：子类可以重写从父类继承的方法，一种接口的多个实现，父类引用指向子类对象。\n\n2.2 封装\n封装也不难理解，就是我的变量只能我来操作，我的方法只有我能调用,其他类操作不了。\n比如：\n\nprivate关键字：private关键字可以将方法或属性封装在类中，避免其他类中对它们进行操作。\n私有静态内部类: 私有静态内部类只能拥有它的类调用\n友好类/友好静态内部类：友好类将自己封装在一个包中，只允许同包的类调用\n受保护的静态内部类：受保护的静态内部类将自己封装在一个包中，只允许同包的类调用或子类调用\n\n2.3 继承\n继承描述的就是子类可以继承父类一些属性而不用重复定义。\nextends关键字：子类继承父类以及祖先类的可继承的属性和方法。\n3.抽象类和抽象方法\n3.1用关键字abstract修饰的类称为抽象类\n例如：\nabstract class A{...}\n\n抽象类中既可以有抽象方法也可以有非抽象方法，而非抽象类中不能有抽象方法\n抽象类不能用new运算符创建对象。\n抽象类的一个非抽象子类必须重写父类的所有抽象方法，并给出方法体。\n抽象类的抽象子类可以重写父类的抽象方法，也可以继承。\n抽象类声明的对象可以做其子类的上转型对象，调用子类重写的方法。\n\n3.2 用关键字abstract修饰的方法称为抽象方法\n例如：\nabstract int mi(int x,int y);\n并且在抽象类中：\n\n对于抽象方法，只允许声明，不允许实现。\n不允许用final和abstract同时修饰一个方法或类。\n不允许用static修饰抽象方法\n\n代码地址：\nJava基础学习/src/main/java/exa13 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java基础"]},{"title":"15.内部类,匿名类","url":"/article/JavaPrograming-JavaBase-15-%E5%86%85%E9%83%A8%E7%B1%BB-%E5%8C%BF%E5%90%8D%E7%B1%BB/","content":"1.什么是内部类？\n1.1 内部类的定义\n《JAVA programming》里这样定义的：\n内部类（又叫嵌入类），是一种在其他类的内部定义的类。\n如下所示：\npublic class ShowInnerClass &#123;        private int data;    public void methodOne()&#123;            &#125;    /**     * InnerClass是ShowInnerClass的内部类     */    class InnerClass&#123;        public void method()&#123;            data++;            methodOne();        &#125;    &#125;    &#125;\nInnerClass类在ShowInnerClass类的内部定义，所以InnerClass是ShowInnerClass的内部类。\n1.2 内部类的特性\n内部类作为定义在类中的类，有着其一定的特殊性。\n内部类有下列特性：\n1.2.1 内部类有外部变量的直接访问权\n内部类可以引用包含它的外部类中的数据和方法，所以不必把外部类的引用传递给内部类的构造方法，\n基于这个原因，内部类可以使程序简单明了。\n如下面所示，内部类InnerClass可以直接访问外部类的私有变量和方法。\npublic class ShowInnerClass &#123;    private int data;    private int num;    private void methodOne()&#123;    &#125;    /**     * InnerClass是ShowInnerClass的内部类     */    class InnerClass&#123;        public void method()&#123;            data++;            methodOne();        &#125;    &#125;&#125;\n1.2.2 内部类的编译文件\n内部类只是用来支撑外部类的工作。编译后，他的名称形如“外部类名称$内部类名称.class”。\n例如，showInnerClass中内部类InnerClass,被编译为showInnerClass$$InnerClass.class。\n\n1.2.3 内部类的成员\n内部类可以声明为public,protected,private，其意义与用在类的其他成员上相同。\npublic class ShowInnerClass &#123;    public ShowInnerClass.InnerClass InnerClass;    private int data;    private int num;    private void methodOne()&#123;        System.out.println(&quot;Hello world&quot;);    &#125;    public ShowInnerClass()&#123;        InnerClass = new InnerClass();    &#125;    /**     * InnerClass是ShowInnerClass的内部类     */     class InnerClass&#123;         private int num2;         protected int age;         public void method()&#123;            data++;            methodOne();        &#125;    &#125;&#125;\n1.2.4 静态内部类\n内部类可以声明为static的，可以使用外部类的类名来访问静态的内部类，\n但静态的内部类不能访问外部类的非静态成员。\n如果内部类是静态的，使用下列语法可以直接创建它的对象:\n外部类.内部类 内部类对象名 = new 外部类.内部类();\n示例：\npublic class StaticInnerClass &#123;    public static int data;    private static void methodOne()&#123;        System.out.println(&quot;hello world! &quot;);    &#125;    /**     * InnerClass是ShowInnerClass的内部类     */    static class InnerClass&#123;        private int num2;        protected int age;        public void method()&#123;            data++;            methodOne();        &#125;    &#125;&#125;\n上面的类中定义了一个静态内部类。\npublic class StaticInnerTest &#123;    public static void main(String[] args) &#123;        StaticInnerClass.InnerClass innerClass = new StaticInnerClass.InnerClass();        innerClass.method();    &#125;&#125;\n运行结果：\nHello worldProcess finished with exit code 0\n1.2.5 内部类的使用\n我们经常在外部类中创建内部类的对象，但也可以从另外的类中创建内部类的对象。如果内部类是非静态的，\n必须先创建外部类的实例，然后使用下列语法创建内部类的对象：\n外部类.内部类   内部类对象名 = 外部类对象.new 内部类();\npublic class ShowInnerClass &#123;    public ShowInnerClass.InnerClass InnerClass;    private int data;    private int num;    private void methodOne()&#123;        System.out.println(&quot;Hello world&quot;);    &#125;    public ShowInnerClass()&#123;        InnerClass = new InnerClass();    &#125;    /**     * InnerClass是ShowInnerClass的内部类     */     class InnerClass&#123;         private int num2;         protected int age;         public void method()&#123;            data++;            methodOne();        &#125;    &#125;&#125;\n上面的类中定义了非静态内部类：\npublic class InnerTest &#123;    public static void main(String[] args) &#123;        ShowInnerClass showInnerClass = new ShowInnerClass();        ShowInnerClass.InnerClass innerClass = showInnerClass.new InnerClass();        innerClass.method();    &#125;&#125;\n运行结果：\nHello worldProcess finished with exit code 0\n2.我们为什么需要内部类？\n有人有问题：内部类要实现的东西，用前面已学的东西也可以实现，为什么要用它？\n这个问题粗略的来讲可以从使用环境来解释它。\n有的地方我们用内部类的方法会更方便，至于是那些地方，现在本人并没有很深的理解。\n但是，下面的场景我们可以考虑使用：\n在定义POJO接收Json数据时，如果存在嵌套结构，我们可以使用内部类来定义接收，如下实例：\npublic class BackRequest &#123;    private String transactionId;    private List&lt;Report&gt; reports;    public static class Report&#123;        private String uuid;        private String errorCode;        private String errorDesc;        private String time;    &#125;&#125;\n使用上面的定义，让我们很容易的将Json数据和实体一一对应。\n3.匿名内部类\n匿名类就是没有名字的子类。因为没有名字，可以使代码更简洁。\n例如\nBank是类，下面代码用Bank的一个子类创建对象：\nnew Bnak()&#123;...类体&#125;\n实例：\npublic class NoNameClass &#123;    public int num;    public int age;    public void say()&#123;        System.out.println(&quot;say hello&quot;);    &#125;    public static void main(String[] args) &#123;       NoNameClass noNameClass = new NoNameClass() &#123;           public void say() &#123;               System.out.println(&quot;I am no body&quot;);           &#125;       &#125;;       noNameClass.say();    &#125;&#125;\n运行结果：\nI am no bodyProcess finished with exit code 0\n我们可以看出这样使子类的对象的创建更简洁了。但也有一个的局限性，就是一次使用。\n不能在使用第二次这个类，因为没有名字。\nJava基础学习/src/main/java/exa15 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java基础"]},{"title":"14.接口编程","url":"/article/JavaPrograming-JavaBase-14-%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B/","content":"1.接口\n1.1 Java接口定义\n在Java程序中，我们将使用关键字interface声明的特殊类称之为接口。\n接口的定义和类的定义很相似，分为接口声明和接口体。\n例如：\n/** * 定义一个名为Printable的接口 * 其中拥有常量MAX, * 抽象方法add(),sum(float x,float y) */public interface Printable &#123;        final int MAX = 100;    /**     * 执行加操作     */    float add(float x);    /**     * 对x和y进行求和     * @param x     * @param y     * @return     */    float sum(float x,float y);&#125;\n对于一个接口，我们要记住：\n\n接口用来描述类应该做什么，而不是指定它们具体应该如何做，也就是说，Java接口从技术层面来说不应该包含实现,\n而是定义一些抽象的方法或者常量。接口定义来就是要被其他类去实现的。\n一个类可以实现一个或多个接口。（下一节会介绍）\n接口不是普通的类，而是对希望符合这个接口的类的一组定义。\n接口中的所有方法都自动是public的（无须提供public关键字）。\n接口中可以定义常量。\n\n注意：接口绝不会有实例字段，在java8之前，接口绝不会实现方法，\n现在我们已经可以在接口中提供简单方法（但这些方法不能引用实例变量），\n提供实例变量和方法实现的任务应该由实现接口的那个类来完成。 因此我们可以将接口看成是没有实例变量的抽象类。\n2.接口的实现\n2.1 implements 关键字\n一个类可以使用implements关键字实现一个或多个接口。\n因为接口可以进行多实现（继承只能单一继承），所以接口比抽象类更为灵活。\n例如：\nclass A implements Printable,Addable&#123;....&#125;\n注意： 普通类和抽象类都可以实现接口。但是二者的实现是有差别的。\n类通过实现接口里的抽象方法来实现接口，抽象类既可以实现接口中的方法，也可以直接拥有接口中的抽象方法。\n2.2 使用接口的限制\n2.2.1 实现接口的类必须有接口中的所有方法\n当一个类实现了某个接口，那么这个类就得提供这个接口的所有抽象的实现。\n如下：\npublic class PrintableImp implements Printable&#123;    @Override    public float add(float x) &#123;        return 0;    &#125;    @Override    public float sum(float x, float y) &#123;        return 0;    &#125;&#125;\n2.2.2 实现接口的抽象类可以不提供方法的实现\npublic abstract class AbstractPrintable implements Printable&#123;    &#125;\n2.2.3 如果父类实现了某个接口，那么子类也就自然实现了该接口\npublic class PrintableImpSon extends PrintableImp&#123;    &#125;\n2.2.4 接口也可以被继承\n即可以通过关键字extends声明一个接口是另一个接口的子接口。由于接口中的方法和常量都是public的，子接口将继承父接口中的全部方法和常量。\npublic interface PrintableSon extends Printable&#123;    void sayHello();&#125;\n3.接口和多态\n接口的使用也是多态的一种体现：\n由接口产生的多态就是指不同的类在实现同一个接口时可能具有不同的实现方式。\n4.接口回调\n4.1 什么是接口回调\n接口回调是指一个接口声明的变量被赋予实现类的对象地址时，可以调用一个类实现的接口方法，\n此时这个变量也就是实现类的上转型对象,接口的这个特性是实现多态的关键点。\n4.2 实例\npublic class Example &#123;    public static void main(String[] args) &#123;        //声明一个接口变量        showMessage sm;        //将实现类TV的实例地址赋给接口变量        sm = new TV();        sm.showSome(&quot;长虹电视机&quot;);//接口回调        //将实现类PC的实例地址赋给接口变量        sm = new PC();        sm.showSome(&quot;华为电脑&quot;);//接口回调    &#125;&#125;/** * 定义一个showMessage接口 */interface showMessage&#123;    void showSome(String s);&#125;/** * 定义一个接口showMessage的实现类TV */class TV implements showMessage&#123;    public void showSome(String s)&#123;        System.out.println(s);    &#125;&#125;/** * 定义一个接口showMessage的实现类PC */class PC implements showMessage &#123;    public void showSome(String s) &#123;        System.out.println(s);    &#125;&#125;\n运行结果：\n长虹电视机华为电脑Process finished with exit code 0\nJava基础学习/src/main/java/exa14 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java基础"]},{"title":"16.程序设计的三大错误,异常类和断言","url":"/article/JavaPrograming-JavaBase-16-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E9%94%99%E8%AF%AF-%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%92%8C%E6%96%AD%E8%A8%80/","content":"1.程序设计的三大错误\n1.1.语法错误\n最低级错误，由编译器发现。这个错误就是你错误使用Java语法导致的编译失败，\n这类错误一般在集成开发工具中编写代码的时候会有工具警告。\n例如：\n\n在编程中将String类型的数据赋值给int类型的变量，这明显是语法错误，所有开发工具给出了警告。\n在使用集成开发工具进行编程的过程中，语法错误基本不会发生。\n1.2.逻辑错误\n程序没有按照预期的方案执行。逻辑错误也称为小虫子（bugs）其查找和改正错误的过程称为调试（debugging）。\n处理方法一般为缩小范围法。\n根据具体的业务场景来定位具体的业务组件，然后一步一步的进行断点调试，最后定位问题所在。\n这类错误的发生条件基于没有语法错误的情况下，程序运行过程中出现了与预期结果不符的情况，\n这时这个情况的错误我们就称之为逻辑错误，这类错误是比较难处理的，它需要我们对业务有一定的熟悉度才能进行正确的解决。\n例如：我们需要写一个程序用来两数之和，我们采用这种实现\npublic byte add(byte a,byte b)&#123;    return (byte) (a+b);&#125;\n刚开始，我们可能觉得没啥问题，但是，如果我们这样使用：\npublic static void main(String[] args) &#123;    LogicError logicError = new LogicError();    byte b=100;    byte c=100;    System.out.println(&quot;100+100= &quot;+logicError.add(b,c));&#125;\n我们会发现，最后的结果和预期不一样：\n100+100= -56Process finished with exit code 0\n这就是很明显的逻辑错误了，我们用byte数据类型计算超过其运算范围的加法，就会出现得到的结果和预期的不一致的情况。\n这时候我们就可以修改程序来进行bug修复：\n/** * 逻辑错误 */public class LogicError &#123;    public int add(int a,int b)&#123;        return a+b;    &#125;    public static void main(String[] args) &#123;        LogicError logicError = new LogicError();        byte b=100;        byte c=100;        System.out.println(&quot;100+100= &quot;+logicError.add(b,c));    &#125;&#125;\n1.3.运行错误\n如果环境发现了一个不可能执行的错误，就会出现。其处理方法就是异常和断言。\n如果程序在运行中出现了错误导致程序异常中断，\n一般这样的错误最常见的是空指针异常，数据越界，错误类型转换等等。\n例如：\n/** * 运行错误 */public class RunError &#123;    public int add(Integer a,Integer b)&#123;        return a+b;    &#125;    public static void main(String[] args) &#123;        RunError logicError = new RunError();        System.out.println(&quot;100+100= &quot;+logicError.add(null,100));    &#125;&#125;\n运行结果：\nException in thread &quot;main&quot; java.lang.NullPointerException\tat Base.exa16.RunError.addOne(RunError.java:10)\tat Base.exa16.RunError.main(RunError.java:28)Process finished with exit code 1\n2.异常处理和断言\n2.1.try-catch语句处理异常\nJava使用try-catch语句来处理运行错误，就是将可能出现异常的操作语句放在try部分，\n一旦try部分抛出异常（即在try里的某条语句发生了运行错误），那么try部分将立即结束，\n转向执行异常处理器catch部分处理错误，try-catch语句可以由几个catch组成，分别处理发送的相应异常，\n例如：\ntry&#123;     包含的可能发送异常的语句    &#125;  catch(ExceptionSubClass1 e)&#123;      发生了ExceptionSubClass1异常后执行的语句  ....  &#125;  catch(ExceptionSubClass2 e)&#123;      发生了ExceptionSubClass2异常后执行的语句  ....  &#125;\n举个例子：\n假如你是一个中学生，你想要偷偷去网吧上网，但你又还怕被逮到，可是你又很聪明， 你想到了几种办法来应对，\n\n方法一：当你被老师抓到时，你会乖乖向老师认错，并求他不要告诉你父母。\n方法二：当你被父母抓到，你会转头就跑回家，疯狂做家务。\n\n在这个例子中，你去上网这个过程中可能不会出错，一切平安，也可能会出现错误，你为了处理可能出现的错误，\n于是你想出了几个办法。\ntry-catch就是用来装这些的：\ntry&#123;        你去上网；   &#125;   catch(被老师抓住)&#123;      乖乖认错；   &#125;   catch(被父母抓住)&#123;      跑回家做家务；   &#125;\n示例：\npublic class TryCatchStudy &#123;    public static void main(String[] args) &#123;        try&#123;            int i=0/0;        &#125;catch (Exception e)&#123;            e.printStackTrace();            System.out.println(&quot;发生了异常哦！！&quot;);        &#125;    &#125;&#125;\n运行结果：\njava.lang.ArithmeticException: / by zero\tat Base.exa16.TryCatchStudy.main(TryCatchStudy.java:9)发生了异常哦！！Process finished with exit code 0\n2.断言\n在一个具有自我保护能力的程序中，断言非常常用\n2.1 断言的定义\nJava中提供了一种机制，让我们能在程序开发阶段尽可能全面的测试程序的稳定性，\n同时能让我们在开发完成测试完成后不修改代码的基础上 注释掉测试语句，\n从而不让测试语句影响程序运行效率。 这种机制，就是断言机制。断言机制相比于异常处理，\n它提供了更为高效的异常处理机制(使我们有选择性的忽略某些检查代码提高运行效率)\n2.2 如何使用断言\n断言使用assert关键字,assert使用有两种：\n//condition是一个判断语句，如果判断语句是false，则会抛出AssertError异常assert condition;//其中condition是一个判断语句，如果判断语句是false，则会抛出AssertError异常且把message//赋给AssertError构造方法进行打印。assert condition:message;\n要想断言生效，需要开启断言，需要添加运行配置的VM options: -ea\n\npublic class TryCatchStudy &#123;    public static void main(String[] args) &#123;        //使用断言进行判断，如果不符合判断，则抛出异常AssertError        assert args != null;        int num = 30;        try&#123;            int i=0/0;        &#125;catch (Exception e)&#123;            e.printStackTrace();            System.out.println(&quot;发生了异常哦！！&quot;);        &#125;       //使用断言进行判断，如果不符合判断，则抛出异常,且把num的值传给AssertError        assert num&lt;0:num;    &#125;&#125;\n运行结果：\njava.lang.ArithmeticException: / by zero\tat Base.exa16.TryCatchStudy.main(TryCatchStudy.java:9)Exception in thread &quot;main&quot; java.lang.AssertionError: 30\tat Base.exa16.TryCatchStudy.main(TryCatchStudy.java:14)发生了异常哦！！Process finished with exit code 1\nJava基础学习/src/main/java/exa16 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java基础"]},{"title":"17.常用类学习,final关键字","url":"/article/JavaPrograming-JavaBase-17-%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%AD%A6%E4%B9%A0%EF%BC%8Cfinal%E5%85%B3%E9%94%AE%E5%AD%97/","content":"1.String类学习\n1.1.什么是String类\n由于程序设计中经常涉及处理和字符序列有关的算法，所以Java专门提供了用来处理字符序列的String类\n来让我们的编程变得的更简单。\n此类在java.lang包中，而此包在Java程序中被默认引用(无需import)，因此程序可以直接使用String类。\n但Java将String类定义为final类，标记为不可变类,即此类不能被继承改写。\n1.2.String类中常用的方法\n1.2.1. 构造方法\nString(char value[])\n这是String里的一个构造方法，它的作用是将一个char数组转为一个String对象进行使用\n其用法为：\nchar a[]=&#123;&#x27;j&#x27;,&#x27;a&#x27;,&#x27;v&#x27;,&#x27;a&#x27;&#125;;String s=new String(a);\n相当于：\nString s=new String(&quot;java&quot;);\nString(char value[],int offset,int count)\n也是String类的一个构造方法，它的作用是将一个char数组中的指定范围的char序列转为一个String对象并进行使用。\n其用法为：\nchar a[]=&#123;&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;&#125;;String s=new String(a,2,4);\n相当于\nString s=new String(&quot;2345&quot;);\n虽然String提供了一些构造方法给我们进行构造，但是，String的最常用的构造方式是：\nString str = “你好”;  //直接赋值\n除此之外，String还提供了其他的构造方法，这个自行查阅API或者阅读源码。\n1.2.2.public int length()\n此方法是获取一个String对象的字符序列长度的一个方法，其用法如下：\npublic static void main(String[] args) &#123;    String str = &quot;中华人民共和国&quot;;    System.out.println(&quot;中华人民共和国 长度： &quot;+str.length());&#125;\n执行结果：\n中华人民共和国 长度： 7Process finished with exit code 0\n1.2.3.public boolean equals(String s)\n此方法是一个比较两个字符串是否相同(比较的是内容)的方法，其用法如下：\npublic static void main(String[] args) &#123;    boolean a ,b;    String tom = new String(&quot;天道酬勤&quot;);    String boy = new String(&quot;天道酬勤&quot;);    String jerry = new String(&quot;投机取巧&quot;);    a=tom.equals(boy);//a的值为true    b=tom.equals(jerry);//b的值为false    System.out.println(&quot;a: &quot;+a);    System.out.println(&quot;b: &quot;+b);&#125;\n运行结果：\na: trueb: falseProcess finished with exit code 0\n1.2.4 .public boolean startsWith(String s)\npublic boolean endsWith(String s)\n它们分别是判断当前String对象的字符序列前缀或后缀是否是参数指定的String\n对象s的字符序列，其用法如下：\npublic static void main(String[] args) &#123;    boolean a,b,c,d;    String tom=&quot;天气预报&quot;;    String jerry = &quot;比赛终止&quot;;    a=tom.startsWith(&quot;天气&quot;);//a的值为true    b=jerry.startsWith(&quot;天气&quot;);//b的值为flase    c=tom.endsWith(&quot;终止&quot;);//c的值是false    d=jerry.endsWith(&quot;终止&quot;);//d的值是true    System.out.println(&quot;a: &quot;+a);    System.out.println(&quot;b: &quot;+b);    System.out.println(&quot;c: &quot;+c);    System.out.println(&quot;d: &quot;+d);&#125;\n运行结果：\na: trueb: falsec: falsed: trueProcess finished with exit code 0\n1.2.5 public int compareTo(String s)\n此方法为一个按字典排序与参数指定的String对象s的字符序列比较大小。\n用法如下：\npublic static void main(String[] args) &#123;    String str=&quot;adcde&quot;;    int a,b,c;    a = str.compareTo(&quot;boy&quot;);//小于0    b = str.compareTo(&quot;aba&quot;);//大于0    c = str.compareTo(&quot;adcde&quot;);//等于0    System.out.println(&quot;a: &quot;+a);    System.out.println(&quot;b: &quot;+b);    System.out.println(&quot;c: &quot;+c);&#125;\n运行结果：\na: -1b: 2c: 0Process finished with exit code 0\n补充（字符串大小比较规则）：以字符是ASCII值确定，比较规则是，从第一个字符开始，\n顺次向后比较直到出现不同的字符为止，然后以第一个不同的字符的ASCII值比较大小确定，\n例如：&quot;abc&quot;和&quot;abadfg&quot;相比较，由于前两个字符相同，且第三个字符不同，一个为’c’，一个为’a’,\n由于c的ASCII码比a的大，所以这两个字符串的比较结果是：“abc”&gt;“abadfg”。\n1.2.6.public boolean contains(String s)\n此方法是判断当前String对象的字符序列是否包含参数s的字符序列。\n用法如下：\npublic static void main(String[] args) &#123;    String tom=&quot;student&quot;;    boolean a,b;    a = tom.contains(&quot;stu&quot;);//的值是true    b = tom.contains(&quot;ol&quot;);//的值是false    System.out.println(&quot;a: &quot;+a);    System.out.println(&quot;b: &quot;+b);&#125;\n运行结果：\na: trueb: falseProcess finished with exit code 0\n###1.2.7.int indexOf(String s) | int lastIndexOf(String s)\nindexOf用于检索首次出现s的字符序列的位置。\nlastIndexOf检索最后出现s的字符序列的位置，若没有检索到则返回-1。\n若想指定开始检索的位置，则有indexOf(String s,int startpoint）\n和lastIndexOf(String s,int startpoint),取值后面的int startpoint为开始检索的位置。\n用法如下:\npublic static void main(String[] args) &#123;    String tom=&quot;I am a good cat&quot;;    int a,b,c,d;    a=tom.indexOf(&quot;I&quot;);    b=tom.indexOf(&quot;a&quot;);    c=tom.indexOf(&quot;good&quot;,2);    d=tom.indexOf(&quot;good&quot;,8);    System.out.println(&quot;a: &quot;+a);    System.out.println(&quot;b: &quot;+b);    System.out.println(&quot;c: &quot;+c);    System.out.println(&quot;d: &quot;+d);&#125;\n运行结果：\na: 0b: 2c: 7d: -1a lastIndexOf:13Process finished with exit code 0\n注意：String对象的字符序列中的转义字符是一个字符，例如\\n代表回行,路径表示的\\也是一个字符’'。\n1.2.8.public String substring(int startpoint)\n此方法用于获取一个新的String对象，新对象的字符序列是复制当前String对象字符序列的startpoint\n开始到最后位置上的字符所得的字符序列。\n用法如下：\npublic static void main(String[] args) &#123;    String tom=&quot;I like football&quot;;    String str = tom.substring(1);//str的字符序列为&quot; like football&quot;    System.out.println(&quot;str: &quot;+str);&#125;\n运行结果：\nstr:  like footballProcess finished with exit code 0\n还有substring(int start,int end)方法同上，但它是复制从start到end-1区间的字符。\n例如：\nString tom=&quot;I like football&quot;;String str = tom.substring(2，6);//str的字符序列为&quot;like&quot;\n1.3.String的使用场景\n1.3.1.字符串常量的使用\npublic class Exa01 &#123;    public static void main(String[] args) &#123;        String s1,s2;        s1=&quot;你好&quot;;        s2=&quot;你好&quot;;        // s1==s2的值为true        System.out.println(s1==s2);    &#125;&#125;\n也就是说，我们使用上面的方式给字符串进行赋值的时候，当赋的值相同的时候，分配的内存地址也一样。\n1.3.2.字符串的并置\nString对象可以用&quot;+&quot;进行并置运算，即首尾相接得到一个新的String对象。\n例如：\npublic class Exa02 &#123;    public static void main(String[] args) &#123;        String you=&quot;你&quot;;        String me=&quot;我&quot;;        String testOne;        // testOne为一个新的字符串对象        testOne=you+me;//testOne为&quot;你我&quot;        System.out.println(testOne);        System.out.println(you.hashCode());        System.out.println(me.hashCode());        System.out.println(testOne.hashCode());    &#125;&#125;\n运行结果：\n你我2032025105655025Process finished with exit code 0\n1.3.3.字符串与基本数据的转换\n\n基本类型数据到字符串的转换\n\n可以使用以下方法：\npublic static String valueOf(byte n)\npublic static String valueOf(int n)\n…依此类推，只需改变后面的数据类型就可以了。\n例如：\npublic class Exa03 &#123;    public static void main(String[] args) &#123;        //浮点型到String        String str = String.valueOf(1235434.345);        System.out.println(&quot;str: &quot;+str);    &#125;&#125;\n\n字符串到数据的转换\n例如：\n\npublic class Exa03 &#123;    public static void main(String[] args) &#123;        //浮点型到String        String str=String.valueOf(1235434.345);        System.out.println(&quot;str: &quot;+str);        //String 到 基本类型        int x;        String s=&quot;234&quot;;        x=Integer.parseInt(s);//可以根据需要将parseInt中的Int改为其他数据类型        System.out.println(x);    &#125;&#125;\n运行结果：\nstr: 1235434.345234Process finished with exit code 0\n1.3.4.对象的字符串表示\nObject类有一个public String toString()方法，此方法可以使一个对象通过调用该方法获得该对象的字符串表示。\n此方法的一般返回形式为：创建对象的类的名字@用字符串表示的对象的引用，\n但是我们可以重写该方法让对象的toString方法输出我们想要它输出的信息。\n例子：\npublic class Exa04 &#123;    public static void main(String args[])&#123;        Date date=new Date();        System.out.println(date.toString());        TV tv=new TV();        tv.setPrice(5345);        System.out.println(tv.toString());    &#125;&#125;class TV&#123;    double price;    public void setPrice(double m)&#123;        price=m;    &#125;    public String toString()&#123;        String oldStr=super.toString();        return oldStr+&quot;\\n这是电视机，价格是:&quot;+price;    &#125;&#125;\n运行结果：\nThu May 18 15:10:11 CST 2023Base.exa17.TV@135fbaa4这是电视机，价格是:5345.0Process finished with exit code 0\n1.3.5.字符串与字符数组，字节数组\n字符串与字符数组\nString类提供了将String对象的字符序列存放到数组中的方法：\npublic void getChar(int start,int end,char c[],int offset)\n此方法可将当前String对象的字符序列的一部分字符复制到参数c指定的数组中，\n将字符序列中从位置start到end-1位置上的字符复制到数组c中，并从数组c的offset处开始存放这些字符。\n另外，还有一个简练地将String对象的字符序列的全部字符存放在一个字符数组的方法：\npublic char[] toCharArray();\n该方法返回一个字符数组，该数组的长度与String对象的字符序列长度相等（第i个单元中的字符刚好为第i个字符）\n使用实例如下：\npublic class Exa05 &#123;    public static void main(String args[])&#123;        char[] a,c;        String s=&quot;1945年8月15日是抗战胜利日&quot;;        a = new char[4];        s.getChars(11,15,a,0);        System.out.println(a);        c=&quot;十一长假期间，学校都放假了&quot;.toCharArray();        System.out.println(c);    &#125;&#125;\n字符串与字节数组\nString类的一个构造方法String(byte[])用指定的字节数组构造一个String对象。\nString(byte[],int offset,int length)构造方法用指定的字节数组的一部分，\n即从数组的起始位置offset开始去length个字节，构造一个String对象。\npublic byte[] getBytes()方法使用平台默认的字符编码，将当前的String对象的字符序列存放到字节数组中，\n并返回数组的引用。\n例子：\npublic class Exa05 &#123;    public static void main(String args[])&#123;        char[] a,c;        String s=&quot;1945年8月15日是抗战胜利日&quot;;        a = new char[4];        s.getChars(11,15,a,0);        System.out.println(a);        c=&quot;十一长假期间，学校都放假了&quot;.toCharArray();        System.out.println(c);        //String 与 byte        byte d[]=&quot;javaHello&quot;.getBytes();//字符串转为字节数组        System.out.println(&quot;数组d的长度：&quot;+ d.length);        System.out.println(d);        String s1=new String(d,6,2);//字节数组转字符串        System.out.println(s1);//输出&quot;好&quot;        s1=new String(d,0,6);        System.out.println(s1);//输出&quot;java你&quot;    &#125;&#125;\n1.3.6.正则表达式及字符串的替换和分解\n正则表达式\n正则表达式是一个String对象的字符序列，该字符序列中含有具有特殊意义的字符，\n这些特殊字符称为元字符，如&quot;\\dcat&quot;中的\\d代表0~9中任意一个数。\nString对象调用 public boolean matches(String regex)\n方法可判断当前String对象的字符序列是否和regex指定的正则表达式匹配。（正则表达式可用来进行高效过滤）\npublic class Exa06_1 &#123;    public static void main(String[] args) &#123;        String str = &quot;0cat&quot;;        boolean is = str.matches(&quot;\\\\dcat&quot;);        System.out.println(str+&quot;是否符合正则表达式：\\\\\\\\dcat ：&quot;+is);    &#125;&#125;\n字符串的替换\nString对象可调用 public String replaceAll(String regex,String replacement)\n方法返回一个新的String对象。\n这个新对象的字符序列是把当前String对象的字符序列中所有和参数regex匹配的子字符序列，\n用参数replacement的字符序列替换后得到字符序列。\n例如：\nString str=“12hello567bird”.replaceAll(“[a-zA-a]+”,“你好”);\n此操作是将字符序列（即12hello567bird）中所有英文字符替换为&quot;你好&quot;，即str为&quot;12你好567你好&quot;。\npublic class Exa06_2 &#123;    public static void main(String[] args) &#123;        String str=&quot;12hello567bird&quot;.replaceAll(&quot;[a-zA-a]+&quot;,&quot;你好&quot;);        System.out.println(str);        String str1 = &quot;12hello567bird&quot;.replace(&quot;hello&quot;,&quot;你好&quot;);        System.out.println(str1);    &#125;&#125;\n字符序列的分隔\nString类提供了一个方法public String[] split(String regex).\n此方法可使用参数指定的正则表达式regex作为分隔标记分解出当前String对象序列中的单词，\n并将分解出的单词存放在String数组中。\n例如：\npublic class Exa06_3 &#123;    public static void main(String[] args) &#123;        String str=&quot;1949年10月1日,是中华人民共和国成立的日子&quot;;        String regex=&quot;,&quot;;        String degitWord[] = str.split(regex);        for(String str1:degitWord)&#123;            System.out.println(str1);        &#125;        String[] strings = str.split(&quot;\\\\D+&quot;);        for(String str1:strings)&#123;            System.out.println(str1);        &#125;    &#125;&#125;\n关于字符串的使用还有很多使用场景，还要学习。\n细心的我们仔细看就会发现String类被final修饰了，String是个不可变类。\n1.3.7.final关键字\n注意：final可以用来修饰类，方法和属性，但不能修饰构造方法。\n使用final修饰的类不可被继承，使用final修饰的方法不可被重写，使用final修饰的变量不可被修改。\nfinal修饰的基本类型变量的值不可被改变，但是由final修饰的引用类型变量虽然不可以改变，\n但它所指向的内存空间中的变量可以改变。\n代码地址：\nJava基础学习/src/main/java/exa17 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java基础"]},{"title":"18-1.实用类Scanner,StringBuffer,Date,Calendar","url":"/article/JavaPrograming-JavaBase-18-1-%E5%AE%9E%E7%94%A8%E7%B1%BBScanner-StringBuffer-Date-Caledar/","content":"1.Scanner类\n1.1.说明\nScanner对象可以从字符序列或文件中解析出程序所需要的数据（位置Java.util）\n1.2.常用方法\n\nScanner useDelimiter(String regex) \n此方法将正则表达式作为分隔标记（就是把与正则表达式匹配的字符作为分隔符），\n若不指定分隔标记，那么默认空格或制表符或回行符作为解析String对象中字符序列中的单词。\nString中的split方法也可以满足利用正则表达式分割字符串的功能。\n\nclass ScannerStudy&#123;    public static void main(String[] args) throws FileNotFoundException &#123;        String input = &quot;1 fish 2 fish red fish blue fish&quot;;        Scanner s = new Scanner(input).useDelimiter(&quot;\\\\s*fish\\\\s*&quot;);        System.out.println(s.nextInt());        System.out.println(s.nextInt());        System.out.println(s.next());        System.out.println(s.next());        s.close();    &#125;&#125;\n\nString next();\nScanner对象可调用此方法依次返回被解析的字符序列中字符串。\n\nclass ScannerStudy&#123;    public static void main(String[] args) throws FileNotFoundException &#123;        String input = &quot;1 fish 2 fish red fish blue fish&quot;;        Scanner s = new Scanner(input);        System.out.println(s.next());        System.out.println(s.next());        s.close();    &#125;&#125;\n\nboolean hadNext(); \n如果最后一个字符串已被next()方法返回，那么调用此方法返回的值为false，否则为true,用来判断是否还有\n信息可读\n\nclass ScannerStudy&#123;    public static void main(String[] args) throws FileNotFoundException &#123;        String input = &quot;1 fish 2 fish red fish blue fish&quot;;        Scanner s = new Scanner(input);        System.out.println(s.hadNext());        s.close();    &#125;&#125;\n\nint nextInt(); \n我们可以调用此方法将数字型字符转化为int或double数据返回，如果字符不是数字型的，\nScanner对象调用此方法将发生InputMismatchException异常，\n在处理异常时可以调用next()方法返回非数字化字符。\n\nclass ScannerStudy&#123;    public static void main(String[] args) throws FileNotFoundException &#123;        String input = &quot;1 fish 2 fish red fish blue fish&quot;;        Scanner s = new Scanner(input).useDelimiter(&quot;\\\\s*fish\\\\s*&quot;);        System.out.println(s.nextInt());        s.close();    &#125;&#125;\n1.3 Scanner的常见用法\n1.3.1 读取控制台的输入\nclass Test&#123;    public static void main(String[] args)&#123;        Scanner sc = new Scanner(System.in);        String str = sc.next();        System.out.println(str);    &#125;&#125;\n我们可以通过这个类实现和用户在控制台上的交互。\n1.3.2 简单问答程序\n我们使用这个类来做一个简单的数学问答系统\nimport java.util.Scanner;public class ScannerDemo &#123;    public static void main(String[] args) &#123;        ScannerSysIn();//完整代码点击文章底部链接进入代码仓库学习    &#125;&#125;\n你好，欢迎来到问答游戏你准备好啦吗？ 准备好啦请按Yy1+1=？2恭喜你，回答正确！得分1+2=?4很遗憾，回答错误....游戏结束！！Process finished with exit code 0\n2.StringBuffer类\n2.1.说明\n与String类不同是，StringBuffer类对象实体的内存空间可以自动的改变大小，\n便于存放可变的字符序列，增强内存利用率。(位置java.lang) ,\n与String相比，它的字符序列是可变的。和String相同的是,StringBuffer也是线程安全的。\n2.2.构造方法\n2.2.2StringBuffer();\npublic StringBuffer() &#123;     super(16); &#125;\n使用此构造方法创建一个对象的实体，初始容量可以容纳16个字符，当该对象的实体存放的字符序列的长度大于16时，\n实体的内容量自动增加(当容量满了后，自动扩容,扩容机制为2*oldCapacity+2)，以便于存放所增加的字符。\n演示实例：\nclass Test&#123;    /**     * 默认构造方法学习     */    public void study01()&#123;        //新建一个新的StringBuffer对象        StringBuffer stringBuffer = new StringBuffer();        System.out.println(&quot;使用new StringBuffer()构造的对象其容量大小为：&quot;+stringBuffer.capacity());        stringBuffer.append(&quot;1111123434433233&quot;);        System.out.println(&quot;扩容机制为：2*oldCapacity+2&quot;);        stringBuffer.append(&quot;1&quot;);        //扩容: int newCapacity = (value.length &lt;&lt; 1) + 2;  -&gt;  2*oldCapacity+2        System.out.println(&quot;第一次扩容：16*2+2= &quot;+stringBuffer.capacity());        stringBuffer.append(&quot;11111111111111112222221&quot;);        System.out.println(&quot;第二次扩容：34*2+2= &quot;+stringBuffer.capacity());    &#125;&#125;\n使用new StringBuffer()构造的对象其容量大小为：16扩容机制为：2*oldCapacity+2第一次扩容：16*2+2= 34第二次扩容：34*2+2= 70Process finished with exit code 0\n2.2.3 StringBuffer(int size);\n指定容量的构造方法\npublic StringBuffer(int capacity) &#123;       super(capacity);&#125;\n此构造方法可以指定分配给该对象的实体的初始容量为参数size指定的字符个数，也会自动增加。\nclass Test&#123;    //实例    /**     *构造时指定容量大小     */    public void study02()&#123;        StringBuffer stringBuffer = new StringBuffer(5);        System.out.println(&quot;使用new StringBuffer(5)构造的对象其容量大小为：&quot;+stringBuffer.capacity());        stringBuffer.append(&quot;11111&quot;);        System.out.println(&quot;扩容机制为：2*oldCapacity+2&quot;);        stringBuffer.append(&quot;1&quot;);        //扩容: int newCapacity = (value.length &lt;&lt; 1) + 2;  -&gt;  2*oldCapacity+2        System.out.println(&quot;第一次扩容：5*2+2= &quot;+stringBuffer.capacity());        stringBuffer.append(&quot;1111111&quot;);        System.out.println(&quot;第二次扩容：12*2+2= &quot;+stringBuffer.capacity());    &#125;&#125;\n2.2.4 StringBuffer(String s);\npublic StringBuffer(String str) &#123;       super(str.length() + 16);       append(str);   &#125;\n此构造方法可以指定分配给该对象的实体的初始容量为参数s的序列长度再加16。\nclass Test&#123;    /**     * 字符串构造     */    public void study03()&#123;        StringBuffer stringBuffer = new StringBuffer(&quot;111&quot;);        System.out.println(&quot;使用new StringBuffer(\\&quot;111\\&quot;)构造的对象其容量大小为：&quot;                +stringBuffer.capacity());    &#125;&#125;\n2.3.非构造方法\n2.3.1 append方法\nStringBuffer append(String s);\n此方法将String对象s的字符序列追加到当前StringBuffer对象的字符序列中，\n并返回当前StringBuffer对象引用。\nStringBuffer append(int n);\n此方法将int型数据n转化为String对象，再把该String对象的字符序列追加到当前StringBuffer中，\n并返回当前StringBuffer对象引用。（同理，其他数据类型一样）\nStringBuffer append(Object o);\n此方法将一个object对象o的字符序列表示(object.toString())追加到当前StringBuffer中，并返回当前StringBuffer对象引用。\n示例：\nclass Test&#123;    public void appendStudy()&#123;        StringBuffer stringBuffer = new StringBuffer(&quot;111&quot;);        stringBuffer.append(&quot;nihao&quot;);        System.out.println(stringBuffer.toString());        stringBuffer.append(1222);        System.out.println(stringBuffer.toString());        stringBuffer.append(&#x27;a&#x27;);        System.out.println(stringBuffer.toString());//.....等等        stringBuffer.append(new Object());        System.out.println(stringBuffer.toString());    &#125;&#125;\n2.3.2 public char charAt(int n);\n此方法得到StringBuffer对象字符序列中位置为n上的字符。（从0开始计数）\nclass Test&#123;    public void charAtStudy()&#123;        StringBuffer stringBuffer = new StringBuffer(&quot;123&quot;);        System.out.println(stringBuffer.charAt(1));    &#125;&#125;\n2.3.3 public void setCharAt(int n,char ch);\n此方法将当前StringBuffer对象字符序列位置n处的字符用参数ch指定的字符替换（n必须有意义）并返回当前对象引用。\nclass Test&#123;    public void charAtStudy()&#123;        StringBuffer stringBuffer = new StringBuffer(&quot;123&quot;);        System.out.println(stringBuffer.charAt(1));        stringBuffer.setCharAt(1,&#x27;4&#x27;);        System.out.println(stringBuffer.toString());    &#125;&#125;\n2.3.4 StringBuffer insert(int index,String str);\n此方法将参数str指定的字符插入到参数index指定的位置，并返回当前对象引用。\nclass Test&#123;    public void insertStudy()&#123;        StringBuffer stringBuffer = new StringBuffer(&quot;123&quot;);        stringBuffer.insert(1,6);        System.out.println(stringBuffer.toString());    &#125;&#125;\n2.3.5 public StringBuffer reverse();\n此方法可将该对象实体中的字符序列翻转，并返回当前对象引用。\nclass Test&#123;    /**     * reverse将字符序列进行反转     */    public void reverseStudy()&#123;        StringBuffer stringBuffer = new StringBuffer(&quot;123&quot;);        stringBuffer.reverse();        System.out.println(stringBuffer.toString());    &#125;&#125;\n2.3.6 StringBuffer delete(int startIndex,int endIndex);\n此方法从对象的字符序列中删除一个子字符序列，并返回（从startIndex~endIndex-1）。\nclass Test&#123;    public void deleteStudy()&#123;        StringBuffer stringBuffer = new StringBuffer(&quot;1235678&quot;);        System.out.println(stringBuffer.delete(0,3).toString());        System.out.println(stringBuffer.deleteCharAt(1).toString());    &#125;&#125;\n2.3.7 StringBuffer replace(int startIndex,int endIndex,String str);\n此方法是将位置为startIndex~endIndex-1位置的子序列用str替换。\nclass Test&#123;    public void replaceStudy()&#123;        StringBuffer stringBuffer = new StringBuffer(&quot;1235678&quot;);        stringBuffer.replace(0,3,&quot;hhhh&quot;);        System.out.println(stringBuffer.toString());    &#125; &#125;\n2.3.8 StringBuffer对象可以调用length();\n方法获取实体中存放的字符序列的长度，也可调用capacity();方法获取当前实体的实际容量。\nclass Test&#123;    public void lengthStudy()&#123;        StringBuffer stringBuffer = new StringBuffer(&quot;1235678&quot;);        System.out.println(&quot;stringBuffer length: &quot;+stringBuffer.length());        System.out.println(&quot;stringBuffer capacity: &quot;+stringBuffer.capacity());    &#125;&#125;\n3.Date类和Calendar类\n说明：\n程序设计中可能需要日期，时间等数据，而java.util包中的Date类和Calender类，二者可用于处理日期时间数据，\n让我们能获得想要的时间参数。\n3.1.Date类\n通过Date类我们可以获取我们想要的时间日期。\n3.1.1 Date();\n使用此构造方法创建的对象可以获取本机当前日期和时间。\nclass Test&#123;    /**     * 无参构造方法学习     */    public static void DateStudy1()&#123;        Date nowDate = new Date();        System.out.println(&quot;目前本机时间表示：&quot;+nowDate.toString());        System.out.println(&quot;目前时间戳&quot;+nowDate.getTime());    &#125;&#125;\n3.1.2 Date(long time);\n众所周知，计算机系统将其自身的时间的“公元”设置在1970年1月1日0时（格林威治时间），\n此方法中的参数取正数表示公元后的时间，取负数表示公元前的时间。1000表示1000ms。\nclass Test&#123;    /**     * 指定参数构造方法学习     */    public static void DateStudy2()&#123;        //获取指定时间对象        Date date = new Date(1658546489564L);        System.out.println(&quot;目前本机时间表示：&quot;+date.toString());        System.out.println(&quot;目前时间戳&quot;+date.getTime());        //除了上面两个构造方法，Date中其他的构造方法已经弃用了        Date date2 = new Date(1,2,3);    &#125;&#125;\n3.2.Calendar类\n通过Calendar类，我们可以进行日期的计算，跳转我们指定的日期时间上。\n3.2.1 static getInstance();\n此方法可以初始化一个日历对象。\n3.2.2 set方法\npublic final void set(int year,int month,int date); \npublic final void set(int year,int month,int date,int hour,int minure); \npublic final void set(int year,int month,int date,int hour,int minure,int second); \nCalendar对象可以调用上述方法将日历翻到任何一个时间，当参数year取负数时表示公元前（真实公元）\n假如我们要设置一个日期我们可以：\nclass Test&#123;    public static void main(String[] args) &#123;        Calendar calendar = Calendar.getInstance();        calendar.set(2018,5,21,12,22,34);        System.out.println(calendar.getTime());        System.out.println(calendar.getTimeInMillis());        System.out.println(calendar.getTime().getTime());    &#125;&#125;\n3.2.3 public int get(int field);\n此方法可以获取有关年份，月份，小时，星期等信息，参数的field的有效值由Calendar的静态常量指定，\n如：Calendar.get(Calendar.MONTH);返回一个整数（0表示1月依次递增年份也是如此）\n3.2.4 public long getTimeInMillis();\n此方法可以返回当前Calendar对象中时间的毫秒计时。\n关于日期API的学习，还是建议大家到下面路径进行系统学习:\nhttps://gitee.com/yan-jiadou/study/tree/master/Java%E5%8A%A8%E6%89%8B%E5%81%9A%E4%B8%80%E5%81%9A/src/main/java/DateTimeApi\n4.Console类\n如果希望在键盘输入一行文本，但不想使其在命令行显式的显示，那么就需要使用java.io包中的Console类的对象来完成。\n用法如下：\n首先使用System类调用console()方法返回Console类的一个对象。 \n例如：Console cons=System.console(); \n然后调用readPasswoord()方法读取用户在键盘输入的一行文本，并将文本以一个char数组返回： \nchar[] password = cons.readPsaaword();\n代码地址\nJava基础学习/src/main/java/Base/exa18 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java基础"]},{"title":"18-2.动手实验：简历分析器","url":"/article/JavaPrograming-JavaBase-18-2-%E5%8A%A8%E6%89%8B%E5%AE%9E%E9%AA%8C%EF%BC%9A%E7%AE%80%E5%8E%86%E5%88%86%E6%9E%90%E5%99%A8/","content":"1.制作简历分析器\n通过前面的学习，已经具备的基本的编程能力，现在可以通过自己动手做一个简历分析器来进行巩固和进阶。\n1.1 需求分析\n人工读取简历虽然准确，但是也耗费了大量的人力，如果我们能做一个简历分析器，\n在简历筛选前期自动过滤一些不符合条件的， 将会节省大量人力阅读。\n所以，需要一个简历分析程序，能快速的对一份简历进行关键信息提取，\n比如，姓名，年龄，毕业院校，专业信息等。\n1.2 场景描述\n假设现在有一个文件，内容如下\n姓名: 张麻子性别： 男年龄: 28自我评价： 好好啊好好好哈大学成绩：A A A毕业院校: 黄埔军校获得证书：教师资格证, 教官证人生格言: 公平，公平，还是tm的公平专业：打劫专业\n要求写一个程序，能提取上面的姓名，年龄，毕业院校，专业，并存放在一个对象里，然后打印对象的信息。\n1.3 具体实现\n首先，我们需要定义一个存放信息的对象:\npublic class PersonInfo &#123;    // 姓名    private String name;    // 学校名称    private String school;    // 年龄    private Integer age;    // 专业    private String professional;    public String getName() &#123;        return name;    &#125;    @Override    public String toString() &#123;        return &quot;PersonInfo&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, school=&#x27;&quot; + school + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &quot;, professional=&#x27;&quot; + professional + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getSchool() &#123;        return school;    &#125;    public void setSchool(String school) &#123;        this.school = school;    &#125;    public Integer getAge() &#123;        return age;    &#125;    public void setAge(Integer age) &#123;        this.age = age;    &#125;    public String getProfessional() &#123;        return professional;    &#125;    public void setProfessional(String professional) &#123;        this.professional = professional;    &#125;&#125;\n然后就是进行信息提取的程序：\nimport java.io.File;import java.io.FileNotFoundException;import java.util.Scanner;public class Demo &#123;    public static void main(String[] args) throws FileNotFoundException &#123;        Scanner scanner = new Scanner(new File(&quot;麻子.txt&quot;));        String[] ps = readInfo(scanner);        PersonInfo personInfo = getPersonInfo(ps);        System.out.println(&quot;简历的基本信息为：&quot;+personInfo.toString());    &#125;    /**     * 信息提取     * @param params     * @return     */    public static PersonInfo getPersonInfo(String[] params)&#123;        PersonInfo personInfo = new PersonInfo();        for(String s:params)&#123;            if(s!=null)&#123;                if(s.contains(&quot;姓名&quot;))&#123;                    s = s.replace(&quot;姓名&quot;,&quot;&quot;);                    s = s.replace(&quot;\\r&quot;,&quot;&quot;);                    personInfo.setName(s);                &#125;                if(s.contains(&quot;年龄&quot;))&#123;                    String age = &quot;&quot;;                    for(int i=0;i&lt;s.length();i++) &#123;                        if (s.charAt(i) &gt;= 48 &amp;&amp; s.charAt(i) &lt;= 57) &#123;                            age += s.charAt(i);                        &#125;                    &#125;                    personInfo.setAge(Integer.valueOf(age));                &#125;                if(s.contains(&quot;毕业院校&quot;))&#123;                    s = s.replace(&quot;毕业院校&quot;,&quot;&quot;);                    s = s.replace(&quot;\\r&quot;,&quot;&quot;);                    personInfo.setSchool(s);                &#125;                if(s.contains(&quot;专业&quot;))&#123;                    s = s.replace(&quot;专业&quot;,&quot;&quot;);                    s = s.replace(&quot;\\r&quot;,&quot;&quot;);                    personInfo.setProfessional(s);                &#125;            &#125;        &#125;        return personInfo;    &#125;    /**     * 信息扫描     * @param scanner     * @return     */    public static String[] readInfo(Scanner scanner)&#123;        String [] params = new String[2];        scanner.useDelimiter(&quot;\\n&quot;);        int i = 0;        while (true)&#123;            if(scanner.hasNext())&#123;                if(i==params.length)&#123;                    params = dilatation(params);                &#125;                params[i++] = scanner.next();            &#125;else break;        &#125;        return params;    &#125;    /**     * 字符串数组扩容     * @param source     * @return     */   public static String[] dilatation(String[] source)&#123;        String[] result = new String[2*source.length+5];        for (int i=0;i&lt;source.length;i++)&#123;            result[i] = source[i];        &#125;        return result;    &#125;&#125;\n最后运行它：\n简历的基本信息为：PersonInfo&#123;name=&#x27;: 张麻子&#x27;, school=&#x27;: 黄埔军校&#x27;, age=28, professional=&#x27;：打劫&#x27;&#125;Process finished with exit code 0\n上面是满足了基本需要，想要做的更好的同学可以在此基础上进行扩展，优化，达到更好的效果。\n注意： 上面的实践仅作为学习巩固练习，真实项目中是不会这么写的哈哈哈哈哈哈。\n代码地址\nJava基础学习/src/main/java/Base/exa18_1 · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["Java基础"]},{"title":"6.原型模式","url":"/article/DesignPattern-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-5-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","content":"1.什么是原型模式？\n原型模式是一种创建型模式，是我们能够复制已有对象而又无需使代码依赖他们所属类的一种设计模式。\n1.1原型模式解决的问题\n首先抛出一个问题：\n如果我们有一个类型为Student的对象，并希望生成与其完全相同的克隆对象，我们该如何实现呢？\n\n如果没有原型模式，我们可能的做法是：\n首先，新建一个这个类的对象，然后遍历目标对象中的所有成员变量，并将成员变量的值复制到新对象中。（直接复制） 实例代码如下：\npublic static void main(String[] args) &#123;    Student student = new Student();    student.setName(&quot;黄四郎&quot;);    student.setNum(1);    student.setAge(40);    student.setWeight(180);    System.out.println(student.toString());    Student student1 = new Student();    System.out.println(student1.toString());    student1.setName(student.getName());    student1.setNum(student.getNum());    student1.setAge(student.getAge());    student1.setWeight(student.getWeight());    System.out.println(student1);&#125;\n这样做在一些情况下可以满足我们的需求，但是有一种情况，我们可能无能为力，那就是我们如何复制目标对象的私有变量。（在不用反射和不提供共有获取方法的情况下）\n因为私有变量在对象本身以外是不可见的。\n上面我们采用的就是在定义变量的时候提供了公有get方法，所以能顺利复制。\n直接复制还有另外一个问题，那就是我们必须知道对象所属的类才能创建复制对象，所以代码必须依赖该类。 即使我们可以接收额外的依赖性，那还有一个问题：\n有时我们只知道对象所属的接口，但不知道其所属的具体类。 这时我们又该如何去做？\n1.2 解决方案： 原型模式\n原型模式将对象clone过程委托给被clone的目标对象。也就是说，目标对象的clone过程是在对象内部完成的。\n原型模式为所有支持clone的对象声明了一个通用接口（ 通常情况下，这样的接口中仅包含一个clone方法），该接口让我们能够clone对象，同时又无需将代码和对象所属类耦合。\nUML如下：\n\n所有类对clone的方法实现非常类似，该方法首先会创建一个当前类的对象，然后将原始对象所有成员变量的值复制到新建的类中。(\n包括私有变量哦)   支持clone的对象我们称之为原型。\n下面我们进行实践，将上面的Student类改为原型模式\n\n其中clone的实现是：\n@Overridepublic Student clone() &#123;    Student student = new Student();    student.name = this.name;    student.age = this.age;    student.num = this.num;    student.weight = this.weight;    return student;&#125;\n这样做之后，我们就可以用下面的方式进行克隆：\npublic static void main(String[] args) &#123;    Student student = new Student();    student.setName(&quot;黄四郎&quot;);    student.setNum(1);    student.setAge(40);    student.setWeight(180);    System.out.println(student.toString());    Student student1 = student.clone();    System.out.println(student1);&#125;\n当我们的对象有几十个变量和几百种类型时，对其进行clone甚至可以代替子类的构造。\n运作方式如下： 创建一系列不同类型对象并用不同的方式进行配置。如果所需对象与预先配置的对象相同，那么我们只需要clone原型即可，无需新建一个对象。\n2.原型模式的应用\nString的特殊性在于：\n因为他为引用型，而且他指向的值为常量，克隆出来的对象改变他的值。实际上是改变了克隆出来对象String类型成员的指向，不会影响被克隆对象的值及其指向。\n2.1 Object中的clone\n在JDK中提供了接口Cloneable,这时一个标记接口，和Object同包， Object中提供了一个\nprotected native Object clone() throws CloneNotSupportedException;\n它是用来对对象进行克隆的方法。\n这就是为什么JDK中如果想要一个类具有克隆能力就必须实现Cloneable接口的原因。而且如果我们如果不对clone方法进行重写的话，我们使用clone方法得到的对象是浅克隆的。\n浅克隆和深克隆的差别：\nclass RunoobTest implements Cloneable &#123;    // 声明变量    String name;    int likes;    RunoobTest runoobTest;    public static void main(String[] args) &#123;        // 创建对象        RunoobTest obj1 = new RunoobTest();        RunoobTest inObj = new RunoobTest();        inObj.name = &quot;内部引用对象&quot;;        inObj.likes = 222;        obj1.runoobTest = inObj;        // 初始化变量        obj1.name = &quot;Runoob&quot;;        obj1.likes = 111;        // 打印输出        System.out.println(obj1.name); // Runoob        System.out.println(obj1.likes); // 111        System.out.println(obj1.runoobTest.name);        System.out.println(obj1.runoobTest.likes);        try &#123;            // 创建 obj1 的拷贝            RunoobTest obj2 = (RunoobTest) obj1.clone();            // 使用 obj2 输出变量            System.out.println(obj2.name); // Runoob            System.out.println(obj2.likes); // 111            System.out.println(obj2.runoobTest.name);            System.out.println(obj2.runoobTest.likes);            obj2.name = new String(&quot;copy2&quot;);//这个操作不会影响obj1的内容，原因是String是final类型的,不可变的。            obj2.runoobTest.name = &quot;copy&quot;;//这个操作会印象obj1的内容        &#125; catch (Exception e) &#123;            System.out.println(e);        &#125;        System.out.println(obj1.name); // Runoob        System.out.println(obj1.likes); // 111        System.out.println(obj1.runoobTest.name);        System.out.println(obj1.runoobTest.likes);    &#125;&#125;\n","tags":["设计模式-创建型模式"]},{"title":"4.建造者模式","url":"/article/DesignPattern-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-4-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","content":"1.什么是建造者模式？\n建造者模式是一种创建型设计模式，它能让我们将创建一个复杂对象的步骤分开，一步一步的建造好我们要创建的对象架子，在最后使用时生成实例对象。\n该模式允许我们使用相同的创建代码生成不同类型的对象。\n1.1 建造者模式能解决的问题\n假设有一个复杂的类，在对其进行构造时需要对很多成员变量和嵌套对象进行繁琐的初始化工作。\n这些初始化代码通常深藏于一个包含众多参数且很难让人看懂的构造函数中，甚至更糟糕的时，这些初始化代码散落在系统的各个角落。\n在这种情况下，这样的类会让我们的系统的灵活性变得很差，很不利于系统的更新迭代。\n然而，建造者模式就能解决这个问题，建造者模式设计能让我们实现对复杂对象创建的可控化，让系统更加的灵活。\n1.2 具体解决方案\n建造者模式建议将对象构造代码从产品类中抽取出来，并聚合在一个名为Builder的独立对象中。\n1.2.1 详细解释\n我们如何去实施上面的解决方案呢？ 下面我们以一个例子来进行讲解\n1.2.1.1 设计一个House类\n我们来思考如何设计一个House类。 建造一个简单的House, 首先我们需要建造四面墙和地板，安装房门和一套窗户，然后再建造一个屋顶。\n我们知道House类中必须的属性： 墙，地板，房门，窗户，屋顶。\nUML设计如下\n\n代码如下：\npublic class House &#123;    //地板    private String floor;    //墙    private String wall;    //门    private String door;    //窗户    private String window;    //屋顶    private String roof;    public House(String floor, String wall, String door, String window, String roof) &#123;        this.floor = floor;        this.wall = wall;        this.door = door;        this.window = window;        this.roof = roof;    &#125;    public String toString() &#123;        System.out.println(&quot;恭喜您，建造了一个&quot; + floor + wall + door + window + roof + &quot; 的房子&quot;);        return &quot;恭喜您，建造了一个&quot; + floor + wall + door + window + roof + &quot; 的房子&quot;;    &#125;&#125;\n好了，我们现在可以调用House构造函数来建造一个House对象了。\npublic class Demo &#123;    public static void main(String[] args) &#123;        House house = new House(&quot;木质地板&quot;, &quot;白色墙面&quot;, &quot;钢门&quot;, &quot;木窗&quot;, &quot;平顶&quot;);        house.toString();    &#125;&#125;\n到目前为止，我们的House类的设计感觉还可以蛤，但是这样设计能应对软件开发的宿敌（ change） 吗？\n1.2.1.2 扩展House类的功能\n但是如果我们想要一栋更宽敞更明亮的房屋，还要有院子和其他设施,比如暖气，排水和供电设备等，这时又该怎么办呢？\n最简单的一种方式是扩展House基类，然后创建一系列涵盖所有参数组合的子类。\n但是这样做的后果就是我们必须面对相当数量的子类（类爆炸），并且新增任何参数都会让我们的修改变得麻烦（我们也许需要修改很多类）。\n另一种方式就是无需再写子类，直接修改House类，再此类中创建一个包含所有可能参数的超级构造函数，并用它来控制House对象，这种方式的确可以减少子类，但是它会造成另外一个问题：\n它让House类变得复杂，用起来很麻烦。 因为通常情况下，大多数参数是没有用的，这样让我们对构造函数的调用变得十分不简洁。\npublic House(String floor, String wall, String door, String window, String roof) &#123;    this.floor = floor;    this.wall = wall;    this.door = door;    this.window = window;    this.roof = roof;&#125;\n目前的构造函数的参数已经够多了。。。\n为了解决这个问题，我们可以用建造者模式：\n建造者模式建议将对象构造代码从产品类中抽取出来，并聚合在一个名为Builder的独立对象中。\n就是我们新建一个HouseBuilder类，这个类用来编写生成House对象的步骤方法，我们可以灵活的用HouseBuilder类来创建我们想要的House对象。\n该模式会将对象的构造过程划分为一组步骤，每次创建对象时，我们都需要通过生成器对象执行一系列步骤，并且一些步骤的关联性不是很强，我们可以选择我们需要的步骤，最后调用getResult方法进行目标对象创建。\npackage BuilderPattern.first;public class HouseBuilder &#123;    House house;    //地板    private String floor;    //墙    private String wall;    //门    private String door;    //窗户    private String window;    //屋顶    private String roof;    public void buildWalls(String wall) &#123;        this.wall = wall;    &#125;    public void buildDoors(String door) &#123;        this.door = door;    &#125;    public void buildWindows(String window) &#123;        this.window = window;    &#125;    public void buildRoof(String roof) &#123;        this.roof = roof;    &#125;    public void buildFloor(String floor) &#123;        this.floor = floor;    &#125;    public House getResult() &#123;        return new House(floor, wall, door, window, roof);    &#125;&#125;\n下面我们的创建House就可以这样创建了：\npublic class Demo &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;建造器进行构造： &quot;);        HouseBuilder houseBuilder = new HouseBuilder();        houseBuilder.buildDoors(&quot;木制的门&quot;);        houseBuilder.buildRoof(&quot;金色的屋顶&quot;);        House house1 = houseBuilder.getResult();        house1.toString();    &#125;&#125;\n从上面两种对比我们可以总结： 建造者实际上就是将复杂的对象构造流程用固定的代码写死，然后提供了简洁的建造接口供客户端使用。\n2.建造者模式的应用\n2.1 java.lang.StringBuilder 的设计\nJava中，相信大家都认识StringBuilder, 很明显，这是一个字符串建造者。\n我们来看下它的用法吧：\npublic static void main(String[] args) throws CloneNotSupportedException &#123;    StringBuilder stringBuilder = new StringBuilder();    stringBuilder.append(&quot;你好\\n&quot;);    stringBuilder.append(&quot;我不好&quot;);    System.out.println(stringBuilder.toString());&#125;\n其中append就是提供的一个建造方法，toString就是对应与上面的getResult。\n除此之外，StringBuilder还提供了流式建造，什么意思呢？就是下面这种用法：\npublic static void main(String[] args) throws CloneNotSupportedException &#123;    StringBuilder stringBuilder = new StringBuilder();    stringBuilder.append(&quot;hello&quot;).append(&quot;\\n&quot;).append(&quot;haha&quot;);    System.out.println(stringBuilder.toString());&#125;\n那么我们怎么做到这样呢？ 其实，我们只需要将每个建造方法的返回改为自类型就可以了。具体代码如下：\npackage BuilderPattern.first;public class HouseBuilder &#123;    House house;    //地板    private String floor;    //墙    private String wall;    //门    private String door;    //窗户    private String window;    //屋顶    private String roof;    public HouseBuilder buildWalls(String wall) &#123;        this.wall = wall;        return this;    &#125;    public HouseBuilder buildDoors(String door) &#123;        this.door = door;        return this;    &#125;    public HouseBuilder buildWindows(String window) &#123;        this.window = window;        return this;    &#125;    public HouseBuilder buildRoof(String roof) &#123;        this.roof = roof;        return this;    &#125;    public HouseBuilder buildFloor(String floor) &#123;        this.floor = floor;        return this;    &#125;    public House getResult() &#123;        return new House(floor, wall, door, window, roof);    &#125;&#125;\n使用方式如下：\npublic static void main(String[] args) &#123;    System.out.println(&quot;流式建造器进行构造： &quot;);    HouseBuilder builder = new HouseBuilder();    builder.buildRoof(&quot;黄色屋顶&quot;).buildFloor(&quot;黑色地板&quot;);    builder.getResult().toString();&#125;\n还有一些用到建造者模式的知名框架，例如okhttp3.Request.Builder, java.nio.ByteBuffer 等待。\n","tags":["设计模式-创建型模式"]},{"title":"3.单例模式","url":"/article/DesignPattern-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-3-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","content":"1.什么是单例模式？\n\n确保一个类只有一个实例，并提供一个应用全局访问点。\n\n问：这句话什么意思呢？\n答：就是利用单例模式可以让指定的类在它的整个使用周期上只生产出一个实例对象并存放在内部，且提供一个公共方法去访问这个对象。从而保证在全局范围内这个类的实例对象只有一个。\n2.根据具体的例子理解单例模式\n2.1 单例类设计\n员工A在写代码的时候发现自己写一个了类，但是这个类在整个系统中好像只需要一个对象，从业务的角度上，这个类不允许出现第二个对象，不然会产生很恐怖的后果！！\n但是他又没办法防止别人使用这个类生成对象，他这时候犯难了，他不知道该怎么办。\n员工B听到他的难处了，轻笑一声：还是太年轻了吧！ 你不知道有一种设计叫单例模式吗？\n单例模式的特点： 构造方法私有，静态自类型声明，公共访问方法\n先上图：\n\n确保一个类只有一个实例（构造方法私有，声明静态自类型变量），并提供一个全局访问点（提供一个公共方法访问静态变量）。\n没错，就是这么简单，\n下面代码这个类保证了自己只生成一个对象，怎么做到的呢？\n其实将构造方法私有化，并在自己内部组合一个自身的引用且提供一个公共方法得到这个引用。\npackage SingletonPattern.first;/** * 普通单例类，应用场景： * 注册表设置，连接池，线程池等等。利用单件模式对象， * 我们可以确保程序中使用的全局资源只有一份 */public class Singleton &#123;    //自类型引用    private static Singleton instance;    //构造方法私有化    private Singleton() &#123;    &#125;    /**     * 公共访问点     * @return     */    public static Singleton getInstance() &#123;        if (instance == null) &#123;            instance = new Singleton();        &#125;        return instance;    &#125;    public void sayHello() &#123;        System.out.println(&quot;Hello world!!&quot;);    &#125;&#125;\n员工A如获至宝，立即打断了员工B的讲解，并迫不及待的在程序中用上了。 这时员工B只是笑笑不说话。\n2.2 多线程下的单例类安全吗？\n用了一段时间，员工A发现，上面单例类的设计存在一个缺陷，就是在多线程的情况下不安全！！\n如果两个线程同时进入了空判断，这时，可能会发生单例类实例化两次的情况。这违背了设计初衷！！\n如下所示：\npackage SingletonPattern.third;/** * 单例模式确保了一个类只有一个实例，并提供了一个全局访问点 */public class SingletonChocolateBoiler &#123;    public static SingletonChocolateBoiler Instance;    /**     * 通过私有化构造方法，达到单一实例的效果     */    private SingletonChocolateBoiler() &#123;    &#125;    /**     * 获取实例唯一入口     * @return 此类的唯一实例     */    public static SingletonChocolateBoiler getInstance() &#123;        if (Instance == null) &#123;            Instance = new SingletonChocolateBoiler();            System.out.println(&quot;构造了一个新SingletonChocolateBoiler对象&quot;);        &#125;        return Instance;    &#125;&#125;\n线程安全测试：\npackage SingletonPattern.third;/** * 按道理说，使用Singleton对象时，无论多少个线程使用它，它都应该始终构造一次即可，但是， * 如果按照second中的做法去设计类，时会出现线程安全问题的，例如如下 */public class ThreadProblem &#123;    public static void main(String[] args) &#123;        for (int i = 0; i &lt; 1000; i++) &#123;            new Thread(() -&gt; &#123;                SingletonChocolateBoiler.getInstance();            &#125;).start();        &#125;    &#125;&#125;\n\n这时，员工A想起了员工B在向他介绍这个模式的时候好像还有些话没说。\n于是，他找到了员工B，员工B欣慰的笑了，说：小子，你终于发现了。 给你个提示： synchronized\n员工A茅塞顿开：\npackage SingletonPattern.third;public class FirstSafeSingleton &#123;    private static FirstSafeSingleton Instance;    private FirstSafeSingleton() &#123;    &#125;    /**     * 通过这样进行同步确实可以解决问题，但是通过同步加锁是一定会增加性能开销的     * 因为我们只需要在第一次构造实例时进行同步即可，其他的情况不需要同步     * @return     */    public static synchronized FirstSafeSingleton getInstance() &#123;        if (Instance == null) &#123;            Instance = new FirstSafeSingleton();            System.out.println(&quot;构造一个新的FirstSafeSingleton&quot;);        &#125;        return Instance;    &#125;&#125;\n紧接着做出了如下对比测试：\npackage SingletonPattern.third;/** * 按道理说，使用Singleton对象时，无论多少个线程使用它，它都应该始终构造一次即可，但是， * 如果按照second中的做法去设计类，时会出现线程安全问题的，例如如下 */public class ThreadProblem &#123;    public static void main(String[] args) &#123;        for (int i = 0; i &lt; 10000; i++) &#123;            new Thread(() -&gt; &#123;                SingletonChocolateBoiler.getInstance();            &#125;).start();        &#125;        //通过synchronized解决后测试        for (int i = 0; i &lt; 10000; i++) &#123;            new Thread(() -&gt; &#123;                FirstSafeSingleton.getInstance();            &#125;).start();        &#125;    &#125;&#125;\n\n果然，安全问题解决了。但是员工A还是觉得不划算，只是为了解决第一次构造实例时的线程安全问题就牺牲整个getInstance方法的性能，太不划算了。\n有没有什么方法，只保证在第一次构造对象时的线程安全即可。员工B欣慰的笑了，随后提示到： 双重检测机制。\n这时员工A上百度搜索了一下，茅塞顿开：\npackage SingletonPattern.third;public class SecondSafeSingleton &#123;    /**     *volatile保证了此变量的可见性(一个线程对主内存的修改可以及时的被其他线程观察到)     *这样当第一个线程将此变量的实例存入主内存后，其他线程知道了后     *在进行Instance==null判断的时候就会判断正确并获得正确的实例对象     * 防止重排序出现问题     */    private volatile static SecondSafeSingleton Instance;    private SecondSafeSingleton() &#123;    &#125;    /**     * 双重检查锁机制解决first中引起的性能降低     * @return     */    public static SecondSafeSingleton getInstance() &#123;//第一次检查，这里可能会出现多个线程同时进入的情况        if (Instance == null) &#123;//此时采取同步措施，保证多个线程进入下面的代码块是串行的            synchronized (SecondSafeSingleton.class) &#123;//这里第一个线程肯定是满足条件的，此时它进入下面的步骤进行实例构造//但由于我们使用了volatile，Instance被更新了立刻被其他线程知道了，//第二个线程在进来的时候这里的判断是过不去的                if (Instance == null) &#123;                    Instance = new SecondSafeSingleton();                    System.out.println(&quot;构造了一个新的SecondSafeSingleton&quot;);                &#125;            &#125;        &#125;        return Instance;    &#125;&#125;\n然后又做出了对比测试：\n\n上面的加载方式被称为懒汉式加载，就是用到的时候才加载。\n其实还有一种方式来编写单例类：饿汉式单例类\n这种方式的特点是简单，缺点是比较浪费资源。\npublic class HungrySingleton &#123;    //饿汉式加载    private final static HungrySingleton hungrySingleton = new HungrySingleton();    private HungrySingleton() &#123;    &#125;    public HungrySingleton getInstance() &#123;        return hungrySingleton;    &#125;&#125;\n还有一种被称为静态内部类的方式，这种方式实现方式简单，也不浪费资源，是懒加载和安全性的结合：\npublic class Singleton &#123;    private static class SingletonHolder &#123;        private static final Singleton INSTANCE = new Singleton();    &#125;    private Singleton() &#123;    &#125;    public static final Singleton getInstance() &#123;        return SingletonHolder.INSTANCE;    &#125;&#125;\n使用枚举也是个不错的选择：\npublic enum Singleton &#123;    INSTANCE;    public void whateverMethod() &#123;    &#125;&#125;\n","tags":["设计模式-创建型模式"]},{"title":"4.工厂模式能解决的问题","url":"/article/DesignPattern-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-4-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F/","content":"1.工厂模式能解决啥问题？\n我们考虑这个问题的时候就说明我们其实已经了解了工厂模式，我们想要知道工厂模式的具体应用场景，并灵活的在工作中使用它来提供工作效率。\n1.1 复习工厂模式\n工厂模式具体分为：\n简单工厂：将创建一类对象的细节(new的过程)封装在一个类(工厂类)中，外界只需要通过这个工厂类根据特定的参数就能直接获取想要的对象。\n工厂方法模式：定义一个创建对象的接口，由其子类来决定要实例化的类是哪一个，工厂方法模式将实例化延迟到子类中。\n抽象工厂模式：提供一个接口，用于创建相关对象或依赖对象的家族，而不需要明确指定具体类。通过依赖注入来降低耦合。\n下面我们来根据具体的UML图对这三个具体的工厂模式进行复习。\n1.1.1 简单工厂模式\n看不懂的同学请跳到工厂模式那一节。\n\n将创建一类对象的细节(new的过程)封装在一个类(工厂类)中，外界只需要通过这个工厂类根据特定的参数就能直接获取想要的对象。\n下面我们根据这句话来解析上面的UML图中的信息，使其一一对应起来：\n上面的UML中的工厂类是PizzaFacotory，在这个类里封装了对具体的CheesePizza,GreekPizza实体类的创建。\nPizzaStore就是外界，在PizzaStore中，只需要根据特定的参数type调用PizzaFacotory的getPizza就能获得相应的对象，而无需进行new。\n1.1.2 工厂方法模式\n看不懂的同学请跳到工厂模式那一节。\n\n定义一个创建对象的接口，由其子类来决定要实例化的类是哪一个，工厂方法模式将实例化延迟到子类中。\n其中PizzaFactory就是一个创建对象的接口，由NYPizzaFactory,ChicagoPizzaFactory,CaliforniaPizzaFactory这些继承PizzaFactory的子类来决定具体实例化那个实体类。\n1.1.3 抽象工厂模式\n看不懂的同学请跳到抽象工厂模式那一节。\n提供一个接口用于创建相关依赖或依赖对象的家族，而不需要明确指定具体类。通过依赖注入来降低耦合。\n\n首先，将Pizza抽象化，并且建立一个PizzaFactory接口将具体的Pizza工厂和具体的Pizza解耦（通过依赖注入相关联），然后建立一个抽象PizzaStore将具体的Store和具体的Pizza解耦，和具体的PizzaFactory解耦。\n1.2 我们在项目中哪里会用到工厂模式呢？\n其实如果我们稍稍留意一下，就会发现当我们使用Spring的WebApplicationContext.getBean(beanName);根据bean名称获取实例的方式，用的就是工厂模式实现的。\n在Spring项目中，工厂模式大致的运行思路是：\n首先在系统初始化时实例化所有的Bean类，将其实例放到BeanFactory中或者将其new的方式放入Factory中，我们在编写代码时，不用去new某个Bean，而根据BeanName或Type调用BeanFactory就能得到具体类的实例化对象。\n这样做就能将业务代码和具体的Bean解耦。\n比如我们写一个通用查询接口，这个接口能通过入参中查询类型参数的取值不同而能查询到不同的数据。\n我们可以先写出针对不同查询的查询组件，然后在配置文件中配置查询类型参数取值和具体的查询组件的映射关系，这样我们就可以完成业务代码和Bean的解耦，查询接口具体执行那种查询是根据配置的映射关系到对象工厂中获取对象执行，然后将结果返回。\n\n所以工厂模式的应用场景有： 在某种业务场景下，我们只需要在一类对象中获取一个对象进行使用时，我们可以使用工厂模式将创建的过程聚合在某个地方方便管理。\n","tags":["设计模式-创建型模式"]},{"title":"5.单例模式进阶","url":"/article/DesignPattern-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-5-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%BF%9B%E9%98%B6/","content":"1.单例模式能解决啥问题？\n首先，我们先来复习一下什么是单例模式：\n单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。\n那么问题来了？ 什么样的类只能创建一个实例呢？\n比如，在一个系统中，总有一些东西是全局共享且很少改变的。 比如数据库的url , password, username配置信息。我们可以把它放在一个单例类中，然后系统中所有的地方需要用到这些配置的时候，就可以直接通过全局访问点获得此单例类的实例，然后通过调用相关的方法获取相关的配置。\n1.1复习单例模式\n\n单例模式的UML非常简单，首先是私有化构造函数，然后是增加一个对外的对象全局访问点。\n1.1.1 单例类的常见实现方式\n1.1.1.1 懒汉式 ：第一次使用时才创建对象\n普通实现\npublic class Singleton {\n//采用static修饰保证此类只有一个实例\nprivate static Singleton instance;\nprivate Singleton (){}\n//用synchronized保证此类不会实例化此类两次\npublic static synchronized Singleton getInstance() {\nif (instance == null) {\ninstance = new Singleton();\n}\nreturn instance;\n}\n}\n采用双重检查锁机制实现安全的懒汉式单例类\npublic class Singleton {\n//volatile保证此类变量的可见性，保持线程安全\nprivate volatile static Singleton singleton;\nprivate Singleton (){}\npublic static Singleton getSingleton() {\nif (singleton == null) {\nsynchronized (Singleton.class) {\nif (singleton == null) {\nsingleton = new Singleton();\n}\n}\n}\nreturn singleton;\n}\n}\n1.1.1.2饿汉式： 类加载的时候就初始化单例对象\npublic class Singleton {\n//final保证了此变量的不可变性，防止反射攻击\nprivate static final Singleton instance = new Singleton();\nprivate Singleton (){}\npublic static Singleton getInstance() {\nreturn instance;\n}\n}\n通过静态代码块的方式实现单例类\n/**\n* 静态代码块方式实现单例类，此种方式和和饿汉式效果一样，都是在类加载的时候进行实例化\n*/\npublic class StaticBlockSingleton {\n//final保证变量的不可变性，防止反射攻击\nprivate static final StaticBlockSingleton instance;\nprivate StaticBlockSingleton(){}\n//静态代码块也是在类加载是进行初始化的，且只执行一次\nstatic{\ntry{\ninstance = new StaticBlockSingleton();\n}catch(Exception e){\nthrow new RuntimeException(“Exception occured in creating singleton instance”);\n}\n}\npublic static StaticBlockSingleton getInstance(){\nreturn instance;\n}\n}\n1.1.1.3静态内部类实现方式：这种方式即达到了懒加载的效果，也实现了线程安全。\npublic class Singleton {\n//静态内部类只有在第一次使用时加载\nprivate static class SingletonHolder {\nprivate static final Singleton INSTANCE = new Singleton();\n}\nprivate Singleton (){}\npublic static final Singleton getInstance() {\nreturn SingletonHolder.INSTANCE;\n}\n}\n1.1.1.4枚举实现方式： 这是单例模式的最佳实现方式，它简洁，自动支持序列化机制，绝对防止多次实例化。\n/**\n* 枚举单例实现\n* 其实我们采用普通私有化构造器方法是实现单例类的方式在反射面前并不可靠\n* 因为一些客户端使用反射机制能够实例化单例类的第二个实例甚至第n个实例，\n* 如果我们想要抵御这样的攻击，我们可以人为的增加限制，让构造器进行自我检查，就是在构造器尝试实例化第二个实例的时候抛出异常\n* 单例枚举单例可以不用那么麻烦就能做到抵御前面的攻击,枚举对象天然就是单例\n*/\npublic enum EnumSingleton {\nINSTANCE;\nprivate String name;\nprivate String code;\npublic String getName(){\nreturn name;\n}\npublic String getCode(){\nreturn code;\n}\npublic void setName(String name){\nthis.name = name;\n}\npublic void setCode(String code){\nthis.code = code;\n}\n}\n1.1.1.5序列化单例类\nimport java.io.Serializable;\n/**\n* 可序列化的单例类，用于分布式系统的单例类\n*/\npublic class SerializedSingleton implements Serializable {\nprivate static final long serialVersionUID = -78834253243544235L;\nprivate SerializedSingleton(){}\nprivate static class SingletonHelper{\nprivate static final SerializedSingleton instance = new SerializedSingleton();\n}\npublic static SerializedSingleton getInstance(){\nreturn SingletonHelper.instance;\n}\n/**\n*通过添加这个方法能防止序列化所造成的多实例\n*/\nprotected Object readResolve() {\nreturn getInstance();\n}\n}\nHead first 设计模式学习: Head First设计模式学习，从简单的粗暴的实现到使用设计模式进行实现，层层递进，简单易学，和Head First书本基本一致，但又进行细致和层次化学习的扩展。 - Gitee.com\n","tags":["设计模式-创建型模式"]},{"title":"2.抽象工厂模式","url":"/article/DesignPattern-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-2-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","content":"1.什么是抽象工厂模式？\n提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。 通过依赖注入来降低耦合。\n\n2.结合工厂模式的披萨实例来理解抽象工厂模式\n2.1 具体设计\n尽管上一节的工厂模式设计已经好像看着可以，但是，我们好像也能明显的发觉到对于具体的PizzaStore的编写，我们好像违反了一个原则： 不要依赖具体，要依赖抽象。\n例如我们看一下NYPizzaStore，它里面好像依赖了具体的Pizza对象，现在看来它就依赖了两个，但是如果长期以这样的方式来做的话，不难发现我们会进入一个依赖噩梦。\npackage factoryPattern.third.store;import factoryPattern.third.PizzaStore;import factoryPattern.third.pizza.NYPizza1;import factoryPattern.third.pizza.NYPizza2;import factoryPattern.third.pizza.Pizza;public class NYPizzaStore extends PizzaStore &#123;    @Override    protected Pizza createPizza(String type) &#123;        Pizza pizza = null;        if (type.equals(&quot;NY1&quot;)) &#123;            pizza = new NYPizza1();        &#125; else if (type.equals(&quot;NY2&quot;)) &#123;            pizza = new NYPizza2();        &#125;        return pizza;    &#125;&#125;\n如何解决这个问题，我们也许可以从抽象工厂模式中得到启发。\n抽象工厂模式：提供一个接口用于创建相关或依赖对象的家族，而不需要明确指定具体类。\n那么我们该如何让PizzaStore从依赖噩梦中解脱呢？\n员工A在原有的基础上，进行思考后,设计出下面的结构：\n\n首先，他将Pizza抽象化了，并且新建立一个PizzaFactory接口用来将具体的PizzaStory和具体的Pizza实例解耦。\n从图中我们可以看到，面向用户的具体的NYPizzaStore是通过依赖抽象的方式来满足需求的。\n2.2 具体实现\nhttps://gitee.com/yan-jiadou/design-mode/tree/master/设计模式/src/main/java/AbstractFactoryPattern\nOK，构建完毕，下面进行测试一下：\npackage AbstractFactoryPattern;import AbstractFactoryPattern.base.PizzaStore;import AbstractFactoryPattern.pizzaStore.NYPizzaStore;/*** 抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。 这种方式依赖注入  */  public class MainTest &#123;  public static void main(String[] args) &#123;  PizzaStore nyPizzaStore = new NYPizzaStore();  nyPizzaStore.orderPizza(&quot;cheese&quot;);  &#125;  &#125;\n完成！！ 如果你重现出了这种方式，可以将它和上一节的例子进行对比。\n","tags":["设计模式-创建型模式"]},{"title":"1.工厂模式","url":"/article/DesignPattern-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-1-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","content":"1.什么是工厂模式？\n工厂模式：\n\n\n简单工厂： 将创建一类对象的细节封装在一个工厂对象中，外界只需要通过这个工厂对象根据特定的参数直接获取想要的目标对象。\n\n\n工厂方法模式：定义一个创建对象的工厂接口，将其组合到工作类中，实现工厂接口产生不同的实现， 用户类可以根据自己的需求自己决定使用哪一个实现，将其注入到工作类中。\n\n\n2.实例理解工厂模式\n2.1 员工A的困惑\n在自己学习到一个原则后：面对抽象编程，而不是面对具体实现编程。 员工A有了自己的困惑，为啥我们知道这个原则，\n但是还是逃不掉new，要知道我们在代码里写出new A()的时候就已经是针对具体实现编程了!!\n当看到new 的时候，就会想到具体，我们无法回避这个问题，例如我们在学习策略模式时：\nDuck duck = new MallardDuck();\n这里是针对具体实现编程，因为程序里还是依赖了具体的MallardDuck类。\n当我们需要根据某个条件在某群类中实例化一个的时候，我们的代码可能就会变成这样：\npublic class MakeDuck &#123;    public boolean picnic;    public boolean hunting;    public boolean inBathTub;    public Duck getDuck() &#123;        Duck duck;        if (picnic) &#123;            duck = new MallardDuck();        &#125; else if (hunting) &#123;            duck = new DecoyDuck();        &#125; else if (inBathTub) &#123;            duck = new RubberDuck();        &#125;        duck.fly();        duck.quack();        duck.swim();        return duck;    &#125;&#125;\n当我们写了这样的代码后，一旦后面需要增加Duck实现类，或者更改对象构造条件，我们都需要打开这个类进行修改。\n这样做违反了开闭原则（对扩展开放，对修改关闭）\n我们好像陷入了僵局，陷入了new和设计原则的僵局了，那么如何破局呢？ 员工B给出了他的看法\n2.2 员工B的观察\n员工B细心的发现，其实上面的根据条件构造不同对象的做法是不是就是我们编程过程中变化的部分。\n我们之前的策略模式在这里好像能给我们启发 ： 找出变化的部分，把它们从不变的部分分离出来。\n于是员工B结合公司正在做的披萨订单项目，实践了他的想法， 情况是这样的：\n在这个项目里，进行披萨订单的方法是这样写的：\npublic static Pizza orderPizza(String type) &#123;    Pizza pizza = null;    if (type.equals(&quot;cheese&quot;)) &#123;        pizza = new CheesePizza();    &#125; else if (type.equals(&quot;greek&quot;)) &#123;        pizza = new GreekPizza();    &#125;    assert pizza != null;    pizza.prepare();    pizza.bake();    pizza.cut();    pizza.box();    return pizza;&#125;\n我们其实不难发现，其中变化的部分就是：\nif(type.equals(&quot;cheese&quot;))&#123;pizza =new CheesePizza();&#125;else if(type.equals(&quot;greek&quot;))&#123;pizza =new GreekPizza();&#125;\n我们可以把它提取出来，放到一个类里：\n然后调用那个类去生产实例对象就好了，这样就把变化的部分提取出来了。(动静分离)\npackage factoryPattern.first;public class PizzaFactory &#123;    public static Pizza getPizza(String type) &#123;        Pizza pizza = null;        if (type.equals(&quot;cheese&quot;)) &#123;            pizza = new CheesePizza();        &#125; else if (type.equals(&quot;greek&quot;)) &#123;            pizza = new GreekPizza();        &#125;        return pizza;    &#125;&#125;\n剩余完整代码如下：\n简单工厂模式代码\n下面进行测试下：\npublic class MainTest &#123;    public static void main(String[] args) &#123;        Pizza pizza = Pizza.orderPizza(&quot;cheese&quot;);    &#125;&#125;\n这样的话我们就可以在披萨种类变化的时候只修改变化的类PizzaFactory就好了,这就是简单工厂模式。\n简单工厂UML图如下：\n\n2.3 披萨订单系统的一次需求\n现在客户的订单披萨系统不能满足部分需求了：随着披萨店越来越多，部分加盟店想要自己提供自己的特色披萨，然而目前系统好像只能做指定类型的披萨。例如纽约，芝加哥，加州。\n这时员工A想了下，他想到了一个解决方案，下面我们来看看：\n我们可以利用PizzaFactory，将PizzaFactory抽象成一个接口，写出三种不同的披萨工厂实现类，分别为：\nNYPizzaFactory , ChicagoPizzaFactory , CaliforniaPizzaFactory , 那么这几个加盟店就有了自己的披萨工厂类使用了。\nUML如图：\n\n下面我们来实现看看：\n第一次需求解决方案\nOK，新的Pizza订单系统创建完毕，下面我们进行使用测试一下：\npackage factoryPattern.second;import factoryPattern.second.factory.CaliforniaPizzaFactory;import factoryPattern.second.factory.ChicagoPizzaFactory;import factoryPattern.second.factory.NYPizzaFactory;public class MainTest &#123;public static void main(String[] args) &#123;//纽约分店PizzaStore pizzaStore1 = new PizzaStore(new NYPizzaFactory());pizzaStore1.orderPizza(&quot;NY1&quot;);        //芝加哥分店        PizzaStore pizzaStore2 = new PizzaStore(new ChicagoPizzaFactory());        pizzaStore2.orderPizza(&quot;ChicagoPizza1&quot;);        //加州分店        PizzaStore pizzaStore3 = new PizzaStore(new CaliforniaPizzaFactory());        pizzaStore3.orderPizza(&quot;California1&quot;);    &#125;&#125;\n完成，满足需求！！！\n2.4 披萨订单系统的第二次需求\n随着业务的扩展，市场的变化，一些加盟店虽然使用我们推出的披萨工厂进行创建披萨，但是在制作工艺和流程上，不同的加盟店的厨师却有着不同的见解，于是他们希望我们能提供一个更具弹性的订单系统，支持制作流程的特殊化。\n这个要怎么实现呢？ 领导将这个任务交给的员工B来做， 员工B结合现状， 思考了良久，给出了下面的方案：\n\n下面来实现它：\nhttps://gitee.com/yan-jiadou/design-mode/tree/master/设计模式/src/main/java/FactoryPattern/third\n下面进行测试：\npackage factoryPattern.third;import factoryPattern.third.store.ChicagoPizzaStore;import factoryPattern.third.store.NYPizzaStore;public class MainTest &#123;public static void main(String[] args) &#123;PizzaStore pizzaStore1 = new NYPizzaStore();pizzaStore1.orderPizza(&quot;NY1&quot;);        PizzaStore pizzaStore2 = new ChicagoPizzaStore();        pizzaStore2.orderPizza(&quot;ChicagoPizza1&quot;);    &#125;&#125;\n完成， 这次的需求问题解决了。 下面我们来认识一下工厂方法模式：\n定义一个创建对象的接口，但是由子类去决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类中。\n2.5 出现了依赖问题\n尽管上面的设计已经好像看着可以，但是，我们好像也能明显的发觉到对于具体的PizzaStore的编写，我们好像违反了一个原则：\n不要依赖具体，要依赖抽象。\n例如我们看一下NYPizzaStore，它里面好像依赖了具体的Pizza对象，现在看来它就依赖了两个，但是如果长期以这样的方式来做的话，不难发现我们会进入一个依赖噩梦。\npackage factoryPattern.third.store;import factoryPattern.third.PizzaStore;import factoryPattern.third.pizza.NYPizza1;import factoryPattern.third.pizza.NYPizza2;import factoryPattern.third.pizza.Pizza;public class NYPizzaStore extends PizzaStore &#123;    @Override    protected Pizza createPizza(String type) &#123;        Pizza pizza = null;        if (type.equals(&quot;NY1&quot;)) &#123;            pizza = new NYPizza1();        &#125; else if (type.equals(&quot;NY2&quot;)) &#123;            pizza = new NYPizza2();        &#125;        return pizza;    &#125;&#125;\n如何解决这个问题，下一节的抽象工厂模式也许能解决这个问题。\n抽象工厂模式：提供一个接口用于创建相关或依赖对象的家族，而不需要明确指定具体类。\n","tags":["设计模式-创建型模式"]},{"title":"1.Redis基础","url":"/article/Database-Redis-1-Redis%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%EF%BC%9ARedis%E6%A6%82%E8%BF%B0%E5%8F%8AString%E5%92%8CHash%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/","content":"一.Redis概述\n1.Redis是什么？\nRedis是一个开源的，高性能的，基于内存的键值对的缓存与存储系统，通过提供多种键值数据类型（五种）来适应不同场景下的缓存与存储需求。与mysql相比，它的读写速度很快。\n2.Redis支持的键值数据类型有哪些？\n1）字符串类型（String）\n2）散列类型（Hash）\n\n\n列表类型（List）\n\n\n集合类型（Set)\n\n\n有序集合类型（TreeSet）\n\n\n注意：String类型是Redis中最基本的数据类型，它能存储任何形式的字符串，它是其他4种数据类型的基础，其他数据类型和字符串类型的差别从某种角度来说只是组织字符串的形式不同。\n3.Redis技术特性\n1.相对于一般数据库，Redis映射结构的存储方式和多种键值数据类型的支持使我们可以将程序中的数据直接映射到Redis中，因为数据在程序中的存储方式和Redis中的存储方式非常相似。\n2.Redis对不同数据类型提供了非常方便的操作方式，这让我们使用起来也很方便。\n3.Redis数据库中的所有数据都存储在内存中，所以它的存取速度相对于其他基于硬盘存储的数据库，它的性能优势非常大，同时，它也提供数据持久化支持，不必担心数据丢失。\n4.虽然Redis是一个数据库，但由于它提供了丰富的功能和惊人的响应速度，很多技术人员把它当作缓存系统，队列系统来使用。\n5.Redis使用C语言开发，代码量只有几万行，这意味着改造它成为可能。\n二.Redis字符串和散列数据类型操作命令学习\n注意：Redis中所有命令都是原子操作\n字符串类型\n1.获得键名列表\nKEYS * //获得所有键名列表\nKEYS a [b-d ] //获得匹配的键名列表 ab ac ad\nKEYS a? //匹配a~ 问号可以匹配任何一个字符\n2.创建一个键值对\nSET keyname value //keyname是键名 value是它对应的值\n或者创建多个\nMSET keyname1 value1 keyname2 value2 …\n3.判断名为keyname的键是否存在\nEXISTS keyname //返回1存在，0不存在\n4.删除一个或多个键\nDEL keyname\n或者\nDEL keyname1 keyname2 …\n5.获得键值的数据类型\nTYPE keyname\n6.让当前键值递增，并返回递增后的值，如果当前键值不是数字会报错\nINCR keyname\n7.指定键值加上指定数\nINCRBY keyname n //让keyname对应的值加n\n或者增加指定浮点数\nINCRBYFLOAT keyname m//m为浮点数\n8.指定键值减1或减n操作\nDECR keyname //减一\nDECR keyname n//减n\n9.向键值末尾添加指定字符串\nAPPEND keyname value //如果value中包含空格类型的字符，我们可以用 “value”\n10.获得键值长度\nSTRLEN keyname\n11.获取一个或多个键值\nMGET keyname1 keyname2 …\n位操作\n12.获得键值位级数据第offet+1个数值(因为从0开始计数)\nGETBIT keyname offet\n13.设置键值指定位置(offet位)二进制的数，返回其旧值\nSETBIT keyname offet value\n14.获取键值中位值为1的二进制位个数\nBITCOUNT keyname\n或者\nBITCOUNT keyname n m//n ,m限制统计的字节范围（从0开始计数）\n15.位运算\nBITOP OR res foo1 foo2//将foo1和foo2进行或运算后的结果放入res中\n//AND 与\n//NOT 非\n//XOR 异或\n16.获取键值中第n个二进制数为1的偏移量（把存储单元的实际地址与其所在段的段地址之间的距离称为段内偏移，也称为“有效地址或偏移量”。）\nBITPOS keyname n\n或者\nBITPOS keyname n m k//其中m k 指定开始和结束字节的位置\n利用位操作命令可以非常紧凑地存储布尔值。\n散列类型\n其类型结构为：\n\n1.设置一个散列类型键值对\nHSET keyname field value//同时它也兼并更新操作\n2.获取某键某字段的值\nHGET keyname field\n3.设置或更新多个字段\nHMSET keyname field1 value1 field2 value2 …\n4.获取指定键的多个字段值\nHMGET keyname field1 field2 …\n5.获取某键的所有信息\nHGETALL keyname\n6.判断字段是否存在\nHEXISTS keyname field\n7.不更新创建：当字段不存在时才创建，否则不执行任何操作\nHSETNX keyname field value\n8.使指定字段加n\nHINCRBY keyname field n//当keyname不存在时会自动创建且字段值为n\n9.删除一个或多个字段\nHDEL keyname field …\n10.只获取所有字段名\nHKEYS keyname\n11.只获取所有字段值\nHVALS keyname\n12.获取字段数量\nHLEN keyname\nRedis中散列类型相对于普通数据库而言，它可以自由的为任何键增减字段而不影响其他的键。\n","tags":["Redis学习"]},{"title":"2.Redis数据类型和操作指令","url":"/article/Database-Redis-2-Redis%E5%85%A5%E9%97%A8%EF%BC%9A%E5%88%97%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E9%9B%86%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/","content":"三.列表类型\nRedis里的列表类型可以存储一个有序的字符串列表，其内部使用双向链表实现，故向列表两端添加元素的时间复杂度为1，获取越接近两端的元素速度就越快。\n操作命令\n1.向列表中添加元素，如果列表不存在则自动创建\nLPUSH keyname value …//向列表左边添加一个或多个元素，返回增加后列表的长度\nRPUSH keyname value …//向列表右边添加一个或多个元素，返回增加后列表的长度\n2.从列表中弹出第一个元素\nLPOP keyname//从列表左边弹出\nRPOP keyname//从列表右边弹出\n3.获取列表中元素的个数\nLLEN keyname\n4.获取列表片段\nLRANGE keyname start stop// 0 2 代表开始3个， -3 -1代表末尾三个\n5.删除列表中前count个值为value的元素，返回实际删除元素的个数\nLREM keyname count value//count&gt;0时，从左边开始\n//count&lt;0时，从右边开始\n//count==0时，删除所有的\n6.返回指定索引的元素\nLINDEX keyname index\n7.更改指定索引处的值\nLIST keyname index value\n8.删除指定索引范围之外的所有元素\nLTRIM keyname start end\n9.插入元素操作\nLINSERT keyname BEFORE pivot value//这条命令首先会在列表中从左到右查找值为pivot的元素，然后将value插入它的前面\nLINSERT keyname AFTER pivot value//这条命令首先会在列表中从左到右查找值为pivot的元素，然后将value插入它的后面\n10.数据转移\nRPOPLPUSH source destination//命令会从键source列表的右边弹出第一个元素然后加入到destination的左边返回这个元素的值\n四.集合类型\n集合（Set）用于存储不重复的数，它常用的操作是向集合中加入或删除元素，判断某个元素是否存在等，由于集合类型在Redis内部是使用值为空的散列集实现的，所以这些操作的时间复杂度为1，最方便的是多个集合之间还可以进行并集，交集和差集运算。\n1.向集中添加一个或多个值\nSADD keyname vlaue1 value2 …\n2.从集中删除一个或多个元素\nAREM keyname value1 vlaue2 …\n3.获取集合中的所有元素\nSMEMBERS keyname\n4.判断元素是否存在集合中\nSISMEMBER key value\n5.集合间进行集运算\nSDIFF keyname1 keyname2 …//差集运算：返回keyname1-keyname2-…后的集合\nSINTER keyname1 keyname2…//交集运算\nSUNION keyname1 keyname2…//并集运算\n6.返回集中元素个数\nSCARD key\n7.将集运算后的结果存入新集中\nSDIFFSTORE newkey keyname1 keyname2 …//将keyname1 ,keyname2…等结果的差集存入newkey中\nSUNIONSTORE newkey keyname1 keyname2 …//并集\nSINTERSTORE newkey keyname1 keyname2 …//交集\n8.随机获取count个元素\nSRANDMEMBER keyname count\n9.从集合中随机弹出一个元素\nSPOP key\n五.有序集合类型\n有序集合类型是在集合类型的基础上为每个元素都关联了一个分数，这使得我们不仅可以完成插入，删除和判断元素是否存在等集合类型支持的操作，还能够进行有序的一些操作。\n有序集合类型和列表类型对比\n1.二者都是有序的\n2.二者都可以获得某一范围的元素\n3.列表类型通过链表实现，获取接近两端的数据速度极快，访问中间位置数据速度相对慢一点。\n有序集合类型是使用散列表和跳跃表实现的，即使读取位于中间部分的数据速度也很快（logN）\n4.列表中不能简单地调整某个元素的位置，但是有序集合可以。\n5.有序集合比列表更耗费内存。\n操作命令\n1.向有序集合中加入一个或多个键值对\nZADD key score1 member1 score2 member2…\n2.获取指定元素的分数\nZSCORE key member\n3.依据分数从小到大返回指定闭区间索引的元素\nZRANGE key start stop\n4.依据分数从大到小返回指定闭区间索引的元素\nZREVRANGE key start stop\n5.获取指定分数范围的指定个数的元素\nZRANGEBYSCORE key min max LIMIT offset count\n6.增加某个元素对应的分数\nZINCRBY key increment member //member对应的分数加increment ，返回加后的分数\n7.获取集合中元素的数量\nZCARD key\n8.返回指定分数范围内的元素个数\nZCOUNT key min max\n9.删除一个或多个元素\nZREN key memeber …\n10.按照排名范围内删除元素\nZREMRANGEBYRANK key start stop//删除在指定范围内的所有元素，返回删除的元素数量\n12.按照分数范围删除\nZREMRANGEBYSCORE key min max\n13.获取元素排名\nZRANK key member//从小到大\nZREVRANK key member//从大到小\n","tags":["Redis学习"]},{"title":"3.Redis事务处理","url":"/article/Database-Redis-3-Redis%E5%AD%A6%E4%B9%A0%EF%BC%9A%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/","content":"1.什么是事务？\n简单来说，事务是一组命令的集合，一个事务中的所有命令要么全部执行，要么全不执行。\nRedis保证一个事务中的所有命令要么都执行，要么都不执行，它还能保证一个事务内的命令依次执行而不被其他命令插入。\n简单使用如下：\n\nmulti告诉Redis:下面我给你发的命令属于同一事务，先不要执行，存起来。Redis返回OK。\nexec告诉Redis:我发完了，你可以执行之前存储的命令了\n注意：如果在发送exec命令前客户端断线了，则Redis会清空所有事务队列，事务中的所有命令都不会执行，如果在发送exec命令后断线，所有命令都会被执行。\n2.事务错误处理\n事务错误可分为两类：\n1）语法错误\n语法错误指命令不存在或者命令参数的个数不对。\n当发生语法错误时，执行exec命令后Redis就会直接返回错误，连语法正确的命令也不会执行。\n\n2）运行错误\n在命令执行时出现的错误，比如使用散列类型的命令操作集合类型的键，这种错误在实际执行之前Redis是无法发现的。\n如果事务里的一条命令出现了运行错误，事务里的其他命令依然会被执行（包括出错命令之后的命令）。\n\n注意：Redis的事务没有提供回滚功能（rollback），为此开发者必须事先在事务执行出错后自己将数据库复原回事务执行之前的状态。\n3.WATCH命令介绍\n我们已经知道在一个事务中只有当所有命令都执行完后才能得到每个结果的返回值，可是在有些情况下我们需要先获得一条命令的值后才能进行下一条命令。\n为了解决这个问题我们需要WATCH:WATCH命令可以监控一个或多个键，一旦其中有一个键在事务之前被修改，之后的事务就不会执行，监控一直持续到EXEC命令\n\n执行EXEC命令会取消对所有键的监控，如果不想执行事务中的命令来取消监控，也可以使用UNWATCH命令来取消监控。\n注意：由于WATCH命令的作用只是被监控的键值被修改后阻止之后一个事务的执行，而不能保证其他客户端不修改这一键值，所以我们需要在EXEC执行失败后重新执行整个函数。\n","tags":["Redis学习"]},{"title":"4.Redis过期时间和排序","url":"/article/Database-Redis-4-Redis%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E5%92%8C%E6%8E%92%E5%BA%8F/","content":"一.过期时间\n在实际的开发中我们经常遇到一些有时效的数据，在Redis中我们应该怎样处理这些数据呢？\n下面来学习：\n1.EXPIRE命令\n我们可以使用它来设置一个键的过期时间，到时间后Redis会自动删除它。\n例如\nSET session:23 uid1314\nEXPIRE session:23 30//单位为秒\n\n上面返回1表示执行成功，如果返回0则表示键不存在或者失败。\n2.TTL命令\n如果我们想知道我们设置自动删除的键还有多久会删除，我们可以用TTL来查询：\n\n当键不存在时会返回-2 ：\n\n返回-1则表示该键永久存在：\n\n3.PERSIST命令\n如果我们想取消键的过期时间设置（就是将键设置为永久的）,我们可以用这个\n\n注意：除了PERSIST命令外，我们还可以用SET或者GETSET命令在为键赋值的同时也清除过期时间设置，也可以用EXPIRE为键重新设置过期时间。\n细节：如果使用WATCH命令监视了一个拥有过期时间的键，该键时间到期自动删除并不会被WATCH命令认为该键被改变\n4.应用场景\n1）.实现访问频率限制\n例如我们要限制每分钟每个用户最多只能访问100个页面，基本的思路就是：\na.对每一个用户使用一个名为rate.limiting:用户IP 的字符串类型的键。\nb.每次用户访问则使用INCR命令递增该键的键值，如果递增后的值为1，则同时还要设置改键的过期时间为1分钟。\nc.这样每次用户访问页面时都增加改键的键值，如果达到100就提示用户稍后访问，知道该键被删除，用户就又可以重新访问了。\n我们开始也许会认为上面的思路没啥问题，但当我们仔细的想想，会发现这样一种情况：\n某个用户在第1秒访问1次，在第60秒访问99次，改键被删除，然后再进行访问在第1秒访问100次**，这样的话，该用户在2秒访问了199次！！**\n我们如果需要精确的控制的话，我们需要记录下用户每次访问的时间，因此对每个用户：\na.我们使用一个列表类型的键来记录它最近100次访问网页的时间。\nb.一旦键中的元素超过100个，就判断时间最早的元素距现在的时间是否小于1分钟：\n如果是则表示用户最近1分钟的访问次数超过了100次。\n如果不是则将现在的时间加入到列表中，同时把最早的元素删除。\n2）实现缓存\n为了提高网站的负载能力，常常需要将一些访问频率较高但对CPU或IO资源消耗较大的操作结果缓存起来，相当于一个Cache，并希望让这些缓存过一段时间失效，这时候我们就可以用过期时间来实现。\n例如：\n一个成绩排名网站要对所有用户的成绩汇总排名，并在首页上显示前10名的学生姓名。\n由于计算过程比较消耗资源，于是将结果使用一个Redis的字符串缓存起来。\n但由于用户的成绩总在不断变化，需要每隔两个小时就重新计算排名，这时候我们可以通过给键设置过期时间。\n每次用户访问首页的时候程序先查询缓存键是否存在，如果存在则直接使用缓存的值，否则重新计算并将计算结果赋给该键并设置过期时间。\n注意：\n但是我们不能滥用这个技术，特别是当服务器内存有限时，如果大量使用缓存键且过期时间设置的过长就会导致Redis占满内存，另一方面如果为了防止Redis占用内存过大而将缓存的过期时间设置的过短又会导致缓存命中率降低，所以：如何为Redis缓存键设置过期时间是对我们的能力的一种考验\n一般的做法为：限制Redis能够只用的最大内存，并让Redis按照一定的规则淘汰不需要的缓存键。\n具体的设置方法为：修改配置文件的maxmemory参数，限制Redis最大可用内存大小，当超过了这个限制时Redis会依据maxmemory-policy参数指定的策略来删除不需要的键直到Redis占用的字节内存小于指定内存。\n删除键的规则有如下：\n规则说明volatile-lru使用LRU算法删除一个键（只对设置了过期时间的键） allkeys-lru 使用LRU算法删除一个键 volatile-random 随机删除一个键（只对设置了过期时间的键） allkeys-random 随机删除一个键volatile-ttl删除过期时间最近的一个键noeviction不删除键，只返回错误\nLRU算法的思想是：删除最近最少使用的缓存\n二.排序\n1.SORT命令\n除了使用有序集合之外我们还可以借助Redis提供的SORT命令来解决一些问题。\nSORT命令可以对列表类型，集合类型和有序集合类型键进行排序，并且可以完成与关系型数据库中的连接查询类似的任务。\n1）对列表排序\n\n2).对有序集合排序（注意在对有序集合进行排序时会忽略分数，只针对元素自身的值进行排序）\n\n除了对数字排序以外，还支持字符排序（注意和上面的略有不同）：\n\n还可以降序排序：\n\n2.LIMIT命令\n和MySQL一样限制查询（从0开始)\n\n3.BY参数\nBY参数可以让我们的SORT命令将不再依赖元素自身的值进行排序，而是对每个元素使用元素的值替换参考键中第一个“*”并获取其值，然后依据该值对元素排序：\n\n4.GET参数\nGET参数不影响排序，它的作用是使SORT命令的返回结果不再是元素自身的值，而是GET参数中指定的键值。\n\n5.STORE参数\n默认情况下SORT会直接返回排序结果，如果希望保存排序结果，可以使用STORE参数\n\n三.性能优化\nSORT是Redis中最强大且最复杂的命令之一，使用时一定要谨慎！！\n这个命令的时间复杂度为 O(n+mlog(m)) , 其中n为排序集合元素个数，m为要返回的元素个数，所以我们在使用时一定要让n和m尽可能的小。\n我们可以：\n1）尽可能减少待排序键中元素的个数n\n2）使用LIMIT来减少m\n3）如果要排序的数据量较大，尽可能使用STORE参数将结果缓存\n","tags":["Redis学习"]},{"title":"5.Redis消息通知","url":"/article/Database-Redis-5-Redis%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5/","content":"一.任务队列\n1.什么是任务队列？\n我们可以从字面意思去理解：传递任务的队列。与任务队列进行交互的实体有两种，一种是生产者，负责向队列中添加任务，一类是消费者，负责从队列中提取任务并执行。\n2.使用任务队列的好处\n1）松耦合：生产者消费者无需知道彼此的实现细节，只需要约定好任务的描述格式就行了。\n2）易于扩展：我们可以扩展出多个消费者分布在不同的服务器中，从而可以降低单台服务器的性能压力，如图：\n\n3.Redis中实现任务队列\n1）BRPOP命令\nBRPOP命令接收两个参数，第一个是键名，第二个是超时时间（单位s）,当超过了此时间仍然没有获得新元素就会返回nil。 如果设置超时时间为0，则表示不限时等待（如果没有新元素加入永久等待）\n使用实例：\n首先我们在一个命令窗口A中设置任务对列：\n\n然后在另一个窗口B向queue中添加元素：\n\n这时我们看到窗口A中出现下面消息：\n\n上面就是任务队列的实例演示过程，除了BRPOP（从右边取元素）之外，Redis还提供了BLPOP，顾名思义，就是从左边取元素。\n4.优先级队列\nBRPOP命令可以同时接收多个键，如果所有键都没有元素则阻塞，如果其中一个键有元素则会从该键中弹出元素，如果多个键都有元素，则按照从左到右的顺序取第一个键中的一个元素。我们可以利用这个特性设置优先级任务。\n5.发布/订阅 模式\n除了实现任务队列之外，Redis还提供了一组命令可以让开发者实现 发布/订阅 模式。\n这个模式有两种角色：发布者和订阅者，发布者每次发布消息后都会通知订阅者。\n1)PUBLISH命令和SUBSCRIBE命令\n首先我们在一个命令窗口订阅一个频道：\n\n然后再另一个窗口发布该频道的一个消息：\n\n我们可以看到：\n\n按照规则订阅：\nPSUBSCRIBE命令\n它可以定义订阅的规则，既可以一次订阅多个符合匹配表达式的频道：\n\n它可以匹配channel.1和channel.10等等。\n退定命令：\nUNSUBSCRIBE命令\n\nPUNSUBSCRIBE命令\n\n","tags":["Redis学习"]},{"title":"6.Redis空间节约","url":"/article/Database-Redis-6-Redis%E8%8A%82%E7%9C%81%E7%A9%BA%E9%97%B4/","content":"我们知道Redis是一个基于内存的数据库，所有的数据都存储在内存中，所以我们需要学习如何优化存储，用最小的代价得到最好的性能。\n在使用Redis的过程中，我们可以使用下面的方式来节省空间：\n一.精简键名和键值\n这是一种很直观的减少内存占用的方式，这种方式的目标是：用最简洁的名称表达最好的效果。切忌为了单纯的节省空间而使用难以理解的键名。\n二.内部编码优化\n1.概念了解\n这种方式是根据Redis内部编码规则来节省空间，Redis为每种数据类型都提供了两种内部编码方式，我们以散列类型为例：\n散列类型是通过散列表实现的，它的优势是在数据很多的时候以优越的时间复杂度查找指定数据。\n但是当键中的元素很少的时候，它的性能并不比普通的查找方式高所以这种情况下Redis会采用一种更为紧凑但性能较差的普通内部编码方式。\n内部编码方式的选择对于开发者来说是透明的，Redis会根据实际情况自动调整，当键中元素变多时Redis会自动将该键的内部编码方式转换为散列表。\n如果想查看一个键的内部编码方式我们可以使用OBJECT ENCODING命令来执行：\n\n2.基本知识了解\nRedis的每个键值都是使用一个redisObject结构体保存的，redisObject的定义如下：\ntype struct redisObject{\nunsigned type:4; /表示键值的数据类型\nunsigned notused:2; /\nunsigned encoding:4; /表示Redis键值的内部编码方式\nunsigned lru:22;/\nint refcount;/该键被引用的数量\nvoid *ptr;\n}robj;\n其中type字段表示的键值的数据类型取值可以是如下内容：\n#define REDIS_STRING 0\n#define REDIS_LIST 1\n#define REDIS_SET 2\n#define REDIS_ZSET 3\n#define REDIS_HASH 4\nencoding字段表示的就是Redis键值的内部编码方式。\n3.下面我们针对每种数据类型分别学习其内部编码规则及优化方式：\n1）字符串类型\nRedis使用一个sdshdr类型的变量来存储字符串，而redisObject的ptr子段指向的是改变量的地址，\nsdshdr定义如下：\nstruct sdshdr{\nint len;\nint free;\nchar buf[];\n}\n其中len表示字符串长度，free表示buf中的剩余空间，buf存储字符串内容。\n所以当执行SET key foobar时，存储键值需要的空间是：\nsizeof(redisObject)+sizeof(sdshdr)+strlen(“foobar”)=30字节\n而当键值内容可以用一个64位有符号整数表示时，Redis会将键值转换成long类型来存储，例如：SET key 123456, 它所占用的空间比前者要小。\n由此可见，使用字符串类型存储数字比存储字符串要省空间。 int 比 raw编码方式省空间。\n在Redis 3.0中新加了一中编码方式，embstr方式，这种方式与raw类似，都是基于sdshdr方式实现，只不过sdshdr的结构体与其对应的分配在同一块连续的内存空间中。这种方式便于分配和释放内存，当键值内容不超过39字节时，Redis会采用这种方式编码，但当对这种编码方式的键值进行任何修改操作时，Redis会将其转换为raw编码方式。\n2）散列类型\n散列类型的内部编码方式可能是 ：\nREDIS_ENCODING_HT(基于hash存储，适合元素量较多的集合)\nREDIS_ENCODING_ZIPLIST（基于链表存储，适合元素较少的集合）\n我们可以在配置文件中定义使用REDIS_ENCODING_ZIPLIST方式编码散列类型的时机，在配置文件中配置下面属性：\nhash-max-ziplist-entries 512\nhash-max-ziplist-value 64 时，\n当散列类型键的字段数少于hash-max-ziplist-entries参数值且每个字段名和字段值的长度都**小于** hash-max-ziplist-value参数值（单位为字节）时，Redis就会使用REDIS_ENCODING_ZIPLIST来存储该键，否则使用REDIS_ENCODING_HT. **每当键值变更后Redis都会自动判断是否满足条件来完成转换。**\n3）列表类型\n列表类型的内部编码方式：\nREDIS_ENCODING_LINKEDLIST(基于双向链表)\nREDIS_ENCODING_ZIPLIST（和散列类型的一样）\n它们之间的转换方式和散列类型的一样，同理。\nREDIS_ENCODING_QUICKLIST:它是前两者的结合，其原理是将一个长列表分成若干个以链表形式组织的ziplist，从而达到减少空间占用的同时提升了REDIS_ENCODING_ZIPLIST编码的性能。（最新的Redis默认使用它）\n4）集合类型\n集合类型的内部编码方式为：\nREDIS_ENCODING_HT（无序）\nREDIS_ENCODING_INTSET（有序）\n当集合中的所有元素都是整数且元素的个数小于配置文件中的set-max-intset-entries(默认512)时Redis会使用REDIS_ENCODING_INTSET编码方式存储该集合，否则使用REDIS_ENCODING_HT。\nREDIS_ENCODING_INTSET编码存储结构体inset的定义如下：\ntypedef struct intset{\nuint32_t encoding;\nuint32_t length;\nint8_t contents[];\n}intset;\n其中contents存储的就是集合中的元素值，根据encooding的不同，每个元素占用的字节数不同，默认的encoding是INTSET_ENC_INT16(两个字节)，当新增加的整数元素无法用两个字节表示时，Redis会用INTSET_ENC_INT32(4个字节)，再者就用INTSET_ENC_INT64(8个字节)\n这种编码方式以有序的的方式存储元素。\n5）有序集合类型\n有序集合类型的内部编码方式可能是：\nREDIS_ENCODING_SKIPLIST\nREDIS_ENCODING_ZIPLIST\n同样我们可以在配置文件中定义使用：\nzset-max-ziplist-entries 128\nzset-max-ziplist-value 64\n具体是转换和散列类型一样，不赘述。\n当编码方式是REDIS_ENCODING_SKIPLIST时，Redis使用散列表和跳跃列表两种数据结构来存储有序集合类型的键值。\n其中散列表用来存储元素值于元素分数的映射关系以实现O(1)时间复杂度的ZSCORE等命令。\n跳跃表用来存储元素的分数及其到元素值的映射以实现排序的功能，其中Redis中对跳跃列表的实现进行了几点修改，包括：允许跳跃表中的元素（分数）相同，为跳跃链表每个节点增加了指向前一个元素的指针以实现倒序查找。\n总结：我们除了优化键值的应用格式外，还可以通过编码方式对存储空间进行优化。\n","tags":["Redis学习"]},{"title":"1.识别性能问题和优化查询","url":"/article/Database-MySQL-PerformanceOptimization-1-%E8%AF%86%E5%88%AB%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2/","content":"1.如何找到运行缓慢的SQL语句\nshow full processlist\n\n其中\\G是为了让输出结果垂直打印。\n这个命令将列出数据库历史操作中的语句的花费时间的倒叙排序。\n2.确认低效查询\nexplain select * from table_name;\n假设第一步中确认了select * from table_name;花费了很长时间，我们就可以用上面的命令查看这个sql执行的一些细节。\n\n其中我们需要关注的是：rows的大小表示此次查询涉及的行数。 key表示所用的主键，null代表没使用。\n3.优化查询\n我们可以通过查看表的信息来查看是否有索引可被使用。\nshow create table booktuijian;\n\n可以看到，没有主键。\n这时，我们可以选择添加索引，但要知道，添加索引可能会耗费大量时间(大数据量的表添加索引非常耗时)，这个行为在生产环境中是个非常危险的行为。\n添加索引的语句为：\nALTER TABLE table_name ADD INDEX(clomun);\n当表的数据量巨大时，这条语句慎用！！\n","tags":["MySQL性能优化"]},{"title":"2.SQL分析命令学习","url":"/article/Database-MySQL-PerformanceOptimization-2-SQL%E5%88%86%E6%9E%90%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/","content":"1.EXPLAIN\nEXPLAIN SQL语句\n这个命令将为我们展示指定sql的查询执行计划，也就是，用它让mysql告诉我们它准备怎么执行这条语句。\n\n通过上面这些元素，我们可以清晰的了解mysql将如何执行这条sql，其中rows是大致将要扫描的行数，key表示用到的索引（null表示没用到索引）\n\n2.SHOW CREATE TABLE\n通过这条命令我们可以查看指定表的建表语句\n\n主要看的就是表中字段的数据类型，使用的存储引擎，以及索引信息。\n\n3.SHOW INDEXES\n用户可以用这个命令查询特定表的索引信息。\n\n4.SHOW TABLE STATUS\n这个命令可用于查看表的基本信息。\n\n","tags":["MySQL性能优化"]},{"title":"3.深入理解MySQL索引原理","url":"/article/Database-MySQL-PerformanceOptimization-3-MySQL%E7%B4%A2%E5%BC%95%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql%E7%9A%84%E7%B4%A2%E5%BC%95/","content":"创建合适的索引是SQL性能调优中的关键技术之一。\n1.MySQL索引用法\n1.1 保持数据唯一性\nMySQL用主键和唯一键来执行每个表中存储数据的唯一性等级。\n主键：\n\n\n每个表中只能有一个主键\n\n\n主键不能为空\n\n\n通过主键可以获取表中任意特定的行\n\n\n如果定义了AUTO INCREMENT列，那么此列必须是主键的一部分\n\n\n唯一索引：\n\n\n一张表可以有多个唯一索引\n\n\n唯一索引可以包含空值，并且每个空值都是唯一的（但是一般禁止使用空值，即数据库中应该避免空值存在）\n\n\n唯一索引和主键的存在避免了重复的值被插入，即如果唯一键或重复键的值在数据库中已存在，那么重复插入将会报错。\n\n\n1.2 优化数据访问性能\n索引可以让优化器在执行查询的时候不必检索表中所有数据。通过需要访问行的数目，可以显著提高查询速度。这时索引普遍的用途\n1.3 改进表之间的连接操作\n除了在给定表上限制需要读取的数据外，索引的另一个主要的用途就是快捷高效的在相关的表之间做连接操作。\n如前所述，在需要连接的列上使用索引也可以显著的提升性能，并可以在另一个表中快速找到一个匹配的值。\n1.4 对结果进行排序\nmysql索引把数据存储在一个有序的表格中。 如果希望SELECT语句的结果是有序的，那么我们可以使用索引来控制。\n虽然通过ORDER BY关键字可以对任意的SELECT结果进行排序，如果在需要排序的列上没有找到索引，mysql一般会对获取的表进行内部排序。\n然而在高并发系统中每秒需要对成千上万条单独的查询结果进行排序，我们可以通过预先建立索引来提升性能，此后这些查询结果顺利成章按顺序存放在索引中了。\n1.5 简化聚合数据操作\n索引还可以作为一种更方便的计算聚合结果的工具，聚合索引就可以。\n2.关于MySQL存储引擎\n存储引擎拥有如下特性：\n\n事务性和非事务性\n持久性和非持久性\n表锁和行锁\n索引数据结构：B-树，B+树，散列树，R-树\n聚集索引和非聚集索引\n主码索引和非主码索引\n数据压缩\n全文索引能力\n具有代表性的存储引擎：\n\nMyISAM是一种非事务性的存储引擎，它是mysql5.5之前的默认存储引擎版本。\nInnoDB是目前最流行的事务性存储引擎，5.5版本后成为默认存储引擎。\nMemory存储引擎，故名思意，是一种基于内存的，非事务性，非持久性的存储引擎。\n\n\n\n3.索引数据结构\n3.1 B树\n什么是B树：\n简单来说，B树是为磁盘或其他直接存取的辅助存储设备而设计的一种平衡搜索树。\nB树和普通树的差别在于B树的结点可以有很多孩子，可以有1个，也可以有1000个，其大致结构如下：\ngraph TD\n    subgraph \"B树结构示例（3阶）\"\n        A[根节点30, 60] --&gt; B[左子树10, 20]\n        A --&gt; C[中子树40, 50]\n        A --&gt; D[右子树70, 80, 90]\n\n        B --&gt; B1[5, 7]\n        B --&gt; B2[15, 18]\n        B --&gt; B3[25]\n\n        C --&gt; C1[35]\n        C --&gt; C2[45]\n        C --&gt; C3[55]\n\n        D --&gt; D1[65]\n        D --&gt; D2[75]\n        D --&gt; D3[85]\n        D --&gt; D4[95]\n    end\n此树中有两类节点类型：内部节点和叶子节点。\n其中叶子节点只是用于存储数据，内部节点除了存储数据，还包含了指向孩子的指针。\n从上面可以看出，B树从数据分布上看是严格有着顺序分布的，例如我们想要找到45这个节点：\n\n首先用45和根节点的30，60比较，发现30&lt;45&lt;60,所以它应该在中子树下面\n然后通过比较中子数的关键字，发现40&lt;45&lt;50,定位到，它应该是中子树的第二个孩子节点\n\n3.2 B+树\nB+树的主要特点是：\n\n内部节点：仅存储索引键，不存储实际数据\n叶子节点：存储键值和实际数据，通过双向链表连接\n平衡性：所有叶子节点在同一层\n\n例如：\ngraph TD\n    subgraph \"B+树结构（3阶）\"\n        Root[根节点索引：30, 60] --&gt; Child1[内部节点10, 20]\n        \n        Root --&gt; Child2[内部节点30, 40, 50]\n        Root --&gt; Child3[内部节点60, 70]\n\n        Child1 --&gt; Leaf1[\"叶子节点15:data5, 7:data7\"]\n        Child1 --&gt; Leaf2[\"叶子节点210:data10, 15:data15\"]\n        Child1 --&gt; Leaf3[\"叶子节点320:data20, 25:data25\"]\n        \n        Child2 --&gt; Leaf4[\"叶子节点430:data30, 35:data35\"]\n        Child2 --&gt; Leaf5[\"叶子节点540:data40, 45:data45\"]\n        Child2 --&gt; Leaf6[\"叶子节点650:data50, 55:data55\"]\n        \n        Child3 --&gt; Leaf7[\"叶子节点760:data60, 65:data65\"]\n        Child3 --&gt; Leaf8[\"叶子节点870:data70, 75:data75, 80:data80\"]\n    end\n其中所有叶子节点豆通过双向指针进行连接，图例如下：\ngraph\n    subgraph name\n       direction LR\n       Leaf1[\"叶子节点15:data5, 7:data7\"] --双向--&gt; Leaf2[\"叶子节点210:data10, 15:data15\"]\n       Leaf2--双向--&gt; Leaf3[\"叶子节点320:data20, 25:data25\"]\n       Leaf3--双向--&gt;Leaf4[\"叶子节点430:data30, 35:data35\"]\n       Leaf4--双向--&gt;Leaf5[\"叶子节点540:data40, 45:data45\"]\n       Leaf5--双向--&gt;Leaf6[\"叶子节点650:data50, 55:data55\"]\n       Leaf6--双向--&gt;Leaf7[\"叶子节点760:data60, 65:data65\"]\n       Leaf7--双向--&gt;Leaf8[\"叶子节点870:data70, 75:data75, 80:data80\"]\n       Leaf8--双向--&gt;Leaf1\n    end\n3.3 Hash索引\n顾名思义,就是通过Hash算法计算出索引的存储坐标，进行查询时直接计算出存储坐标从而直接查询数据，原理参考HashMap.\n\n使用散列索引最头疼的问题在于散列函数始终无法特地解决散列冲突的问题。\n解决散列冲突的方法可以去看相应的算法书籍。 现在一般的做法是一定长途的散列冲突使用链表法解决，如果多的，则将链表转换成树进行优化。\nHash索引的有点在于查询一条数据时时间复杂度为1，性能很好，但是，不利于范围查询。\n","tags":["MySQL性能优化"]},{"title":"4.MySQL时间相关函数","url":"/article/Database-MySQL-PerformanceOptimization-4-MySQL%E4%B8%AD%E4%B8%8E%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0/","content":"1.NOW() , CURRENT_TIMESTAMP() , SYSDATE()\n1.1 作用\n这三个函数的作用都是返回当前系统的时间，\n例如：\nmysql&gt; select now(),current_timestamp(),sysdate();+---------------------+---------------------+---------------------+| now()               | current_timestamp() | sysdate()           |+---------------------+---------------------+---------------------+| 2026-01-20 14:52:15 | 2026-01-20 14:52:15 | 2026-01-20 14:52:15 |+---------------------+---------------------+---------------------+1 row in set (0.00 sec)\n1.2 那他们之间的差别是什么呢？\n我们先看下面的例子\n\n我们可以看到，当运行sleep（2）让其mysql等待两秒后，sysdate()函数打印的是2秒后的时间，而now（）和current_timestamp()打印的是2秒前的时间。\n所以我们可以总结：\n\n\nnow()和current_timestamp()函数作用相同。\n\n\nsysdate()函数返回的是实时系统时间，而now（）返回的是执行sql时的开始时间。\n\n\n2.时间加减函数\ndate_add(date,interval n day) ,date_sub(date,interval n day)\n如下：\n\n时间加减的问题常常离不开闰月问题：\n1）如果是闰月，那么DATE_ADD函数将如何处理呢？\nMySql中默认是这样处理的：如果目标年份是闰月，那么返回的日期为2月29日，如果不是闰月，那么返回的日期是2月28日，如下：\n\n我们可以看到date_add()中第二个参数是可以变化的： 除了可以使用day，year，也可以使用：second，minute，hour，week，month，microsecond等。\n3.DATE_FORMAT函数\n这个函数的作用就是按照用户需求格式化打印出日期\n\n","tags":["MySQL性能优化"]},{"title":"5.SQL执行顺序","url":"/article/Database-MySQL-PerformanceOptimization-5-MySql%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%EF%BC%88%E9%80%BB%E8%BE%91%E4%B8%8E%E7%89%A9%E7%90%86%EF%BC%89/","content":"重点：SQL语言的逻辑执行顺序和普通的编程语言不同，下面进行详细学习\n1.逻辑查询处理\n首先创建一张名为customers的表\nCREATE TABLE `customers` (`customer_id` varchar(10) NOT NULL,`city` varchar(10) NOT NULL,PRIMARY KEY (`customer_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci\n插入数据：\ninsert into customers select '163','HangZhou';insert into customers select '9you','ShangHai';insert into customers select 'TX','HangZhou';insert into customers select 'baidu','HangZhou';\n然后创建一个名为orders的表：\ncreate table orders(order_id int not null auto_increment,custormer_id varchar(10),primary key(order_id))engine=innodb;\n插入数据：\ninsert into orders select null,'163';insert into orders select null,'163';insert into orders select null,'9you';insert into orders select null,'9you';insert into orders select null,'9you';insert into orders select null,'TX';insert into orders select null,null;\n2. 执行完整的SQL语句\nSELECT c.customers_id,count(o.order_id) AS total_ordersFROM customers as cLEFT JOIN orders as oON c.customer_id=o.customer_idWHERE c.city='HangZhou'GROUP BY c.customer_idHAVING count(o.order_id)&lt;2ORDER BY total_orders DESC;\n在上面语句，各个命名的执行顺序如下\n\nFROM：首先对FROM子句中的左表和右表执行笛卡尔积产生虚拟表VT1\n\n\n\nON: 然后对虚拟表VT1应用ON筛选，只有符合ON条件的行才会被插入虚拟表VT2中：\n\n\n\n\nJOIN: 如果指定了OUTER LEFT ,那么保留表中未匹配的行作为外部行添加到虚拟表VT2中，产生虚拟表VT3。\n\n如果FROM子句包含两个以上的表，则对上一个连接生成的结果表VT3和下一个表重复执行步骤1）到步骤3）,直到处理完所有的表为止。\n\n\nWHERE: 对虚拟表VT3中应用WHERE过滤条件，只有符合条件的行才会被插入VT4中\n\n\n\n\n\nGROUP BY:根据GROUP BY中子句中的列，对VT4中的记录进行分组操作，产生VT5\n\n\n\nCUBE|ROLLUP: 对表VT5进行CUBE或ROLLUP操作，产生VT6.\n\n\n由于这一步上述例子没有所以跳过。VT6=VT5\n\n\nHAVING: 对虚拟表中VT6应用HAVING过滤器，只有符合条件的记录才被插入VT7中。\n\n\n\nSELECT: 执行SELECT操作，选择指定的列，插入到虚拟表VT8中。\n\n\n\nDISTINCT: 去除重复数据，产生虚拟表VT9\n\n\n\n\nORDER BY :将虚拟表VT9中的记录按照指定列进行排序操作，产生虚拟表VT10\n\n\n\nLIMIT:取出指定行记录，产生虚拟表VT11，返回给用户。\n\n\n上述11个步骤就是一个完整的SQL中各个子句的运行步骤和最终查询结果的由来。\n2.物理查询处理\n第一节介绍了执行查询应该得到什么样的结果，但是数据库本身也许并不会完全按照逻辑查询的步骤进行查询。\n我们知道Mysql数据结构中存在 分析器和优化器两个组件 ，分析器的工作就是分析SQL语句，而优化器的工作就是对这个SQL进行优化，\n选择一条最优的途径来选取数据，但是必须保证物理查询的结果和逻辑查询的结果是一致的。\n我们现在只需知道：物理查询会根据索引来进行优化，物理查询可以利用表上的索引来缩短SQL语句运行的时间，以此来提高数据库的整体性能。\n3.SQL执行顺序总结\ngraph TB\n    A[\"📋 SQL原始语句\"] --&gt; B[1. FROM/JOIN确定数据源]\n    B --&gt; C[2. ON连接条件过滤]\n    C --&gt; D[3. OUTER JOIN 补充NULL行]\n    D --&gt; E[4. WHERE行级过滤]\n    E --&gt; F[5. GROUP BY分组]\n    F --&gt; G[6. HAVING组级过滤]\n    G --&gt; H[7. SELECT选择列/计算]\n    H --&gt; I[8. DISTINCT去重]\n    I --&gt; J[9. ORDER BY排序]\n    J --&gt; K[10. LIMIT/OFFSET分页]\n    K --&gt; L[\"📊 最终结果集\"]","tags":["MySQL性能优化"]},{"title":"6.MySQL缓冲池","url":"/article/Database-MySQL-PerformanceOptimization-6-MySql%E7%BC%93%E5%86%B2%E6%B1%A0%E5%AD%A6%E4%B9%A0/","content":"数据库的物理分类\n根据存储介质的不同，一般将数据库分为三种：\n\n基于磁盘的数据库系统（最慢）\n基于内存的数据库系统（最快，最贵）\n混合型数据库系统（折中选择）\n\n1.基于磁盘的数据库系统\n最为常见，比如MySQL， Oracle，SQL Server等数据库都是基于磁盘的数据库系统。\n毫无疑问，基于内存的数据库系统的访问速度非常之快，所以为了让内存在数据库中发挥作用，基于磁盘的数据库系统中存在一个机制：\n缓冲池\n1.1 何为缓冲池？\n缓冲池就是一块内存区域，其作用是将磁盘上读取的指定大小数据（块），\n放入这个内存区域中，当再此查询该数据时，直接从内存中取而不是访问磁盘。\n对于写操作，数据库将页读入缓冲池中，然后在缓冲池中对其进行写操作，之后由系统异步同步到磁盘上即可。\n对于缓冲池的维护一般采用最近最少使用算法进行维护。\n由此可见：缓冲池的大小决定了数据库的性能，若数据库中的数据可以完全存放于缓冲池中，则可以认为这时数据库的性能是最优的！！\n所以，对于缓冲池大小的确定非常之重要！！！\n1.2 如何查看mysql的缓冲池大小？\n// 返回单位为字节show variables like &#x27;innodb_buffer_pool_size&#x27;;\nmysql&gt; show variables like &#x27;innodb_buffer_pool_size&#x27;;+-------------------------+-----------+| Variable_name           | Value     |+-------------------------+-----------+| innodb_buffer_pool_size | 134217728 |+-------------------------+-----------+1 row in set (0.01 sec)\n如果需要以G为单位查看可以用下面语句：\nselect @@innodb_buffer_pool_size/1024/1024/1024;\n1.3 如何修改缓冲池大小？\n缓冲池大小必须总是等于innodb_buffer_pool_chunk_size* innodb_buffer_pool_instances或为其倍数。\n如果将innodb_buffer_pool_size配置为不等于innodb_buffer_pool_chunk_size *innodb_buffer_pool_instances或不为其倍数，则缓冲池大小自动调整为等于innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances或不小于指定缓冲池大小的该乘积的倍数。\n如果想查看innodb_buffer_pool_instances的大小或innodb_buffer_pool_chunk_size大的小可以：\n\n我们可以直接用下面语句设置缓冲池大小：\nSET GLOBAL innodb_buffer_pool_size = 2147483648 \n修改完后记得同步配置文件，防止重启mysql时恢复到原来的大小：\nC:\\ProgramData\\MySQL\\MySQL Server 8.0下的my.ini文件\ninnodb_buffer_pool_size = 2147483648 #设置2G\n1.3 热点数据分析\n在现实的生产环境中，在大多数情况下经过线上的一段运行时间后，数据库大小通常大于内存大小，\n这时，我们则有必要确定热点数据，将热点数据存入内存中。\nInnodb buffer pool采用LRU的方式管理和淘汰数据，根据LRU算法，热点数据都会优先放入内存。\nLRU是Least Recently Used的缩写，即最近最少使用页面置换算法，是为虚拟页式存储管理服务的，\n是根据页面调入内存后的使用情况进行决策了。由于无法预测各页面将来的使用情况，\n只能利用“最近的过去”作为“最近的将来”的近似，因此，LRU算法就是将最近最久未使用的页面予以淘汰。\n","tags":["MySQL性能优化"]},{"title":"7.从算法角度理解B+树索引","url":"/article/Database-MySQL-PerformanceOptimization-7-%E4%BB%8E%E7%AE%97%E6%B3%95%E8%A7%92%E5%BA%A6%E5%AD%A6%E4%B9%A0mysql%E7%B4%A2%E5%BC%95/","content":"B+数索引是最为常见的，也是在数据库中使用最为频繁的索引，为了理解它，\n下面需要简单了解下基础知识：\n1.二分查找法\n二分查找法故名思意，就是一种查找方法，它的作用对象是有序数组。\n其基本思想如下：\n对有序数组采用跳跃式查找\n\n\n先以有序数组的中点位置为比较对象，如果要找的元素的值小于该中点元素，则将待查序列缩小为左半部分，否则为右半部分。 通过一次比较将区间缩小一半，直到找到为止。\n\n\n例如：对于 5，10 ，19 ， 21 ，31，37，42，48，50 ，53中查找42其过程如下：\n\n\n首先将42与31比较，发现42大于31，排除5，10，19，21，31\n\n\n然后将42与42比较，发现相等，找到了\n\n\n\n\n注意：在B+树索引中，B+树索引只能找到某条记录所在的页，需要再根据二分查找法来进一步找到记录所在页的位置。\n2.B+树\nB+树和二叉树，平衡二叉树都是经典的数据结构。B+树由B树和索引顺序访问方法演化而来，但是在实现过程中几乎没有使用B树的情况了。\n在这里我们以了解为主来进行学习（毕竟我们不是去手撕数据库对吧？？）\n因此在这里给出简单的定义：B+树是为磁盘或其他直接存取辅助设备设计的一种平衡二叉树。其特点是在B+树中，所有记录节点都是按键值的大小\n顺序存放在同一层的叶子节点，各叶子节点通过指针进行链接。\n下面来看一个B+树，其高度为2，每页可存放4条记录，叶子指针个数为5：\n\n从上面的图可以看出，所有记录都在叶子节点上，并且是顺序存储的，如果我们从最左边的叶子节点开始顺序遍历，可以得到所有键值的顺序是：\n5，10，15，20，25，30，50，50，55，60，65，75，80，90\n2.1 B+树的插入操作\n我们知道，如果想要维护顺序存储这一特性，就必须有相应的对策。\nB+树的三种情况，每种情况都可能导致不同的插入算法，如下图：\n\n下面通过实例来分析B+树的插入过程。 对于下面的的树：\n\n我们插入28这个键值，首先我们发现叶子页 25，30，null,null没有满，索引页也没有满，所以就直接插入得到下面的树：\n\n然后继续插入70这个键值，首先发现叶子页中65后和75前没有空余位置，叶子页满了，然后检查索引页，发现索引页还有位置，符合第二种情况。\n所以，将70插入叶子页后的情况为50，55，60，65，70.我们根据中间值60拆分叶子节点，得到下面的树：\n\n最后插入记录95，这符合第三种情况，即索引页和叶子页都满了，这时需要做两次拆分，如下图所示：\n\n我们可以看到，不管怎么变化，B+树总会保持平衡，但是为了保持平衡需要在插入新的键值后做大量的拆分页的操作，而B+树主要用于磁盘，\n因此页的拆分意味着磁盘的操作，应该在可能的情况下减少页的拆分。\n为此，B+树提供了旋转的功能：旋转发生在叶子页已经满了而其左右兄弟节点没有满的情况下。这时，B+树并不会急于进行拆分页的操作，\n而是将记录移到所在页的兄弟节点上。通常先判断左兄弟是否被用来做旋转操作，因此对于在插入键值70的时候，B+树并不会急于拆分叶子节点，\n而是进行旋转操作得到下面变化：\n\n\n可以看到，采用旋转操作使B+树减少了一次分页的操作，这时B+树的高度依然不变。\n2.2 B+树的删除操作\nB+树使用填充因子机制来控制树的删除变化，填充因子可以设置的最小值是50%。\nB+树的删除操作同样必须保证删除后叶子节点种的记录仍然是按顺序排列的，同插入一样，其删除操作同样需要考虑：\n\n下面我们对下图的B+树进行删除操作，首先删除键值为70的这条记录：\n\n这符合第一种情况，删除后可得：\n\n接着删除25，这也符合第一种情况，但是该值还是索引页中的值，因此在删除叶子页中的25后，还应该将25的右兄弟节点28更新到索引页中，最后得到：\n\n最后来看看删除60的情况。删除叶子页中键值为60的记录后，填充因子小于50%，这时需要做合并操作。\n同样，在删除索引页中的相关记录后需要做索引页的合并操作，最后得到下面：\n\n3.B+树索引\nB+树索引的本质就是B+树在数据库中的实现，而B+树索引在数据库中的一个特点就是高扇出性。（涉及的叶子节点多）\n例如在Innodb存储引擎中，每个页的大小为16KB（固定的）。\n因此在数据库中，B+树的高度一般都在2~4层，这就意味着查找某一键值最多只需要2到4次的IO操作。 （一般的磁盘IO操作每秒100次左右）\n2~4次的IO操作意味着只需0.02秒到0.04秒。\n在MySQL中，索引实在存储引擎层实现的，这就意味着每个引擎的B+树索引的实现方式可能是不同的，它取决于存储引擎本身的实现。\nB+树索引可以分为聚集索引和辅助索引。\n下面有一张表：\nCREATE TABLE T(a int not null,b varchar(800),c int not null,primary key(a),key idx_c(c))INSERT INTO T(a,b,c) values(1,&#x27;yanjd1&#x27;,-1);INSERT INTO T(a,b,c) values(2,&#x27;yanjd2&#x27;,-2);INSERT INTO T(a,b,c) values(3,&#x27;yanjd3&#x27;,-3);INSERT INTO T(a,b,c) values(4,&#x27;yanjd4&#x27;,-4);\n3.1 聚集索引\n聚集索引是根据主键创建的一颗B+树，聚集索引的叶子节点存放了表中的所有记录。\n对于表T而言，其聚集索引结构如下：\n\n3.2 辅助索引\n辅助索引是根据索引键创建的一颗B+树，与聚集索引不同的是，辅助索引的叶子节点仅存放索引键值以及该索引键值指向的主键。\n也就是说，如果通过辅助索引来查找数据，那么当找到辅助索引的叶子节点后，很有可能还需要根据主键值查找聚集索引来得到数据。\n这种查找方式又被称为书签查找，因为辅助索引不包含行记录的所有数据，这就意味着每页可以存放更多的键值，因此其高度也比聚集索引小。\n对于表T而言，其辅助索引结构如下：\n\n聚集索引和辅助索引之间的关系如下：\n\n4.MyIsam B+树索引\n在MyISAM存储引擎中，所有的行数据都存放于MYD文件中，其B+树的索引都是辅助索引，存放于MYI文件中。\n其PRIMARY KEY和其他索引的不同之处在于其必须是唯一的，并且不可为null，其索引页的大小默认为1KB.\n因为没有聚集索引，其索引页节点存放的键值不是主键值，而是在MYD文件中的物理位置。\n如下如图：\n\n","tags":["MySQL性能优化"]},{"title":"9.Cardinality学习","url":"/article/Database-MySQL-PerformanceOptimization-9-MySQL%E5%88%97Cardinality%EF%BC%88%E5%9F%BA%E6%95%B0%EF%BC%89/","content":"1.什么是Cardinality？\nCardinality中文译名为：基数。\n它在数据库中表示的意思就是数据库中某个表的某个列中不重复行的总条数。\n例如下表：t\nCREATE TABLE `t` (`a` int(11) NOT NULL,`b` varchar(800) DEFAULT NULL,`c` int(11) NOT NULL,PRIMARY KEY (`a`),KEY `idx_c` (`c`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci\n+-------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+--------------+------+-----+---------+-------+| a | int(11) | NO | PRI | NULL | || b | varchar(800) | YES | | NULL | || c | int(11) | NO | MUL | NULL | |+-------+--------------+------+-----+---------+-------+\n其中的数据有：\n+----+--------+-----+| a | b | c |+----+--------+-----+| 3 | yanjd3 | -3 || 4 | yanjd4 | -4 || 5 | yanjd5 | -5 || 6 | yanjd6 | -6 || 7 | yanjd6 | -7 || 8 | yanjd6 | -8 || 9 | yanjd6 | -9 || 10 | yanjd6 | -10 || 11 | yanjd6 | -11 || 12 | yanjd6 | -12 || 13 | yanjd6 | -13 || 14 | yanjd6 | -14 || 15 | yanjd6 | -15 || 16 | yanjd6 | -16 || 17 | yanjd6 | -17 || 18 | yanjd6 | -18 || 20 | yanjd6 | -20 || 21 | yanjd2 | -21 || 22 | yanjd3 | -22 || 23 | yanjd4 | -23 || 24 | yanjd5 | -24 || 25 | yanjd6 | -25 || 26 | yanjd6 | -26 || 27 | yanjd6 | -27 |+----+--------+-----+\n我们可以看出：\n列a的基数为：24\n列b的基数为：5\n列c的基数为：24\n2.如何在MySQL中统计普通列的基数？\n显然易见，我们不可能每次都用眼睛看着数来确定某一列的基数。\n在MySQL中可以用下面语句来确定某一列的基数：\n以前面的表为例，统计出列a的基数：\nmysql&gt; select count(distinct a) from t;+-------------------+| count(distinct a) |+-------------------+| 24 |+-------------------+1 row in set (0.00 sec)\n统计b列的基数：\nmysql&gt; select count(distinct b) from t;+-------------------+| count(distinct b) |+-------------------+| 5 |+-------------------+\n统计c列的基数：\nmysql&gt; select count(distinct c) from t;+-------------------+| count(distinct c) |+-------------------+| 24 |+-------------------+1 row in set (0.00 sec)\n3.基数的用处\n关于基数的用处只需记住一点：对于索引列，基数越大，查询效果越好，基数越小，查询效果越差，理想的索引列满足： 基数/实际行=1；\n对于索引列，我们可以通过下面语句查看其基数：\nmysql&gt; show indexes from t \\G;\n\n从这里我们可以看到，对于索引列，数据库会自动对其基数进行统计。\n4.InnoDB是怎样为索引列统计基数？\n在生产环境中，索引的更新操作可能会非常频繁，如果每次索引发生变化时对其基数进行统计，那么将会给数据库带来很大的负担。\n这是不能接受的，所以MySQL的策略是：\n\n\n1）当表中索引列1/16的数据发生变化时，会对其基数进行统计。\n\n\n2）stat_modified_counter&gt;2000000000时（如果表中某一行的数据频繁地进行更新，这时表中的数据实际并没有增加，发生变化的还是这一行数据，这种情况下第一种策略就无法生效，所以MySQL设置了一个计时器，用来表示发生变化的次数，当发生变化的次数大于2000000000时进行统计），会对其基数进行统计。\n\n\n注意：如果一张表非常大，那么实际统计一次基数信息所需要的时间可能会非常长，所以MySQL采用采样的方式进行基数的统计。\nInnoDB存储引擎只对8个节点进行采样来统计基数，具体步骤如下：\n首先，取得B+树索中节点的数量，记为A;\n然后，随机取B+树索引中的8个节点，统计每页不同记录的个数，记为P1,P2,P3…P8;\n最后计算出此索引列的基数=（P1+P2+P3+P4…+P8)*A/8\n注意：上面获取8个节点的方式是随机！！这就意味着，统计的基数信息每次可能不同，这是正常的现象。\n5.动手试一试\n还是以上面的表t为例子\n首先查看其索引列a的基数：\n\n然后插入数据：\nINSERT INTO T (a,b,c) values(28,&#x27;yanjd2&#x27;,-21);INSERT INTO T (a,b,c) values(29,&#x27;yanjd3&#x27;,-22);INSERT INTO T (a,b,c) values(30,&#x27;yanjd4&#x27;,-23);INSERT INTO T (a,b,c) values(31,&#x27;yanjd5&#x27;,-24);INSERT INTO T (a,b,c) values(32,&#x27;yanjd6&#x27;,-25);INSERT INTO T (a,b,c) values(33,&#x27;yanjd6&#x27;,-26);INSERT INTO T (a,b,c) values(34,&#x27;yanjd6&#x27;,-27);\n然后，查看其索引基数：\n\n这时发现，其基数统计信息没发生变化啊？？ 这可能是统计触发条件没达到的原因。\n解决方案：我们可以执行下面语句使mysql主动计算统计信息：\nanalyze table t;//主动让mysql计算统计信息\n\n这时可以发现，索引a的基数信息发生变化了。\nshow variables like &#x27;%slow%&#x27;;//查询mysql配置变量信息\n","tags":["MySQL性能优化"]},{"title":"10.联合索引","url":"/article/Database-MySQL-PerformanceOptimization-10-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/","content":"数据库中存在两种类型的应用：OLTP(联机事务类型) OLAP(数据分析类型)\n对于联机事务类型的应用，索引的作用是巨大的，这点无需多言。\n对于OLAP数据分析型的应用，索引的作用并不大，但是对于复杂的查询，需要涉及多张表之间的联结操作，这时索引的添加是有意义的。\n索引只有一种吗？显然不是，下面多MySQL中不同类型的索引进行学习\n1.联合索引（最左前缀原则）\n1.1 什么是联合索引？\n联合索引指的是对一张表上的多个列进行索引。\n也就是说，表上多个列加起来组成一个索引，供快速查询使用。\n1.2 如何使用联合索引？\n首先，给表添加索引\n创建表时给表添加索引：\nCREATE TABLE t(a int,b int,primary key(a),key idx_a_b(a,b))\n创建表后给表添加索引：\nCREATE TABLE t(a int,b int,primary key(a))ALTER TABLE t ADD INDEX indx_a_b(a,b);\n然后进行使用该联合索引进行查询，在此之前，我们需要学习联合索引的最左前缀原则。\n最左前缀原则规定了联合索引在何种查询中才能生效，规则如下：\n\n\n如果想使用联合索引，联合索引的最左边的列必须作为过滤条件，否则联合索引不会生效。\n\n\n这也就是说，联合索引其实拥有单列索引的作用。\n\n\n下面我们给上表t插入数据，学习联合索引如何正确使用：\ninsert into t(a,b) values(1,4);insert into t(a,b) values(2,5);insert into t(a,b) values(3,6);\n最左前缀原则实验：\n\n\n\n3.1 联合索引使用场景\n那么联合索引的优势在哪里呢？\n首先，我们需要看一下联合索引内部的结果：\n从本质上说，联合索引还是一个B+树，不过联合索引的键值数量不是1， 而是大于等于2.\n我们一个两列联合索引假定两个键值分别为key1,key2，则其B+树结构如下图：\n\n从上图中我们可以看到，通过叶子节点可以逻辑上顺序地读出，所有数据：\n(1,2) （1,2） (2,1) (2,4) (3,1) (3,2).\n因此，对于查询\nSELECT * FROM TABLE WHERE key1=xxx and key2=xxx 显然是可以使用（key1,key2）这个联合索引的。\n对于单个列key1的查询 SELECT * FROM TABLE WHERE key1=xxx 根据最左前缀原则也是可以使用联合索引的。\n但是：对于单个列key2的查询时不可以使用B+树索引的：\nSELECT * FROM TABLE WHERE key2=xxx;\n我们查看上图B+树可以看到叶子节点上的key2的值为1，2，1，4，1，2,这显然不是顺序的，故对于key2列的查询是不能使用联合索引的。\n综上，我们可以总结出联合索引的一个优势：当两个列的组合是唯一值时，联合索引是个不错的选择。\n3.2 联合索引的另一个好处就是可以对第二个键值进行排序\n例如，在很多时候我们需要查询某个用户的购物情况，并按照时间排序。\n这时使用联合索引（userid,buy_date）可以减少一次排序操作，因为这个索引本身在叶子节点上已经排序了。\n实例：\n首先创建一张表\nCREATE TABLE buy_log(userid int unsigned not null,buy_date DATE)\n然后给表加上一个两个索引：\nALTER TABLE buy_log ADD KEY (userid);ALTER TABLE buy_log ADD KEY(userid,buy_date);\n最后向表中插入数据：\nINSERT INTO buy_log (userid,buy_date) VALUES (1,&#x27;2021-01-01&#x27;);INSERT INTO buy_log (userid,buy_date) VALUES (2,&#x27;2021-01-01&#x27;);INSERT INTO buy_log (userid,buy_date) VALUES (3,&#x27;2021-01-01&#x27;);INSERT INTO buy_log (userid,buy_date) VALUES (1,&#x27;2021-02-01&#x27;);INSERT INTO buy_log (userid,buy_date) VALUES (3,&#x27;2021-02-01&#x27;);INSERT INTO buy_log (userid,buy_date) VALUES (1,&#x27;2021-03-01&#x27;);\n这时联合索引的B+树结构如下：\n\n本例中创建了两个索引来进行比较，一个是userid的单列索引，一个是userid和buy_date的联合索引。\n如果只对userid进行查询，例如：\nEXPLAIN SELECT * FROM buy_log WHERE userid=2;\n\n可以看到，优化器最终选择的是userid，从这里可以看出，查询一行数据时，当单列和索引和联合索引发生冲突时，优先选择单列索引。\n接着，假定要取出userid为1的最近3次的购买记录：\nEXPLAIN SELECT * FROM buy_log WHERE userid=1 ORDER BY buy_date DESC LIMIT 3;\n\n从这里可以看到优化器选择了联合索引，下面我们看下这个查询的结果：\n\n上面说到联合索引的一个优势就是：可以对第二个键值进行排序\n所以下面语句在不使用ORDER BY额外排序的基础上一样可以得到排序结果：\nEXPLAIN SELECT * FROM buy_log WHERE userid=1 DESC LIMIT 3;\n\n\n所以可以总结到，联合索引的最左列原则生效的前提下，索引中其他列的存储是默认排序的，这就是使用联合索引的一个巨大的优势！！！\n","tags":["MySQL性能优化"]},{"title":"11.覆盖索引","url":"/article/Database-MySQL-PerformanceOptimization-11-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95/","content":"InnoDB存储引擎支持覆盖索引\n1. 什么是覆盖索引？\n覆盖索引实际上就是辅助索引，当从辅助索引中就可以查到查询需要的数据而不用去查询聚集索引时，\n这时辅助索引也可被称为覆盖索引。\n下面回顾下辅助索引结构：\n辅助索引的叶子节点仅存放索引键值以及该索引键值指向的主键。\n\n2.使用覆盖索引的好处（提高查询速度）\n使用覆盖索引的好处就是辅助索引不包含整行记录的所有信息，所以查询起来相比于聚集索引会快很多。\n（在辅助索引层就返回结果！！）\n3.使用场景\n对于InnoDB存储引擎的辅助索引而言，由于其中包含了主键信息，因此其叶子节点存放的数据为（primary key1 , primary key2,…,key1,key2,…）\n则下面的语句仅可以使用一次辅助联合索引就可以完成查询：\nSELECT key2 FROM table WHERE key1=xxx;SELECT primary key2,key2 FROM table WHERE key1=xxx;SELECT primary key1,primary key2,key2 FROM table WHERE key1=xxx;\n综上而言:覆盖索引的好处对于某些统计问题和部分索引列单值查询可以减少IO操作。\n如何辨别优化器选择了覆盖索引？\n\n当这里的Extra列为Using index时且possssible_keys为NULL时，表示优化器选择了覆盖索引！！否则使用的是聚集索引。\n4.何种情况下优化器不会选择索引？\n一句话：当索引不能满足查询时，优化器会直接进行全表扫描。这种情况多发生于范围查找，JOIN操作等。\n例如：\nSELECT * FROM orderdetails where orderid&gt;1000 and orderid&lt;12000;\n","tags":["MySQL性能优化"]},{"title":"12.索引提示","url":"/article/Database-MySQL-PerformanceOptimization-12-%E7%B4%A2%E5%BC%95%E6%8F%90%E7%A4%BA/","content":"MySQL支持索引提示（INDEX HINT）机制显式地告诉优化器使用那个索引。\n一般来说，下面两种情况需要用到索引提示：\n\n\n1）MySQL错误的使用了某个索引从而导致SQL语句运行的非常慢。（这种情况非常少见，如果遇见了，就去买彩票吧）\n\n\n2）某些SQL语句可以选择的索引非常多，这时优化器选择执行计划时间的开销可能会大于SQL语句本身。 这时使用索引提示是有必要的。\n\n\n例如，优化器分析范围查询本身就是比较耗时的操作，\n这时DBA或开发人员分析最优的索引选择，通过INDEX HINT来强制让优化器直接选择指定的索引进行查询，而不去分析选择使用那个索引。\n使用索引提示的sql语句有两种：\n\n这个语句只是提醒优化器使用那个索引，具体的选择还是优化器说了算，不推荐使用\n\nSELECT * FROM t USE INDEX(a) WHERE a=1 AND b = 2;\n\n这条语句强制优化器直接使用指定的索引进行查询，推荐使用\n\nSELECT * FROM t FORCE INDEX(a) WHERE a=1 AND b = 2;\n1.例子\n1.1 首先，创建一张表\nCREATE TABLE t(a INT,b INT,key(a),key(b))\n1.2 然后向其中插入数据\nINSERT INTO t(a,b)values(1,1);INSERT INTO t(a,b)values(1,2);INSERT INTO t(a,b)values(2,3);INSERT INTO t(a,b)values(2,4);INSERT INTO t(a,b)values(1,2);INSERT INTO t(a,b)values(1,4);\n1.3 使用索引提示机制\n然后查看下面语句的执行计划：\nselect * from t where a=1 and b=2 ;\n\n通过key值我们可以看到，此次查询使用了两个索引b，a。\nExtra列提示的Using intersect（b,a）表示根据两个索引得到的结果进行求交的数学运算，最后得到结果。\n下面使用USE INDEX来提示优化器进行查询：\nselect * from t use index(a) where a=1 and b=2 ;\n\n可以看到也起到了作用。\n下面使用FORCE INDEX进行强制使用某索引：\nselect * from t force index(a) where a=1 and b=2 ;\n\n推荐使用这种方式！！\n例子：\nmysql&gt; explain select * from t force index(idx_c) where a=1 and c=&#x27;-1&#x27; \\\\G;*************************** 1. row ***************************id: 1select_type: SIMPLEtable: tpartitions: NULLtype: constpossible_keys: idx_ckey: idx_ckey_len: 8ref: const,constrows: 1filtered: 100.00Extra: NULL1 row in set, 1 warning (0.00 sec)ERROR:No query specifiedmysql&gt; explain select * from t where a=1 and c=&#x27;-1&#x27; \\\\G;*************************** 1. row ***************************id: 1select_type: SIMPLEtable: tpartitions: NULLtype: constpossible_keys: PRIMARY,idx_ckey: PRIMARYkey_len: 4ref: constrows: 1filtered: 100.00Extra: NULL1 row in set, 1 warning (0.00 sec)\n","tags":["MySQL性能优化"]},{"title":"13.MySQL分区存储","url":"/article/Database-MySQL-PerformanceOptimization-14-%E4%BA%86%E8%A7%A3MySql%E4%B8%AD%E7%9A%84%E5%88%86%E5%8C%BA%E6%A6%82%E5%BF%B5/","content":"1.什么是分区？\n分区其实是一个过程，它将一个表分解为多个更小，更容易管理的部分,好的分区设计对数据库性能会有极大的提升。\nMySQL支持的分区类型为水平分区：将同一张表中不同行的记录分配到不同的物理文件中。\n这样就可以根据分区对一些有规律的数据进行高效操作。MySQL数据库中的分区时局部分区，即一个分区中既存放数据也存放索引。\n2.MySQL中支持的分区类型\n\n\nRANGE分区：范围分区，一个给定连续区间的列值放入指定范围的分区。分区条件必须为整型\n\n\nLIST分区：它和RANGE分区类型一样，只是LIST分区面向的是离散的值(例如：1,4,6)，而不是连续的列值。分区条件必须为整型\n\n\nHASH分区：Hash分区的目的在于将数据均匀分布在预定义的各个分区中。分区条件必须为整型\n\n\nKEY分区：他和Hash分区相似，不同点在于，Hash分区使用用户定义的函数进行分区，而Key分区使用的是MySQL内置的函数。分区条件必须为整型\n\n\nColumns分区：columns分区支持非整型条件分区。\n\n\n在创建分区时必须注意的一点：如果表中存在主键或唯一索引时，分区列必须是唯一索引的一个组成部分。当建表时没有指定主键和唯一索引时，可以指定任何一个列为分区列。\n3.RANGE分区？\n顾名思义，范围分区，它是根据列值的范围进行分区的。\n3.1 实例学习\n首先，创建一张表,并为表新建范围分区：\nCREATE TABLE t(id int)PARTITION BY RANGE(id)(PARTITION p0 VAlUES LESS THAN(10),PARTITION p1 VALUES LESS THAN(20));\n其中，建表语句后的：\nPARTITION BY RANGE(id)(PARTITION p0 VAULES LESS THAN(10),PARTITION p1 VALUES LESS THEN(20));\n它表示将t表设置成分区表，分区规则是范围分区，将表数据分为两部分，p0分区负责存储列id小于10的数据，\np1分区负责存储列id为10到20的数据。这就是范围分区。\n我们从前面学习到分区的原理其实就是：将一个表或索引分解成多个更小，更可管理的部分，从逻辑上说，只有一个表，但是从物理上说，这个表或索引可能由多个物理文件组成，每个分区都是独立的对象，可以独自处理。\n所以我们在创建这张表后，查看其物理文件，会发现表不再由一个ibd文件组成，而是由建立各分区ibd组成，如图：\n\n然后向此表插入数据：\nINSERT INTO t values(9);INSERT INTO t values(10);INSERT INTO t values(15);\n注意：对于表t，我们定义了分区，因此插入的值应该严格遵守分区的定义，当插入一个不在分区中定义的值时，MySQL数据库就会抛出一个异常，如：\nINSERT INTO t values(20);\n就会抛出一个异常：\n\n而对于上述问题，也就是超过分区上限的值该如何存储，答案就是新加一个MAXVALUE(无穷大)值的分区：\nALTER TABLE t ADD PARTITION(PARTITION p2 values less than maxvalue);\n\n成功插入！！\n接着可以查看每个分区的一些属性信息：\n3.2 查看表中每个分区的具体信息\nSELECT * FROM information_schema.PARTITIONS WHERE table_schema=database() AND table_name=&#x27;t&#x27; \\G;\n\n从这里可以查看到每个分区的情况。\n3.3 RANGE分区的主要应用场景\nRANGE分区主要用于日期列的分区，例如，对于销售类的表，可以根据年份来分区存放销售记录。如下：\n新建一张名为sales的表：\nCREATE TABLE sales(money int unsigned not null,date datetime)\npartition by range(year(date))(partition p2008 values less than(2009),partition p2009 values less than(2010),partition p2010 values less than(2011));\n注意，这里的range(year(date))的原因是：RANGE，LIST,HASH,KEY四种分区种，分区的条件必须是整型！！，如果不是整型，那么需要通过函数将其转化为整型。 如YEAR(),TO_DAYS()…\n接着向表种插入数据：\nINSERT INTO sales(money,date)values(100,&#x27;2008-01-01&#x27;);INSERT INTO sales(money,date)values(100,&#x27;2008-02-01&#x27;);INSERT INTO sales(money,date)values(100,&#x27;2008-01-02&#x27;);INSERT INTO sales(money,date)values(100,&#x27;2009-03-01&#x27;);INSERT INTO sales(money,date)values(100,&#x27;2010-03-01&#x27;);\n3.3.1 删除性能高\n创建一个分区的好处就是，如果我们想删除一个分区的数据，无需重复执行delete语句，只需下面sql就可以清空分区数据：\nALTER TABLE table_name TRUNCATE PARTITION p_name;\n如果我们以后不用该分区，也可以使用下面语句删除该分区达到删除效果：\nalter table table_name drop partition p_name;\n但这样做的坏处是分区不可复用。所以第一个删除语句是首选。\n3.3.2 查询性能高\n使用分区，在范围查询中可以明显加快查询。\n例如：\nEXPLAIN SELECT * FROM sales where date&gt;=&#x27;2008-01-01&#x27; and date&lt;=&#x27;2008-12-31&#x27;\n\n可以看到，使用到了分区查询而不是全表扫描！！！\n注意：对于RANGE分区的查询，优化器只能对YEAR(),TO_DAYS(),TO_SECONDS()这类的函数进行优化选择，而不能对复合表达式进行优化选择！！\n4.何为LIST分区？\nLIST和RANGE分区唯一的区别就是，RANGE分区存储的值是连续的区间，而LIST分区存储的值是离散的。\n4.2 例子学习\nCREATE TABLE t(a int,b int)partition by list(b)(partition p0 values in(1,3,5,7,9),partition p1 values in(0,2,4,6,8));\n这表示p0分区只能存储b列为1，3，5，7，9的行数据。\n注意，它的用法和range分区有所不同：\npartition by list(b)(partition p0 values in(1,3,5,7,9),partition p1 values in(0,2,4,6,8))\n现在，我们向这个分区表中插入数据：\nINSERT INTO t(a,b)values(2,1);INSERT INTO t(a,b)values(2,2);INSERT INTO t(a,b)values(2,3);INSERT INTO t(a,b)values(2,4);\n下面插入一条不符合分区的数据：\nINSERT INTO t(a,b)values(2,10);\n\n很明显，插入失败。\n这里我们要注意：在INNODB中，在执行多个insert的过程中，如果有一条失败，那么整个插入过程会回滚！！\n4.3.LIST分区的应用场景\nLIST分区特别适合枚举值列的分区，例如，将根据性别分区。\n下面创建一张表：\nCREATE TABLE class_people(id int auto_increment,name varchar(20),sex int ,primary key(id,sex))partition by list(sex)(partition p0 values in(1),partition p1 values in(0));\n其中1代表男生，0代表女生。\n然后向表中插入数据：\nINSERT INTO class_people(name,sex)values(&#x27;tom&#x27;,1);INSERT INTO class_people(name,sex)values(&#x27;tony&#x27;,0);INSERT INTO class_people(name,sex)values(&#x27;baby&#x27;,1);INSERT INTO class_people(name,sex)values(&#x27;jayme&#x27;,0);\n\n下面看下下面语句的执行计划：\nSELECT * FROM class_people where sex=1;\n查找性别为男的数据：\n\n可以明显的看到只查询了p0分区。\n5.何为HASH分区？\n故名思意，就是将列值通过特定的HASH函数计算后的值划分分区，\nHASH分区的目的是将数据均匀的分布到预先定义的各个分区中，保证数据均匀分布。\n我们要做的是基于将要被散列的列值指定一个列值或表达式，以及指定被分区的表将要被分割的分区数量。\nMySQL支持的HASH分区分为普通HASH分区和LINEAR HASH分区。\n5.1 普通HASH分区实例学习\nCREATE TABLE t_hash(a int,b datetime)partition by hash(year(b))partitions 4;\n上面建表语句中创建分区的意思是：根据b列的year()的函数值进行分区，计算方式是year(b)的值对4取余，\n若结果为0，则该行数据会被放在p0分区\n若结果为1，则该行数据会被放在p1分区\n若结果为2，则该行数据会被放在p2分区\n若结果为3，则该行数据会被放在p3分区\n其中partitions 4代表着hash分区的数量为4，如果没有这个语句，分区数量默认为1.\n下面插入一个记录：\nINSERT INTO t_hash(a,b) values(1,&#x27;2014-10-01&#x27;);\n\n2014和4取余为2，所以该数据被放在p2分区中。\n注意：HASH分区对于连续的列值做分区比较好，如自增长的主键，这样数据就能较好的分布。\n5.2.LINEAR HASH分区\nLINEAR HASH分区使用一个更加复杂的算法来确定插入到已分区的表中的位置。\n用法如下：\nCREATE TABLE t_linear_hash(a int,b datetime)partition by linear hash(year(b))partitions 4;\n对于这个分区，插入2010-04-01这条记录，这次MySQL数据库根据以下方法来对分区进行判断：\n取大于分区数量4的下一个2的幂值V，V=POWER(2,CEILING(LOG(2,num)))=4.\n所在分区N=YEAR(‘2010-04-01’)&amp;(V-1)=2;\n上面的算法不必深究，关键在于会用，知道其优缺点：\n\n\nLINEAR HASH分区的优点在于增加，删除，合并和拆分分区将变得更加快捷，这有利于处理含有大量数据的表。\n\n\nLINEAR HASH分区的缺点在于，与使用HASH分区得到的数据分布相比，各个分区间数据的分布可能不大均衡。\n\n\n6.何为KEY分区？\nKEY分区和HASH分区相似，不同之处在于HASH分区通过用户定义的函数进行分区，而KEY分区使用MySQL数据库提供的函数进行分区。\n用法如下：\nCREATE TABLE t_key(a int,b datetime)partition by key(b)partitions 4;\n不过这个分区的编号是通过2的幂值得到的，而不是通过模数算法计算出来的。\n7.何为COLUMNS分区？\nCOLUMNS分区允许分区条件为非整型，分区根据类型直接比较而得到，不需要转化为整型。\n此外，RANGE COLUMNS分区可以对多个列的值进行分区，COLUMNS分区支持以下数据类型：\n\n\n所有整型\n\n\n日期类型\n\n\n字符串类型\n\n\n用法如下：\nCREATE TABLE t_columns_range(a int,b datetime)partition by range columns(b)(partition p0 values less than (&#x27;2009-01-01&#x27;),partition p1 values less than (&#x27;2010-01-01&#x27;));\nMySQL从5.5开始支持COLUMNS分区，对于前面的range分区和list分区，可以很好的利用RANGE COLUMNS分区和LIST COLUMNS分区代替。\n","tags":["MySQL性能优化"]},{"title":"14.MySQL子分区","url":"/article/Database-MySQL-PerformanceOptimization-18-MySQL%E5%88%86%E5%8C%BA%E4%B9%8B%E5%AD%90%E5%88%86%E5%8C%BA%EF%BC%88%E5%A4%8D%E5%90%88%E5%88%86%E5%8C%BA%EF%BC%89%E4%B8%8E%E5%88%86%E5%8C%BA%E4%B8%AD%E5%AF%B9NULL%E7%9A%84%E5%A4%84%E7%90%86/","content":"1.何为子分区？\n子分区顾名思义，就是在分区中再创建分区，达到对数据的细腻化操作。\nMySQL数据库中允许在RANGE和LIST的分区上再进行HASH分区或KEY分区。\n2.实例学习\n运行下面语句：\nCREATE TABLE ts(a int,b date)partition by range (year(b))subpartition by hash(to_days(b))subpartitions 2 (partition p0 values less than (1990),partition p1 values less than (2000),partition p2 values less than maxvalue);\n上面的分区语句首先根据b的年份创建三个分区1990，2000，maxvalue，然后再将这三个分区根据天再分成两个小分区，所以其实总共有6个分区。\n如图：\n\n可以看到mysql分别创建了6个物理文件存放这6个分区的数据。\n通过上面的语句我们可以看到使用的子分区是默认的命名，我们也可以显式的定义各个子分区的名字：\nCREATE TABLE ts(a int,b date)partition by range ( year(b))subpartition by hash( to_days(b))(partition p0 values less than(1990)(subpartition s0,subpartition s1),partition p1 values less than(2000)(subpartition s2,subpartition s3),partition p2 values less than maxvalue (subpartition s4,subpartition s5));\n\n在使用分区时，注意：\n每个子分区的数量必须一致\n如果在一个分区表中的任何分区上使用SUBPARTITION来明确定义任何子分区，那么就必须定义所有的子分区\n每个SUBPARTITION子句必须包括子分区的一个名字\n子分区的名字必须是唯一的\n3.分区中对NULL的处理\n对于MySQL需要记住：\n在RANGE分区下，NULL会被放入最左边的分区中\n在LIST分区中使用NULL，必须显式地指出在那个分区中放入NULL值，否则数据库会报错。\nHASH和KEY分区对NULL的处理方式与RANGE和LIST分区不一样，任何分区函数都将会含有NULL值的记录返回为0，也就是会放在P0分区中。\n4.合理利用分区\n数据库的应用分为两类：OLTP （联机事务数据库）, OLAP（联机分析数据库）。\n二者的差别有：联机事务强调快速响应，涉及的数据量小，联机分析强调准确性，涉及的数据量大。\n对于OLAP系统，分区显然可以带来明显的效果，但是对于OLTP系统，在分区时应当非常小心！\n理由如下：\n在OLTP系统中，通常不会获取一张大表中10%的数据，大部分数据都可以通过索引快速获得。\n根据B+树索引的原理可知，对于一张大表，一般的B+树需要2~3次的磁盘IO操作，因此B+树可以很好的完成对大表的查询操作，不需要分区的帮助。\n假设一千万行数据的B+树的高度是3，一百万行数据的B+树的高度就是2，这样上述主键分区的索引可以避免一次IO，从而提高查询的效率。这没问题\n但是这张表只有主键索引，没有其他列需要分区吗？\n如果以其他非主键列为分区列，那么执行：select * from table where key=@key ，这时对于key的查询需要扫描所有的10个分区，即使每个分区的查询开销是2次IO操作，那么一共需要20次IO，而对于原来的表，对key的查询只需2~3次IO.\n因此注意：对于使用Innodb存储引擎作为OLTP应用的表在使用分区时应当十分小心，在设计时要确认数据的访问模式，否在会带来严重的性能损失。\n","tags":["MySQL性能优化"]},{"title":"15.MySQL事务概述","url":"/article/Database-MySQL-PerformanceOptimization-20-MySQL%E4%BA%8B%E5%8A%A1%E4%B9%8B%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/","content":"1.什么是事务？\n事务可由一条非常简单的SQL语句，也可以由一组复杂的SQL语句组成。\n简单说，事务就是SQL的集合。\n事务就是SQL的集合吗？ 那它有一个sql脚本有什么区别？\n这里就涉及到事务的一个重要特性了：\n原子性。一个事务要么全部执行，要么全部不执行，不存在执行一部分，不执行一部分的情况，\n这就是它和sql脚本的区别，也就是说一个事务中的所有SQL，要么全部执行成功，要么全部执行失败。\n注意：原子性是事务的根本！！\n2.简单理解事务的ACID特性\nACID其实是四个特性首字母。\n2.1 A: atomicity 原子性。\n从上面可知，原子性就是不可分割的特性，也就是最小执行单位，它不可能再被分为很多小的过程。\n那么事务的原子性又是什么呢？\n简单来说，我们可以将一次事务当作一次考试。 当我们面对一次考试时，我们能做的选择有两个：参加，不参加。\n参加代表着一次事务的开始（事务开始），当考试完毕，我们交了卷子（事务的提交），这次事务就视作结束。在参加考试的过程中，如果我们违反考试规则被老师抓住，我们的此次考试将被判无效，此前做的所有题的分数将被清0（事务回滚），这时如果我们想要得到考试分数，就只能重新参加考试（**重新开始事务），**但是如果我们做题的过程中有几道题不确定，我们可以给那几道题打个标记（保存点），然后再做剩下题的过程中灵光一现，知道咋做了，于是就回到那几道题上重新做（跳到保存点），然后往下做，做完试卷，到时间后交给老师，这次考试也就结束了。\n不参加很简单，就是不开始这个事务。\n参加考试要么有成绩，要么没成绩，不存在有一半成绩的情况，这就是事务的原子性。\n2.2 C: consistency 一致性\n什么是一致性？\n书上的解释是：一致性指事务将数据库状态从一种状态转变为另一中一致性的状态。\n我看到这句话的第一反应就是：看不懂！\n但仔细思考后，我觉得通过一个实际的例子能更好的帮助理解：\n一天，我和我的好朋友麻子在街上看到一个身材窈窕，气质极佳的美女，我和麻子相视一笑，我们都觉得这个美女是今天遇到的妹子中最养眼的一个，这时我们的看法是一致的。但走到下一个路口，我看到了更好看的妹子，而麻子兄弟因为看手机错过了，这时我们为第二个妹子是最养眼的，而麻子因为没看到第二个妹子，他还是认为第一个妹子是最养眼的，这时，我们的看法是不一致的。\n现在转换到数据库上：我们不难理解，一致性就是当一个公共字段的值发生变化时，要保证所有看到这个值事务所看到的值是一致的，而不是有的事务看到了，有的事务没看到的情况。\n2.3 I :isolation 隔离性\n事务的隔离性，其实就是不同的事务对同一个表进行处理时，他们能彼此看到对方对这个表的操作吗？\n读未提交：他们能看到彼此的操作。\n读已提交：在事物的过程中，他们看不到彼此的操作，但当有一个事务提交后，另一个事务就可以看到了。\n可重复读：他们看不到彼此的操作（即使另一个事务已经提交），但是他们也不会被彼此的操作影响自己的操作。\n可串行化：他们的操作是串行化的，一个一个来的。\n2.4 D: durability 持久性\n事务的持久性就是当一次事务提交后，它保存的数据就是永久的，即使宕机，数据库也能恢复。\n3.使用事务的好处\n使用事务最大的好处就是，当我们在执行一串SQL时，突然发现中间一条SQL执行的结果是错误的，\n这时，我们就可以反悔，告诉数据库，前面的SQL失效吧。\n这时数据库就会回滚前面已执行的SQL语句，我们又可以重新开始自己的SQL操作了，这避免了很多问题。\n这在很多应用场景下都很有用：\n比如银行系统的转账服务：\n\nA要向B账户转200块：首先检查A账户是否有200块，然后扣除A账户200，接着向B账户存入200，但是在存入的过程中发现B账户由于某种原因无法使用了，存入失败。\n这时如果没有事务，那么就只能手工的往A账户加200块，但是有了事务，在B账户存入失败后，数据库会自动回滚前面A账户扣除200块的操作。这样大大提高了工作效率。\n\n","tags":["MySQL性能优化"]},{"title":"16.MySQL事务的分类","url":"/article/Database-MySQL-PerformanceOptimization-22-MySQL%E4%BA%8B%E5%8A%A1%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%88%86%E7%B1%BB/","content":"我们都知道，事务是个好东西，好东西就会发展，发展就会壮大，随着事务技术的发展，事务大致可以分为几类，\n下面对这几类事务进行学习：\n\n扁平事务\n带有保存点的事务\n链事务\n嵌套事务\n分布式事务\n\n1.扁平事务\n1.1 什么是扁平事务？\n扁平事务是最简单的事务，此类事务的所有操作都在同一层次上（同一数据库，同一回滚原则，要么都执行成功，要么都执行失败）。\n扁平事务的执行只存在三种状况：成功提交，人工回滚，外界原因强制终止。\n1.2 扁平事务实例\n我们先查询表t\n\n然后执行下面事务：\n-- 开启事务START TRANSACTION;-- 执行查询select * from t;-- 执行更新update t set b=7 where a=2;-- 回滚rollback;-- 提交事务COMMIT;\n会发现，表t中的数据没发生变化，因为回滚了，然如果将上面的rollback去掉，就会发现更新成功。\n2.带有保存点的事务\n顾名思义，带有保存点的事务，就是可以在事务中设置保存点，并在一定条件下回滚到保存点而不是全部回滚。\n2.2 实例学习\n-- 开启事务START TRANSACTION;-- 执行查询select * from t;-- 设置保存点delete1SAVEPOINT delete1;-- 执行更新语句update t set b=7 where a=2;-- 回退到保存点delete1rollback to delete1;-- 提交事务COMMIT;\n验证过程：\n首先我们先查询表t的数据：\n\n然后，执行：\nSTART TRANSACTION;select * from t;SAVEPOINT delete1;update t set b=7 where a=2;\n后再查询表t的数据：\n\n这时发现表t的数据在本次事务的当前时间发生了变化。\n接着执行：\nrollback to delete1;\n在查询：\n\n会发现它回滚了！！这就是保存点的作用，它能实现部分回滚的作用。\n3.链事务\n3.1 什么是链事务？\n链事务可以作为保存点模式的一个变种，带有保存点的事务虽然可以设置保存点，\n但是当系统发生崩溃时所有的保存点将会消失。\n这意味着如果想要恢复保存点，就必须从开始重新执行，而不能从最近的一个保存点继续执行。\n而链式事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务。\n这就意味着，前一次事务的操作是持久的。\n但链式事务也是有缺点的：最多只能回滚到当前事务的起始点，无法回滚前一个节点事务提交前的状态。\n3.2实例学习\nSTART TRANSACTION;select * from t;SAVEPOINT delete1;update t set b=7 where a=2;COMMIT;START TRANSACTION;select * from t;rollback to delete1;COMMIT;\n我们执行上面链式事务看看结果：\n\n可以很清楚的看到，当后一个事务想要回滚到前一个事务的保存点时，失败了。\n接着看看表的数据是不是前一个事务提交后的数据：\n\n可以清楚的发现前一个事务提交的事务是持久的！！\n4.嵌套事务\n4.1 什么是嵌套事务？\n嵌套事务是一个层次结构的框架。有一个顶层事务控制着各层次的事务。顶层事务之下嵌套的事务被称为子事务，其控制每个个局部的变换。\n如图：\n\n关于嵌套事务，我们必须注意它的一些特性：\n嵌套事务是由若干事务组成的一颗树，子树可以是嵌套事务，也可以是扁平事务。\n处于叶节点的事务时扁平事务，但是每个子事务从根到叶节点的距离可以是不同的。\n位于根节点的事务称为顶层事务，其他事务称为子事务。事务的前驱称为父事务，事务的下一层称为儿子事务。\n子事务既可以提交也可以回滚，但是它的提交操作不会马上生效，除非由其父事务提交。因此可以知道：任何子事务都在顶层事务提交后才真正提交哦。\n树中的任意一个事务的回滚会引起它的所有子事务一同回滚。故子事务只保留A,C,I特性，不具有D特性。\n4.2 实例学习\nmysql不显式的支持嵌套事务，但我们可以通过保存点来实现：\nSTART TRANSACTION;select * from t;#开启子事务update1SAVEPOINT update1;update t set b=8 where a=2;#开启子事务中的子事务sonupdate2SAVEPOINT sonupdate2;update t set b=9 where a=2;#回滚子事务sonupdate2rollback to sonupdate2;select * from t;#回滚update1rollback to update1;COMMIT;\n通过保存点的嵌套可以实现嵌套事务的控制。\n5.分布式事务\n5.1 什么是分布式事务？\n分布式事务通常指的是一个在分布式环境下运行的扁平事务，因此需要根据数据所在的位置访问网络中的不同节点进行数据库操作，这样就存在不同节点下事务如何同步的问题。\n假设一个用户在AMT机前进行银行的转账操作，要从人民银行储蓄卡转账1000员到邮储银行卡中，\n在这种情况下，可以将AMT机器视为节点A,人民银行的后台数据库视为节点B，邮储银行的后台数据库视为节点C，这个转账操作则可以被分为以下步骤：\n\n\n节点A发出转账命令\n\n\n节点B执行从人民银行储蓄卡中将余额值减去1000\n\n\n节点C执行从邮储银行卡中加上1000\n\n\n然后节点A通知用户操作完成或失败\n\n\n在上面的过程中，很明显他们不在用一台机器上，所以这个过程必须通过网络通知来进行事务的同步，如何控制呢？\n我们可以考虑下面的方案：\n\n\n首先节点A发出转账命令后进入监听状态，然后节点B收到命令后执行完后告诉节点C并进入监听，然后节点C执行完后将成功或失败的标识发送给节点B，\n\n\n节点B收到节点C的返回后，来进行事务的提交或回滚，然后节点B将执行的结果又返回给节点A，节点A根据节点B返回的结果告诉用户是失败或成功。\n\n\n那么在实现上面方案的过程中的事务编程，就称之为分布式事务编程。\n","tags":["MySQL性能优化"]},{"title":"17.MySQL事务的编写语法","url":"/article/Database-MySQL-PerformanceOptimization-23-%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%E8%AF%AD%E6%B3%95/","content":"在MySQL默认命令行设置下，事务都是自动提交的，这就意味着单独执行SQL后就会马上执行提交操作。\n如果我们要取消自动提交，我们可以采用两种方式：\n1.关闭自动提交设置\n在 MySQL 中，可以使用 SET autocommit 语句设置事务的自动提交模式，语法格式如下：\nSET autocommit = 0|1|ON|OFF;\n对取值的说明：\n值为 0 和值为 OFF：关闭事务自动提交。如果关闭自动提交，用户将会一直处于某个事务中，只有提交或回滚后才会结束当前事务，重新开始一个新事务。\n值为 1 和值为 ON：开启事务自动提交。如果开启自动提交，则每执行一条 SQL 语句，事务都会提交一次。\n2.显示开启一个事务\nstart transaction;\n3.编写事务必须掌握的语法\n通过前面的学习，我们知道如何将MySQL自动提交改为手动提交。\n3.1 下面正式学习重要语法\n//显示开启一个事务START TRANSACTION //提交事务COMMIT // 回滚前面已经执行事务，它和COMMIT不可同时执行ROLLBACK //创建保存点SAVEPOINT point //  删除保存点RELEASE SAVEPOINT point// 回滚到保存点位置，注意：即使执行了这个，也要执行ROLLBACK 或COMMIT来结束事务ROLLBACK TO point // 设置事务的隔离级别SET TRANSACTION //提交事务，但它和COMMIT是有区别的，COMMIT WORK用来控制事务结束后的行为是CHAIN还是RELEASE的，如果是CHAIN方式，那么事务就变成了链事务。用户可以通过参数completion_type来进行控制，//默认该参数为0，表示没有任何操作，在这种设置下，COMMIT和COMMIT WORK是完全等价的。//当参数completion_type的值为1时，COMMIT WORK等同于COMMIT AND CHAIN,表示马上自动开启一个相同隔离级别的事务。//当参数completion_type为2时，COMMIT WORK 等同于COMMIT AND RELEASE,当事务提交后会自动断开与服务器的连接。COMMIT WORK \n注意：InnoDB存储引擎中的事务都是原子的，这说明下述两种情况：构成事务的每条语句都会提交（成为永久），或者所有语句都回滚。这种保护还延伸到单个语句中。一条语句要么完全提交成功，要么完全回滚（语句回滚）。因此一条语句失败并抛出异常并不会导致前面已经执行的语句自动回滚。所以必须由用户自己来决定是否对其进行提交或回滚操作。\n3.3 实例学习\n首先从创建一张表：并插入两条数据\ncreate table bank(internal_key int(11) auto_increment,uname varchar(20) ,baseAcctId varchar(50),balance decimal(17,2),primary key(internal_key));\ninsert into bank(uname,baseAcctId,balance) values(&#x27;yanjd&#x27;,&#x27;88888888&#x27;,100000000);insert into bank(uname,baseAcctId,balance) values(&#x27;yanjl&#x27;,&#x27;99999999&#x27;,0);\n然后下面我们使用事务进行下面的操作：\n\nyanjd给yanjl转账100块（使用提交）\n\nSTART TRANSACTION;update bank set balance=balance-100 where baseAcctId=&#x27;88888888&#x27;;update bank set balance=balance+100 where baseAcctId=&#x27;99999999&#x27;;COMMIT;\n执行前后结果：\n\n\n但是如果我们执行下面语句（使用回滚）：\n\nSTART TRANSACTION;update bank set balance=balance-100 where baseAcctId=&#x27;88888888&#x27;;update bank set balance=balance+100 where baseAcctId=&#x27;99999999&#x27;;ROLLBACK;\n执行前:\n\n执行后：\n\n\n下面我们执行下面语句（使用保存点）\n\nSTART TRANSACTION;update bank set balance=balance-100 where baseAcctId=&#x27;88888888&#x27;;SAVEPOINT time1;update bank set balance=balance+100 where baseAcctId=&#x27;99999999&#x27;;ROLLBACK TO time1;\n然后单独执行commit\n会发现：\n\n","tags":["MySQL性能优化"]},{"title":"18.事务隔离级别","url":"/article/Database-MySQL-PerformanceOptimization-24-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/","content":"ANSI SQL标准定义的四个隔离级别分别为：\n\n\nREAD UNCOMMITTED 读未提交：就是不同事务之间可以对数据是完全相互可见的，事务B可以见到事务A对某张表做的任何操作，在这种隔离性下的安全性非常低。\n\n\nREAD COMMITTED 读已提交：事务A只能看到事务B提交后的操作。这种隔离级别下的安全性相比前者好一点。\n\n\nREPEATABLE READ 可重复读：目前MySQL InnoDB默认的事务隔离级别，在MySQL中已经完全具备ACID特性。\n\n\nSERIALIZABLE 串行化：安全级别最大，但性能上会有损失，由于可重复读已经达到3°隔离，所以本地事务一般不用这个隔离级别，串行化的隔离级别主要用于innoDB的分布式事务中。\n\n\n1.不同事务隔离级别对锁的支持\n\n\n1）读未提交（脏读）：查询数据时不加锁，更新数据也不加锁，正因为这样，其他事务之间才能做到读未提交。\n\n\n2）读已提交（不可重复读）：在读已提交隔离级别下，除了唯一性的约束检查以及外键约束的检查需要Gap Lock（间隙锁），其他情况下InnoDB存储引擎不会使用Gap Lock锁。\n\n\n3）可重复读：查询数据时，使用Next-key Lock锁避免幻读情况。\n\n\n4）串行化：在串行化的隔离级别下，InnoDB会对每个查询语句后自动加上 LOCK IN SHARE MODE（共享锁）。\n\n\n2.不同事务隔离级别的优缺点\n2.1 读未提交（脏读）\n优点：暂时没有\n缺点：由于事务中的修改对其他事务都是可见的，所以事务可以读取未提交的数据，如果那些未提交的数据最后回滚了，那么读到的数据就是脏数据，这会导致很多问题。\n2.2 读已提交\n优点：相比于读未提交，它防止了脏读\n缺点：虽然防止了脏读，但是，它无法避免一致性冲突问题，由于在读已提交隔离性下，一个事务开始时，只能看见已经提交的事务所做的修改\n所以同一个事务执行两次相同的查询时会发生两次查询的结果不一致的情况。\n2.3 可重复读\n优点：防止脏读，一致性冲突问题\n缺点：虽然防止了一致性冲突，但是它无法防止下面的情况：同一个事务中第一次查询时，符合条件的数据有2条，过了一段时间，其他事务插入了一条相同查询条件的数据并提交了，\n那么当再次查询时，会查到三条数据，这显然是不对的（幻读）。\n注意：但MySQL的InnoDB存储引擎通过MVCC防止了幻读的产生，所以在MySQL中，可重复读已经完全具备ACID特性。\n2.4 串行化\n优点：最高的事务隔离级别，安全性最高\n缺点：串行化下的事务会在读取的每一行数据上都加锁，这会导致开销相比前面而言增大了许多。\n下面的图可帮助理解（但和MySQL的隔离级别有一点差别的）：\n\n3.相关操作语句\n3.1 在InnoDB存储引擎中，可以使用下面命令来设置当前会话或全局的事务隔离级别：\nSET  [GLOBAL|SESSION ] TRANSACTION ISOLATION LEVELREAD UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE\n3.2 查询数据库当前的事务隔离级别\nSELECT @@tx_isolation;//查看当前会话隔离级别SELECT @@global.tx_isolation;//查看全局事务隔离级别\n4.上面提到的锁的知识\n4.1 间隙锁\n简单来说过，间隙锁其实就是对范围内的数据进行加锁来防止出现幻读的情况。\n4.2 Next-key Lock锁\n他其实是间隙锁和行级锁的合称，它对应两种情况：\n当进行范围查询时，使用间隙锁进行锁定范围数据。\n当进行索引等值查询时，使用行级锁锁定数据。\n","tags":["MySQL性能优化"]},{"title":"19.分布式事务编程","url":"/article/Database-MySQL-PerformanceOptimization-25-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%BC%96%E7%A8%8B/","content":"InnoDB存储引擎存储了对于XA事务的支持，并通过XA事务来支持分布式事务的实现。\n1.什么是分布式事务？\n分布式事务是指允许多个独立的事务资源（transactional resources）参与到一个全局事务的事务中，其中独立的事务资源可以理解为不同的数据库。\n全局事务要求在其中所有参与的事务要么都提交，要么都回滚，这对于事务原有的ACID要求又有了提高。\n注意：在使用分布式事务时，InnoDB存储引擎的事务隔离级别必须设置为SERIALIZABLE\n2.XA事务\nXA事务允许不同数据库之间的分布式事务，如一台服务器是MySQL数据库的，另一台是Oracle数据库的，\n可能还有一台服务器是SQL Server数据库的，只要参与到全局事务中的每个节点都支持XA事务即可。\n分布式事务可能在银行系统的转账中比较常见，\n比如用户麻子(账户id为1)需要从上海转10009元到北京的用户四郎（账户id为2）的存储卡中：\nBank@shanghai:UPDATE account SET money = money - 10000 WHERE acctId=1;Bank@Beijing:UPDATE account SET money=money+10000 WHERE acctId=2;\n在上面的情况下，一定需要使用分布式事务来保证数据安全。如果发生的操作不能都提交或回滚，\n那么任何一个节点出现问题都会导致严重的后果，例如第一个事务提交了，但第二个事务回滚了，\n那么就会出现麻子的钱扣了但四郎没收到钱的情况，反之就会出现麻子的钱没扣但四郎的账户多了钱的情况，\n这两种情况都是违背法律的。\n在这里XA事务就可以解决上面的问题，那么XA事务是如何解决的呢？\n1）首先XA事务由一个或多个资源管理器（resource manager）,一个事务管理器（transaction manager）以及一个应用程序（application\nprogram）组成。\n\n\n资源管理器：它提供访问事务资源的方法。通常一个数据库就是一个资源管理器。\n\n\n事务管理器：协调参与全局事务中的各个事务。需要和参与到全局事务中的所有资源管理器进行通信。\n\n\n应用程序：定义事务的边界，指定全局事务中的操作。\n在MySQL数据库的分布式事务中，资源管理器就是MySQL数据库，事务管理器为连接到MySQL服务器的客户端。\n其中三者的关系如下图：\n\n2）其次就是分布式事务的执行过程\n分布式事务使用两阶段提交（two-phase commit）的方式进行的。\n\n\n在第一阶段，所有参与全局事务的节点都开始准备（PREPARE），所有节点告诉事务管理器他们准备好了提交了。\n\n\n然后第二阶段事务管理器就会告诉资源管理器执行ROLLBACK还是COMMIT。如果其中任何一个节点显示不能提交，则所有的节点都会被告知需要回滚。\n\n\nMySQL数据库XA事务的SQL语法如下：\n\n\nXA &#123;START|BEGIN&#125; xid  [JOIN|RESUME ]XA END xid  [SUSPEND  [FOR MIGRATE ] ]XA PREPARE xidXA COMMIT xid  [ONE PHASE ]XA ROLLBACK xidXA RECOVER\n\n在单个节点上运行分布式事务没有太大实际意义，但是要在MySQL数据库的命令下演示多个节点参与的分布式事务也是行不通的。\n注意：通常来说，都是通过编程语言来完成分布式事务的操作的。\n2.1 实例演示\n下面展示如何使用JTA（jdk的JTA API，可以很好的支持MySQL的分布式事务）来调用MySQL的分布式事务：\n首先在自己本地创建两个数据库（我是用的以及有的）：\n\n然后在这两个数据库中创建相同的表：\ncreate table accountBank(userid int(11),username varchar(20),money decimal(17,2),primary key(userid));\n接着在employees库插入数据：\ninsert into accountBank values(1,&#x27;麻子&#x27;,1000000);\npeixun数据库插入：\ninsert into accountBank values(2,&#x27;四郎&#x27;,100);\n通过上面的操作，我们已经具备分布式事务编程的场景了（不同的数据库之间保证事务数据一致性）：\n下面进行代码编写：\n首先编写资源管理器唯一标识id生成器：\npackage XaStudy;import javax.transaction.xa.Xid;public class MyXid implements Xid &#123;    public int formatId;    public byte gtRid[];    public byte bqUal[];    public MyXid() &#123;    &#125;    public MyXid(int formatId, byte gtRid[], byte bqUal[]) &#123;        this.formatId = formatId;        this.gtRid = gtRid;        this.bqUal = bqUal;    &#125;    @Override    public int getFormatId() &#123;        return formatId;    &#125;    @Override    public byte[] getGlobalTransactionId() &#123;        return gtRid;    &#125;    @Override    public byte[] getBranchQualifier() &#123;        return gtRid;    &#125;&#125;\n然后编写全局事务管理器：\npackage XaStudy;import com.mysql.cj.jdbc.MysqlXADataSource;import javax.sql.XAConnection;import javax.transaction.xa.XAResource;import javax.transaction.xa.Xid;import java.sql.Connection;import java.sql.Statement;public class XADemo &#123;    public static MysqlXADataSource GetDataSource(String commString, String user, String passwd) &#123;        try &#123;            MysqlXADataSource ds = new MysqlXADataSource();            ds.setUrl(commString);            ds.setUser(user);            ds.setPassword(passwd);            return ds;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return null;        &#125;    &#125;    public static void main(String[] args) &#123;        //数据库1地址        String connString1 = &quot;jdbc:mysql://localhost:3306/employees&quot;;        //数据库2地址        String connString2 = &quot;jdbc:mysql://localhost:3306/peixun&quot;;        try &#123;//创建资源管理器1            MysqlXADataSource ds1 = GetDataSource(connString1, &quot;root&quot;, &quot;yanjiadou&quot;);//创建资源管理器2            MysqlXADataSource ds2 = GetDataSource(connString2, &quot;root&quot;, &quot;yanjiadou&quot;);//获得资源管理器1的连接            XAConnection xaConnection1 = ds1.getXAConnection();            XAResource xaResource1 = xaConnection1.getXAResource();            Connection connection1 = xaConnection1.getConnection();            Statement statement1 = connection1.createStatement();//获得资源管理器2的连接            XAConnection xaConnection2 = ds2.getXAConnection();            XAResource xaResource2 = xaConnection2.getXAResource();            Connection connection2 = xaConnection2.getConnection();            Statement statement2 = connection2.createStatement();//创建资源管理器1的唯一标识            Xid xid1 = new MyXid(100, new byte[]&#123;0x01&#125;, new byte[]&#123;0x02&#125;);//创建资源管理器2的唯一标识            Xid xid2 = new MyXid(100, new byte[]&#123;0x11&#125;, new byte[]&#123;0x12&#125;);            try &#123;                xaResource1.start(xid1, XAResource.TMNOFLAGS);                statement1.execute(&quot;update accountBank set money=money-10000 where userid=1&quot;);                xaResource1.end(xid1, XAResource.TMSUCCESS);                xaResource2.start(xid2, XAResource.TMNOFLAGS);                statement2.execute(&quot;update accountBank set money=money+10000 where userid=2&quot;);                xaResource2.end(xid2, XAResource.TMSUCCESS);//资源管理器1第一阶段准备                int ret1 = xaResource1.prepare(xid1);//资源管理器2第一阶段准备                int ret2 = xaResource2.prepare(xid2);//事务管理器提交                if (ret1 == XAResource.XA_OK &amp;&amp; ret2 == XAResource.XA_OK)&#123;                    xaResource1.commit(xid1, false);                    xaResource2.commit(xid2, false);                &#125;            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n执行之：\n\n看看数据库是否发生变化:\n\n\n我们可以看到麻子的账户确实少了10000元，四郎的账户确实多了10000元。\n上面的是正常的情况，下面如果测试下不正确的情况下，全局事务管理器是否会防止事故发生\n我们故意将：\nstatement2.execute(&quot;update accountBank set money=money+10000 where userid=2&quot;);\n改成：\nstatement2.execute(&quot;update accountBank set money=money+10000 where userid=1&quot;);\n然后执行，发现数据库中果然出现了事故：\n\n\n这里由于某种原因导致四郎的userid出错了（但sql没错），实际上，四郎并没有接受到钱，但麻子的账户却扣了钱。\n那么这里我们该如何解决呢？\n我们可以先获取受影响的行来进行判断是否进行是否进行提交：\npublic class Test &#123;    public static void main() &#123;        try &#123;            xaResource1.start(xid1, XAResource.TMNOFLAGS);            int num1 = statement1.executeUpdate(&quot;update accountBank set money=money-10000 where userid=1&quot;);            xaResource1.end(xid1, XAResource.TMSUCCESS);            xaResource2.start(xid2, XAResource.TMNOFLAGS);            int num2 = statement2.executeUpdate(&quot;update accountBank set money=money+10000 where userid=1&quot;);            xaResource2.end(xid2, XAResource.TMSUCCESS);            if (num1 == 1 &amp;&amp; num2 == 1) &#123;//资源管理器1第一阶段准备                int ret1 = xaResource1.prepare(xid1);//资源管理器2第一阶段准备                int ret2 = xaResource2.prepare(xid2);//事务管理器提交                if (ret1 == XAResource.XA_OK &amp;&amp; ret2 == XAResource.XA_OK) &#123;                    xaResource1.commit(xid1, false);                    xaResource2.commit(xid2, false);                &#125;            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n这样，不论是sql错误导致问题还是条件异常导致错误，都不会导致分布式事务问题。\n","tags":["MySQL性能优化"]},{"title":"1.Spring概述","url":"/article/SpringFramework-1-Spring%E6%A6%82%E8%BF%B0/","content":"1.1 简化开发\nSpring的目标是致力于全方位的简化Java程序的开发，那么Spring是如何做到这一点的呢？\nSpring的设计理念总结为四点，如下：\n基于POJO的轻量级和最小侵入式编程\n通过依赖注入和面向接口实现类与类之间的松耦合\n基于切面和惯例进行声明式编程实现一些通用功能\n通过切面和模板减少样板式代码\nSpring中所做的所有事的基础都可以追溯到上面的一条或多条！！\n1.1.1 理解非侵入式概念\nPOJO就是简单的，不继承依赖外部类的独立的Java类，也就是说一个POJO可以独立的运行起来。\n（除了依赖jdk内部的一些类，POJO不依赖于任何的外部扩展类）\n（1） 什么是侵入式编程\n侵入式编程简单来说就是一种编程方式，它采用继承或依赖的的方式使类和类之间强耦合，从而导致灵活性下降，例如：\n我们要实现一个DvdPlayer类和Video类，其中Video类继承了DvdPlayer类的播放方法使得Video具有播放功能，使用侵入式编程，我们可以这样写：\npublic class DvdPlayer{\npublic void play(String content){\nSystem.out.println(content);\n}\n}\npublic class Video extends DvdPlayer{\nprivate String content = “Hello is me”;\npublic void playVideo(){\nthis.play(content);\n}\npublic void setContent(String content){\nthis.content = content;\n}\n}\n这样做了之后，Video就离不开DvdPlayer类了，没了DvdPlayer，Video就无法编译通过，如果DvdPlayer本身也继承了其他类，这就会引起连锁反应。侵入式编程会使整个项目向臃肿，复杂的方向上靠。\n（2）非侵入式编程\n了解了前面的侵入式编程，我们是否有一种其他的方式，既能实现上述功能，又能使其弱耦合呢？答案就是非侵入式编程，什么是非侵入式编程呢？ 就是以组合接口的形式使类和类之间的关联依赖降低至类与接口的之间的关联，通过接口降低类与类之间的耦合性。\n好，下面通过这种思想来解决上面的问题：\n首先我们需要创建一个Dvd接口：\npublic interface Dvd{\npublic void play(String content);\n}\n然后Video类组合这个接口，并且提供注入实现Dvd接口的实体类的方式：\npublic class Video{\nprivate Dvd dvdPlayer;\nprivate String content = “Hello is me”;\npublic void playVideo(){\ndvdPlayer.paly(content);\n}\npublic void setContent(String content){\nthis.content = content;\n}\npublic void setDvd(Dvd dvdPlayer){\nthis.dvdPlayer = dvdPlayer;\n}\n}\n这样做的好处是什么呢？ 很明显，这样了之后，我们可以脱离DvePlayer进行独自编译，且可以提供play的多种实现方式并注入使用。但是这样做并不是完全的非侵入式编程，因为它确实还依赖了接口Dvd，所以称之为最小侵入式编程。\n注意：上面提到的注入就是我们所说的依赖注入，也就是说类与类之间的依赖不通过硬编码的方式进行定义，而通过注入的方式进行定义，这样做灵活性更强。 关于依赖注入的详细内容将在下一节进行说明。\n最后DvdPlayer实现Dvd接口即可\npublic class DvdPlayer implements Dvd{\npublic void play(String content){\nSystem.out.println(content);\n}\n}\nOK,了解了侵入式和非侵入式的含义，我们可以知道侵入式编程让类与类之间的耦合度很高，这样不利于系统的弹性变更，而非侵入式编程让类和类之间的耦合度很低，使系统更具弹性。\n1.1.2 切面初了解\n我们知道通过最小侵入式编程的依赖注入可以让类与类之间保持松耦合，那么如何实现代码的可重用性呢？\n就是如何将那些重复的操作代码提取出来放在某一个地方，既能保持这个地方与他作用的类的松耦合，也能保持这个地方的代码发生作用？\n举个例子，\n我们现在有两个类，一个是学生实体类，另一个是教师实体类：\npublic class Student {\nprivate String name;\nprivate int age;\nprivate String sex;\npublic Student(){}\npublic Student(String name,int age,String sex){\nthis.name = name;\nthis.age = age;\nthis.sex = sex;\n}\npublic void disPlay() {\nSystem.out.println(“我的名字是：”+name);\n}\npublic void speak(){\nSystem.out.println(“你好！！”)\n}\n}\npublic class Teacher {\nprivate String name;\nprivate int age;\nprivate String sex;\npublic Teacher(){}\npublic Teacher(String name,int age,String sex){\nthis.name = name;\nthis.age = age;\nthis.sex = sex;\n}\npublic void disPlay() {\nSystem.out.println(“我的名字是：”+name);\n}\npublic void speak(){\nSystem.out.println(“你好！！”)\n}\n}\n哎呀，这可是个糟糕的设计，很明显，教师类和学生类几乎一样，代码重复率高达90%，不行，我们得重新设计一下，于是，我先到了继承，通过继承来提高代码的重用性，这个方式怎么样呢？ 我们先试试吧\n首先，我们先建立一个Person类：\npublic class Person {\npublic String name;\npublic int age;\npublic String sex;\npublic Person(){}\npublic Person(String name,int age,String sex){\nthis.name = name;\nthis.age = age;\nthis.sex = sex;\n}\npublic void disPlay() {\nSystem.out.println(“我的名字是：”+name);\n}\npublic void speak(){\nSystem.out.println(“你好！！”);\n}\n}\n然后，学生类是这样的：\npublic class Student extends Person{\npublic Student(){}\npublic Student(String name,int age,String sex){\nsuper(name,age,sex);\n}\n}\n老师类是这样的：\npublic class Teacher extends Person{\npublic Teacher(){}\npublic Teacher(String name,int age,String sex){\nsuper(name,age,sex);\n}\n}\n我们发现，这这样做确实能将重复的代码给抹掉，但是，这样一来，老师类和Person类的耦合度也上来了啊，我们又进入了侵入式编程噩梦。。。。\n我们该如何摆脱现状呢？ 这时，AOP出现了，面向切面编程，通过AOP理论，我们可以既能实现代码的复用，又能做到最小侵入式编程，AOP存在的意义大概就是如此吧。\n1.2 了解Spring包含的各种组件\n通过前面的了解，我们总结： Spring关注于通过依赖注入，面向切面编程等基础理论来简化企业级Java开发。\n其实，Spring的功能不仅如此，在Spring框架范畴内，我们可以发现Spring简化Java开发的多种方式。除此之外，在Spring基础支持上，我们还可以构建庞大的生态圈：WEB服务，REST , 移动开发以及NoSQL。\n下面让我们来了解下Spring框架的核心，来看看它究竟为我们带来了什么？\n1.2.1 Spring模块\n当我们去下载Spring发布版本时，我们会发现其lib依赖目录下有多个jar文件，其中大概有20多类的jar文件，每一类代表一个模块，我们可以选择其中某些模块进行使用，也可以都用，这看我们自己的选择。\n\n其中,Core Container为我们提供了完整的依赖注入支持，这涉及到容器。 在这个基础上构建了AOP, Aspects,Messaging等模块。\n好啦，现在去了解这些还为时尚早，就混个脸熟，等彻底理解的DI和AOP的精髓再去看这些也许就会变得简单。\n","tags":["Spring"]},{"title":"1.IOC设计理念","url":"/article/SpringFramework-2-IOC%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5/","content":"1.什么是IOC（控制反转）？\n控制反转的意思是将创建实例的权利交给框架去做，我们不需要关心如何在程序中去创建一个对象，然后去使用它，我们只需要提前配置好对象的一些信息，然后在框架下的程序中就可以直接使用，无需new。因为框架会自动的为我们分配我们需要的对象。\n这，便是控制反转。 很神奇对吧，它到底是如何做到的呢？ 其实我们仔细想想也不难。这无非就是实现一个容器，在运行我们的程序之前让容器自动的创建对象，然后注入到我们的程序中，这样我们的程序中就拥有了实例，就可以正常运行了。\n2.实现一个简单的IOC容器\n那么如何去实现这个简单的IOC容器呢？\n我们先思考下如下问题：\n我们如何要保证我们的程序是基于容器运行？\n如何让容器自动创建对象呢？ （扩展）\n如何如何让容器准确的创建我们需要的对象？\n有些对象我们只要创建一个，而有些则需要按情况来创建，如何让容器做到这一点？（扩展）\n下面开始设计：\n我们首先设计容器(一个类) 命名为：ApplicationContext\n我们首先要知道这个类的作用，首先这个类必须要的功能是作为一个容器装载生成的对象，其次这个类还需要有根据配置创建我们想要的对象的能力。\n所以我们决定给这个类声明一个Map类型的对象用来装载对象，借用它的构造方法来生成对象\n/**\n* IOC容器，功能是自动创建对象和对象实例存储，\n* 可以让我们直接使用实例化的对象\n*/\npublic class ApplicationContext {\n/**\n* 存储单例对象\n*/\nprivate final Map&lt;String,Object&gt; singleObjContext;\npublic ApplicationContext(List objectConfigs){\n}\n/**\n* 从容器中获取指定名称对象\n* @param beanName 对象名称\n* @return\n*/\npublic Object getObject(String beanName){\nreturn singleObjContext.get(beanName);\n}\n}\n好啦，下面基本的模子搭建好了，下面就要进行考虑如何让容器正确的创建对象了：\n我们知道创建一个对象需要的要素有下面几个：\n我们得知道这个对象的类型\n我们得知道这对象的属性，并可以为属性赋值\n我们得为这个对象声明一个名称\n由上可知，我们可以设计一个这样的配置类（省略了get set方法，自行补充）：ObjectConfig\npublic class ObjectConfig {\n/**\n* 存储对象名称\n*/\nprivate String beanName;\n/**\n* 存储对象类型\n*/\nprivate Class&lt;?&gt; cl;\n/**\n* 存储对象属性名称和赋的值\n*/\nprivate Map&lt;String,Object&gt; diMap;\n/**\n* 标注注入的字段类型是基本类型还是引用类型\n*/\nprivate Map&lt;String,String&gt; valueType;\npublic ObjectConfig(){\ndiMap = new HashMap&lt;&gt;();\nvalueType = new HashMap&lt;&gt;();\n}\n}\n好了有了这些，我们就可以根据这个来写最关键方法了：\n主要用到反射特性，不了解的同学可以先了解下反射。此方法存在缺陷，想要改进的同学可以进行改进，不过这里只是为了演示学习主题，故不做太多弹性处理。\npublic ApplicationContext(List objectConfigs){\nsingleObjContext = new HashMap&lt;&gt;();\nfor (ObjectConfig objectConfig : objectConfigs) {\ntry {\nString beanName = objectConfig.getBeanName();\nClass&lt;?&gt; className = objectConfig.getCl();\nMap&lt;String, Object&gt; diMap = objectConfig.getDiMap();\nObject obj = className.getConstructor().newInstance();\nField[] fields = className.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\n//遍历注入\nfor (Field field : fields) {\nif (diMap.containsKey(field.getName())) {\nClass&lt;?&gt; cl = diMap.get(field.getName()).getClass();\n//如果字段类型是传入参数类型的父类型或者相等类型\nif(field.getType().isAssignableFrom(cl)||field.getType().equals(cl)){\nfield.set(obj,diMap.get(field.getName()));\n}else{\nthrow new Exception(“类型传输错误！！”);\n}\n}\n}\nsingleObjContext.put(beanName, obj);\n} catch (Exception e) {\ne.printStackTrace();\n}\n}\n}\n写完之后，我们可以进行测试一下：\n首先我们写一个Person类，然后进行配置并使用容器进行创建Person对象。\npublic class Person {\nprivate String name;\nprivate Integer age;\nprivate String sex;\nprivate Integer height;\nprivate Integer weight;\n}\npublic class Test {\npublic static void main(String[] args) {\nObjectConfig objectConfig = new ObjectConfig();\nobjectConfig.setBeanName(“person”);\nobjectConfig.setCl(Person.class);\nMap&lt;String ,Object&gt; diMap = objectConfig.getDiMap();\ndiMap.put(“name”,“牧之”);\ndiMap.put(“age”,12);\ndiMap.put(“sex”,“男”);\ndiMap.put(“height”,170);\ndiMap.put(“weight”,110);\nList objectConfigList = new ArrayList&lt;&gt;();\nobjectConfigList.add(objectConfig);\nApplicationContext applicationContext = new ApplicationContext(objectConfigList);\nPerson person = (Person) applicationContext.getObject(“person”);\nSystem.out.println(person.toString());\n}\n}\n从上面的测试代码中我们可以看到，从始至终都没有new Person（），我们是通过容器来的带Person对象的。\n下面我们来看看，能否成功得到person对象：\n\n我们可以看到，通过配置式的方式，我们确实通过容器得到Person对象。\n由此我们可以总结出： IOC容器其实就是一个通过某些配置的方式来自动获得我们想要的对象的一个工具。\n3.使用IOC容器和不使用IOC容器编程有什么不同的体验？\n通过前面的学习，我们实现了一个简单的IOC容器，下面我们来对比一下，使用容器常见对象并使用和不使用容器进行编程的区别：\npublic class Test {\npublic static void main(String[] args) {\nnew Test().IOCCoding();\nnew Test().NormalCoding();\n}\npublic void IOCCoding(){\nObjectConfig objectConfig = new ObjectConfig();\nobjectConfig.setBeanName(“person”);\nobjectConfig.setCl(Person.class);\nMap&lt;String ,Object&gt; diMap = objectConfig.getDiMap();\ndiMap.put(“name”,“牧之”);\ndiMap.put(“age”,12);\ndiMap.put(“sex”,“男”);\ndiMap.put(“height”,170);\ndiMap.put(“weight”,110);\nList objectConfigList = new ArrayList&lt;&gt;();\nobjectConfigList.add(objectConfig);\nApplicationContext applicationContext = new ApplicationContext(objectConfigList);\nPerson person = (Person) applicationContext.getObject(“person”);\nSystem.out.println(person.toString());\n}\npublic void NormalCoding(){\nPerson person = new Person();\nperson.setName(“四郎”);\nperson.setAge(12);\nperson.setSex(“男”);\nperson.setHeight(170);\nperson.setWeight(110);\nSystem.out.println(person);\n}\n}\n\n二者结果一样，但是从直观上看，会不会给人一种感觉，使用容器好像代码量更大了，好像更复杂了呀！！\n如果你这样认为，那么说明你还没理解到容器的强大之处！\n下面我们解析一下上面的使用容器的那部分代码：\n\n在实际的使用过程中,其实使用容器进行编程的代码就两行：\nApplicationContext applicationContext = new ApplicationContext(objectConfigList);\nPerson person = (Person) applicationContext.getObject(“person”);\n我们只需要在某个地方配置好相应的信息，容器会自动读取并为我们创建好对象，我们只管获取就好了。\n甚至在Spring上，我们连获取都不用操心了，所有的都可以通过配置的方式实现，我们只管使用就好啦！！\n下面我们来学习Spring对IOC是怎么支持的。。\n4.Spring中对IOC的支持\n在Spring中，我们可以通过下面注解来了解：\n@Component 注解： 作用在类上，用来声明这个类将在容器初始化的时候进行对象的加载。\n@Service 注解： 和@Component作用一样，但是它有它的特殊含义，一般用它来修饰业务类。\n@Repository注解： 和@Component作用一样，但是它有它的特殊含义，一般用它来修饰数据库操作类。\n@Controller注解：和@Component作用一样，但是它有它的特殊含义，一般用它来修饰控制器类。\n@Autowired注解： 注入注解，用它来实现属性注入，类似的还有 @Inject, @Resource\n@Configuration注解：用来标志某个类为配置类\n@ComponentScan注解：用来配置类上，表示让容器自动扫描配置类平级包或子包进行自动装配。\n@Qualifier: 用来解决歧义注入的。\n@Scope: 用来设置bean的作用域，也就是控制bean是只创建一个还是根据需求创建。\n好了，下面我们通过Spring来实现第3小节的例子：\n首先，我们要在最外层目录下新建一个配置类：\n\n然后，新建一个Person类并使用注解修饰：\n\n接着建立一个组件类：ChangePerson\n\n最后，在测试方法上初始化容器并获得我们想要的对象，在整个过程中，我们没用用到new\n\n成功获得Person对象：\n\n有些人会对上面的某些地方有疑问，不要着急，照着实操，实操成功基本了解后，下面就开始理解其中的一些细节性的东西了。（包含你产生的疑问）\n","tags":["Spring"]},{"title":"5.了解SpringCloud","url":"/article/SpringFramework-4-%E4%BA%86%E8%A7%A3SpringCloud/","content":"一.单体应用\n就是所有功能都堆积到一起。这个应用大部分是一个war包或者jar包。但是随着业务的发展，功能的增加，多年后这个单体项目变的越来越臃肿，难以管理和维护。\n二.改进单体应用架构\n架构总是通过演变而来的，既然传统的单体架构不能满足业务的发展，那么架构的改变必然会提上日程。在系统不能支撑当前的用户量后，我们将项目按照不同的业务来做拆分，分成多个子系统，系统之间通过Webservice或者HTTP接口进行交互，这样做的好处就是系统不再那么臃肿了。\n但是随着用户越来越多，系统的压力也随之增长。可能其中某一个模块使用的频率比较高，这个时候就需要对该模块进行扩展（其实就是多部署几个节点），然后再前面加一个Nginx用于负载均衡，刚开始可能还没有什么大问题，但是当子系统越来越多的时候，每个子系统前面都要加一个负载均衡，这对运维人员来说工作量就增加了。\n三.向微服务靠拢\n1.什么是微服务？\n微服务是一种架构风格，就是将单体应用划分为小型的服务单元，微服务之间使用Http的API进行资源访问与操作。\n2.使用微服务的优势与缺点\n优势：\n1）服务的独立部署：每个服务都是一个独立的项目，可以进行独立部署，不依赖于其他服务，耦合度低。\n2）服务的快速启动：拆分之后服务启动的速度必然要比没拆之前的快很多，因为依赖的库少了，代码量也少了。\n3）更加适合敏捷开发：敏捷开发以用户的需求进化为核心，采用迭代，循序渐进的方法进行。服务拆分可以快速发布新版本，修改那个服务只需要发布对应的服务即可，不用整体重新发布。\n4）职责专一，指定的团队负责指定的服务：业务发展迅速时，研发人员也会越来越多，每个团队可以负责对应的业务线，服务的拆分有利于团队之间的分工。\n5）服务可以动态按需扩充：当某个服务的访问量较大时，我们只需要将这个服务进行扩容。\n6）代码的复用：每个服务都提供REST API，所以的基础服务都必须抽出来，很多底层实现都可以以接口方式提供。\n缺点：\n1）分布式部署，调用复杂性高：在微服务中，每个模块都是独立部署的，通过Http来进行通信，其中一定会产生许多问题，比如网络问题，容错问题，调用关系等等。\n2）独立的数据库，分布式事务的挑战：每个微服务都有自己的数据库，这样的优势在于不同的服务可以选择适合自身业务的数据库。 但是如何实现一致性是个难点，目前最理想的解决方案就是柔性事务中的最终一致性。\n3）测试的难度提升了：在微服务项目中，服务和服务之间通过接口来进行交互，当接口有改变的时候，对所有的调用方都是有影响的，这个时候自动化测试就非常重要了，如果靠人一个个接口去测试，那工作量太大了。\n4）运维的难度提升：这个可以想到。\n3.重构前的准备工作\n四.了解SpringCloud\n1.什么时SpringCloud？\n它是一系列框架的有序集合。他利用Spring boot的开发便利性，巧妙的简化了分布式系统基础设施的开发，比如服务注册，服务发现，配置中心，消息总线，负载均衡，断路器，数据监控等，都可以用Springboot的开发风格做到一键启动和部署。 通俗的讲，SpringCloud就是用于构建微服务开发和治理的框架集合。\n2.SpringCloud模块介绍\n1）Eureka：服务注册中心，用于服务管理。\n2）Ribbon：基于客户端的负载均衡组件。\n3）Hystrix:容错框架，能够防止服务的雪崩效应。\n4）Feign:Web服务客户端，能够简化http接口的调用。\n5）Zuul:API网关，提供路由转发，请求过滤等功能。\n6）Config:分布式配置管理。\n7）Stream:构建消息驱动的微服务应用程序的框架。\n8）Bus:消息代理的集群消息总线。\n上面的都是常用的框架，还有许多框架。\n3.SpringCloud版本介绍\n因为SpringCloud是一个拥有许多子项目的大型综合项目，可以说是对微服务架构解决方案的综合套件组件，其中包含的各个子项目都独立进行着内容的迭代和更新，各自维护自己的发布版本号。\n对于初学者，还是选择最新的稳定版较好。\n五.开发环境的准备\n1.JDK:java开发环境\n2.Maven:项目构建工具\n3.Eclipse:集成开发工具\n","tags":["Spring"]},{"title":"5.SpringBoot学习","url":"/article/SpringFramework-5-SpringBoot%E5%85%A5%E9%97%A8/","content":"1.什么是SpringBoot？\n它是一个框架，其设计的目的就是简化新的Spring应用的初始化搭建及开发过程。该框架使用了特定的方式进行配置，从而使开发人员不再需要定义样本话的配置。SpringBoot致力于在蓬勃发展的快速应用开发领域成为领导者。\n在使用SpringBoot之前，我们需要搭建一个项目框架并配置各种第三方库的依赖，还需要在XML中配置很多的内容。SpringBoot完全打破了我们之前的使用习惯，一分钟就可以创建一个Web开发的项目,通过Starter的方式可以轻松集成第三方的框架，去掉了XML配置使用注解代替。\n2.什么是SpringBootStarter？\n它是用来简化jar包依赖的，集成一个框架我们只需引入一个Starter，然后在属性文件中配置一些值，整个集成过程就结束了。SpringBoot在内部做了很多处理，让开发人员使用起来更加简单了。\n3.SpringBoot开发的优点\n1）基于Spring开发Web应用更加容易。\n2）采用基于注解方式的配置，避免了编写大量重复的XML配置。\n3）可以轻松集成Spring家族的其他框架，比如SpringJDBC,Spring Data等。\n4）提供嵌入式服务器，开发和部署都变得很方便。\n4.搭建SpringBoot项目\n其实，搭建maven项目过程中最重要的文件就是pom.xml ，编写它可以添加依赖。\npom.xml详解 - 艺意 - 博客园 (cnblogs.com)\n","tags":["Spring"]},{"title":"1.AOP设计理念","url":"/article/SpringFramework-3-AOP%E7%9A%84%E5%A5%BD%E5%A4%84/","content":"1.什么是AOP?\nAOP 中文名称为面向切面编程，英文全称：Aspect Oriented Programming。\n是一种通过预编译或运行期间动态代理实现程序功能的一种编程，简单来说就是一种高级的代码复用技术，它既实现了代码高度复用，也一一种特殊的方式使复用部分的影响降到很低，甚至没有。既增加了功能，又没有增加耦合。\n2.实现一个自己的AOP支持\n前面的解释也许还是有点抽象，下面我们以实际的例子来理解什么面向切面编程，我们将通过一次需求的程序实现和代码优化来引出切面编程技术的必要性。\n2.1 有个需求\n我们现在有两个类，一个是学生实体类，另一个是教师实体类：\npublic class Student {\nprivate String name;\nprivate int age;\nprivate String sex;\npublic Student(){}\npublic Student(String name,int age,String sex){\nthis.name = name;\nthis.age = age;\nthis.sex = sex;\n}\npublic void disPlay() {\nSystem.out.println(“我的名字是：”+name);\n}\npublic void speak(){\nSystem.out.println(“你好！！”)\n}\n}\npublic class Teacher {\nprivate String name;\nprivate int age;\nprivate String sex;\npublic Teacher(){}\npublic Teacher(String name,int age,String sex){\nthis.name = name;\nthis.age = age;\nthis.sex = sex;\n}\npublic void disPlay() {\nSystem.out.println(“我的名字是：”+name);\n}\npublic void speak(){\nSystem.out.println(“你好！！”)\n}\n}\n哎呀，这可是个糟糕的设计，很明显，教师类和学生类几乎一样，代码重复率高达90%，不行，我们得重新设计一下，于是，想到了继承，通过继承来提高代码的重用性，这个方式怎么样呢？ 我们先试试吧\n首先，我们先建立一个Person类：\npublic class Person {\npublic String name;\npublic int age;\npublic String sex;\npublic Person(){}\npublic Person(String name,int age,String sex){\nthis.name = name;\nthis.age = age;\nthis.sex = sex;\n}\npublic void disPlay() {\nSystem.out.println(“我的名字是：”+name);\n}\npublic void speak(){\nSystem.out.println(“你好！！”);\n}\n}\n然后，学生类继承它，是这样的：\npublic class Student extends Person{\npublic Student(){}\npublic Student(String name,int age,String sex){\nsuper(name,age,sex);\n}\n}\n类似的老师类是这样的：\npublic class Teacher extends Person{\npublic Teacher(){}\npublic Teacher(String name,int age,String sex){\nsuper(name,age,sex);\n}\n}\n我们发现，这样做确实能将重复的代码给抹掉，但是，这样一来，学生，老师类和Person类的耦合度也上来了啊，我们又进入了侵入式编程噩梦。。。。\n我们该如何摆脱现状呢？ 这时，AOP出现了，面向切面编程，我们可以通过面向切面编程来避免上面的侵入式噩梦。\n2.2 真正理解AOP\n那么问题来了，我们自己该如何实现一个简单的AOP技术支持呢？ 通过前面的定义我们知道了：\nAOP是一种通过预编译或运行期间动态代理实现程序功能的一种编程技术。 其中一个关键字： 运行时期动态代理。\n也许这是我们的一个实现方向。\n2.2.1 我们先了解一下什么是代理？\n代理，简单来说就是将一个类的某些功能组合到其他的类中，让其他类代替主类调用来达到一些目的。\n代理分为静态代理和动态代理，下面先说静态代理，理解了静态代理，动态代理也就好理解了。（\n由于动态代理机制在jdk中已经提供，后面学习动态代理时，我们将直接使用jdk的相关api即可）\n举个例子:\n新建一个Hello.java\npublic class Hello{\npublic Integer sayHello() {\nSystem.out.println(“hello world!!”);\nreturn 8;\n}\npublic void sayBye() {\nSystem.out.println(“BBye”);\n}\n}\n如果我们不想让这个Hello的sayHello直接被调用，而是想在调用这个sayHello之前希望先做个自我介绍，但是由不想动原有的代码，这时我们可以增加一个代理类：HelloProxy 代替我们调用Hello中的sayHello\npublic class HelloProxy {\nprivate Hello hello;//组合\npublic Integer sayHello() {\nSystem.out.println(“my name is wang”);\nhello.sayHello();//代理调用\nreturn 8;\n}\npublic HelloProxy(HelloInterface hello){\nthis.hello = hello;\n}\n}\n这便是代理了。\npublic class Main {\npublic static void main(String[] args) {\nnew HelloProxy(new Hello()).sayHello();\n}\n}\n\n但是上面的代理类还是依赖具体了，这在实际上并达不到我们的目的，还有更好的实现，你觉得该怎么做呢？\n（我们不应该依赖具体，而应该依赖抽象）\n2.2.2 通过静态代理实现代码复用\n好了，前面学习了静态代理，我们尝试使用静态代理来解决我们最初要解决的问题。\n首先，我们可以新建一个接口：personInterface\npublic interface personInterface {\npublic void disPlay();\npublic void speak();\n}\n然后让Person实现它：\npublic class Person implements personInterface{\npublic String name;\npublic int age;\npublic String sex;\npublic Person(){}\npublic Person(String name,int age,String sex){\nthis.name = name;\nthis.age = age;\nthis.sex = sex;\n}\npublic void disPlay() {\nSystem.out.println(“我的名字是：”+name);\n}\npublic void speak(){\nSystem.out.println(“你好！！”);\n}\n}\n好啦，下面我们该如何编写Student或Teacher呢？\n参考设计如下：\npublic class Student{\nprivate personInterface person;\npublic int studyId;\npublic Student(){}\npublic Student(personInterface person){\nthis.person = person;\n}\npublic void disPlay() {\nperson.disPlay();\n}\npublic void speak(){\nperson.speak();\n}\n}\n终于，通过静态代理解决了侵入式的问题，但是好像也只是省略了一点代码，并没有达到极致复用，还是有一些地方冗余了，就是那些方法的定义上。这个问题能解决吗？ 当然可以，通过动态代理，我们可以解决\n2.2.2 动态代理\n我们先来实现一个动态代理的Demo:\n首先，新建一个Hello的接口：\npublic interface HelloInterface {\nInteger sayHello();\nvoid sayBye();\n}\n然后提供一个实现:\npublic class Hello implements HelloInterface{\n@Override\npublic Integer sayHello() {\nSystem.out.println(“hello world!!”);\nreturn 8;\n}\n@Override\npublic void sayBye() {\nSystem.out.println(“BBye”);\n}\n}\n下面是用动态代理来对Hello进行代理调用，建立一个代理类：\nProxyHandler 实现jdk中的接口InvocationHandler\n/**\n* 动态代理类\n*/\npublic class ProxyHandler implements InvocationHandler {\n//被代理对象\nprivate Object object;\npublic ProxyHandler(Object object){\nthis.object = object;\n}\n@Override\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\nSystem.out.println(&quot;Before invoke &quot; + method.getName());\nmethod.invoke(object, args);\nSystem.out.println(&quot;After invoke &quot; + method.getName());\nreturn null;\n}\n}\n其中invoke方法是关键，我们先不细看，下面会根据使用实例来进行深入理解。\n最后，我们编写一个测试Test\npublic class Test {\npublic static void main(String[] args) {\nHelloInterface hello = new Hello();\nInvocationHandler handler = new ProxyHandler(hello);\n//Class[] classes = hello.getClass().getInterfaces();\n//执行被代理对象的相关逻辑\nHelloInterface proxyHello = (HelloInterface) Proxy.newProxyInstance(hello.getClass().getClassLoader(), hello.getClass().getInterfaces(), handler);\nproxyHello.sayHello();\nproxyHello.sayBye();\n}\n}\n\n我们可以看到，最后对代理目标方法的调用实际上就是执行代理类中的invoke方法调用，其中对目标方法的调用被包装在代理类中，我们可以在代理类执行目标方法之前或之后添加前置/后置处理，这便是AOP。 好处就是以一种很小的侵入式方式实现目标方法功能增强。\n当然，除了上面的JDK动态代理支持来实现，我们也可以用一种绝对无侵入的方式进行动态代理编程，那便是CGLIB：\n注意：使用CGLIB进行动态代理编程，我们需要引入cglib.jar包。\n例子如下：\n首先编写一个目标类：\npublic class UserDao {\npublic void select(){\nSystem.out.println(“UserDao 查询 selectById”);\n}\npublic void update(){\nSystem.out.println(“UserDao 更新 update”);\n}\n}\n然后编写针对这个类的前置后置处理实现类：\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\nimport java.lang.reflect.Method;\npublic class LogInterceptor implements MethodInterceptor {\n@Override\npublic Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\nbefore();\nObject result = methodProxy.invokeSuper(o,objects);\nafter();\nreturn result;\n}\npublic void before(){\nSystem.out.println(“前置处理”);\n}\npublic void after(){\nSystem.out.println(“后置处理”);\n}\n}\n注意，上面两个类没有任何继承或组合的关系！！\n下面我们使用CGlib来进行生产代理类（相当于配置的方式）：\nimport net.sf.cglib.proxy.Enhancer;\npublic class CglibTest {\npublic static void main(String[] args) {\nLogInterceptor logInterceptor = new LogInterceptor();\nEnhancer enhancer = new Enhancer();\nenhancer.setSuperclass(UserDao.class);\nenhancer.setCallback(logInterceptor);\nUserDao dao = (UserDao) enhancer.create();\ndao.select();\ndao.update();\n}\n}\n\n这种方式的优点就是无侵入，很灵活。\n2.3 实现自己的AOP技术支持\n在学习完前面的静态代理和动态代理后，我突然有了以下认知：\n静态代理就是我们人为的创建代理类然后进行使用。\n动态代理就是在一些规则下根据配置在运行时动态的生成代理类供系统使用。\n根据这个思路，我就想：\n我自己能不能写一个代理类自动生成器可以根据配置自动生成java源文件，然后我们根据java提供的内置编译器对其进行编译加载，然后创建实例供系统使用呢？\n想法有了，于是我就开始构思和实现了，终于，事实证明我的想法时可行的，下面分享下我自己实现的动态代理实现：\n涉及到的技术主要有： 反射，编译器，类加载器等知识，大家可以先复现，然后自己去仔细研究。\n代码如下：\nCharSequenceJavaFileObject.java\npackage AOP.base.ClassMake;\nimport javax.tools.SimpleJavaFileObject;\nimport java.io.*;\nimport java.net.URI;\nimport java.net.URISyntaxException;\npublic class CharSequenceJavaFileObject extends SimpleJavaFileObject {\npublic static final String CLASS_EXTENSION = “.class”;\npublic static final String JAVA_EXTENSION = “.java”;\nprivate static URI fromClassName(String className) {\ntry {\nreturn new URI(className);\n} catch (URISyntaxException e) {\nthrow new IllegalArgumentException(className, e);\n}\n}\nprivate ByteArrayOutputStream byteCode;\nprivate final CharSequence sourceCode;\npublic CharSequenceJavaFileObject(String className, CharSequence sourceCode) {\nsuper(fromClassName(className + JAVA_EXTENSION), Kind.SOURCE);\nthis.sourceCode = sourceCode;\n}\npublic CharSequenceJavaFileObject(String fullClassName, Kind kind) {\nsuper(fromClassName(fullClassName), kind);\nthis.sourceCode = null;\n}\npublic CharSequenceJavaFileObject(URI uri, Kind kind) {\nsuper(uri, kind);\nthis.sourceCode = null;\n}\n@Override\npublic CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\nreturn sourceCode;\n}\n@Override\npublic InputStream openInputStream() {\nreturn new ByteArrayInputStream(getByteCode());\n}\n// 注意这个方法是编译结果回调的OutputStream，回调成功后就能通过下面的getByteCode()方法获取目标类编译后的字节码字节数组\n@Override\npublic OutputStream openOutputStream() {\nreturn byteCode = new ByteArrayOutputStream();\n}\npublic byte[] getByteCode() {\nreturn byteCode.toByteArray();\n}\n}\nJdkDynamicCompileClassLoader.java\npackage AOP.base.ClassMake;\nimport com.sun.istack.internal.Nullable;\nimport javax.tools.JavaFileObject;\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\npublic class JdkDynamicCompileClassLoader extends ClassLoader {\npublic static final String CLASS_EXTENSION = “.class”;\nprivate final Map&lt;String, JavaFileObject&gt; javaFileObjectMap = new HashMap&lt;&gt;();\npublic JdkDynamicCompileClassLoader(ClassLoader parentClassLoader) {\nsuper(parentClassLoader);\n}\n@Override\nprotected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {\nJavaFileObject javaFileObject = javaFileObjectMap.get(name);\nif (null != javaFileObject) {\nCharSequenceJavaFileObject charSequenceJavaFileObject = (CharSequenceJavaFileObject) javaFileObject;\nbyte[] byteCode = charSequenceJavaFileObject.getByteCode();\nreturn defineClass(name, byteCode, 0, byteCode.length);\n}\nreturn super.findClass(name);\n}\n@Nullable\n@Override\npublic InputStream getResourceAsStream(String name) {\nif (name.endsWith(CLASS_EXTENSION)) {\nString qualifiedClassName = name.substring(0, name.length() - CLASS_EXTENSION.length()).replace(‘/’, ‘.’);\nCharSequenceJavaFileObject javaFileObject = (CharSequenceJavaFileObject) javaFileObjectMap.get(qualifiedClassName);\nif (null != javaFileObject &amp;&amp; null != javaFileObject.getByteCode()) {\nreturn new ByteArrayInputStream(javaFileObject.getByteCode());\n}\n}\nreturn super.getResourceAsStream(name);\n}\n/**\n* 暂时存放编译的源文件对象,key为全类名的别名（非URI模式）,如club.throwable.compile.HelloService\n*/\nvoid addJavaFileObject(String qualifiedClassName, JavaFileObject javaFileObject) {\njavaFileObjectMap.put(qualifiedClassName, javaFileObject);\n}\nCollection listJavaFileObject() {\nreturn Collections.unmodifiableCollection(javaFileObjectMap.values());\n}\n}\nJdkDynamicCompileJavaFileManager.java\npackage AOP.base.ClassMake;\nimport javax.tools.*;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.*;\npublic class JdkDynamicCompileJavaFileManager extends ForwardingJavaFileManager {\nprivate final JdkDynamicCompileClassLoader classLoader;\nprivate final Map&lt;URI, JavaFileObject&gt; javaFileObjectMap =new HashMap&lt;&gt;();\npublic JdkDynamicCompileJavaFileManager(JavaFileManager fileManager, JdkDynamicCompileClassLoader classLoader) {\nsuper(fileManager);\nthis.classLoader = classLoader;\n}\nprivate static URI fromLocation(Location location, String packageName, String relativeName) {\ntry {\nreturn new URI(location.getName() + ‘/’ + packageName + ‘/’ + relativeName);\n} catch (URISyntaxException e) {\nthrow new IllegalArgumentException(e);\n}\n}\n@Override\npublic FileObject getFileForInput(Location location, String packageName, String relativeName) throws IOException {\nJavaFileObject javaFileObject = javaFileObjectMap.get(fromLocation(location, packageName, relativeName));\nif (null != javaFileObject) {\nreturn javaFileObject;\n}\nreturn super.getFileForInput(location, packageName, relativeName);\n}\n/**\n* 这里是编译器返回的同(源)Java文件对象,替换为CharSequenceJavaFileObject实现\n*/\n@Override\npublic JavaFileObject getJavaFileForOutput(Location location, String className, JavaFileObject.Kind kind, FileObject sibling) throws IOException {\nJavaFileObject javaFileObject = new CharSequenceJavaFileObject(className, kind);\nclassLoader.addJavaFileObject(className, javaFileObject);\nreturn javaFileObject;\n}\n/**\n* 这里覆盖原来的类加载器\n*/\n@Override\npublic ClassLoader getClassLoader(Location location) {\nreturn classLoader;\n}\n@Override\npublic String inferBinaryName(Location location, JavaFileObject file) {\nif (file instanceof CharSequenceJavaFileObject) {\nreturn file.getName();\n}\nreturn super.inferBinaryName(location, file);\n}\n@Override\npublic Iterable list(Location location, String packageName, Set&lt;JavaFileObject.Kind&gt; kinds, boolean recurse) throws IOException {\nIterable superResult = super.list(location, packageName, kinds, recurse);\nList result = new ArrayList&lt;&gt;();\n// 这里要区分编译的Location以及编译的Kind\nif (location == StandardLocation.CLASS_PATH &amp;&amp; kinds.contains(JavaFileObject.Kind.CLASS)) {\n// .class文件以及classPath下\nfor (JavaFileObject file : javaFileObjectMap.values()) {\nif (file.getKind() == JavaFileObject.Kind.CLASS &amp;&amp; file.getName().startsWith(packageName)) {\nresult.add(file);\n}\n}\n// 这里需要额外添加类加载器加载的所有Java文件对象\nresult.addAll(classLoader.listJavaFileObject());\n} else if (location == StandardLocation.SOURCE_PATH &amp;&amp; kinds.contains(JavaFileObject.Kind.SOURCE)) {\n// .java文件以及编译路径下\nfor (JavaFileObject file : javaFileObjectMap.values()) {\nif (file.getKind() == JavaFileObject.Kind.SOURCE &amp;&amp; file.getName().startsWith(packageName)) {\nresult.add(file);\n}\n}\n}\nfor (JavaFileObject javaFileObject : superResult) {\nresult.add(javaFileObject);\n}\nreturn result;\n}\n/**\n* 自定义方法,用于添加和缓存待编译的源文件对象\n*/\npublic void addJavaFileObject(Location location, String packageName, String relativeName, JavaFileObject javaFileObject) {\njavaFileObjectMap.put(fromLocation(location, packageName, relativeName), javaFileObject);\n}\n}\nProxySourceMaker.java\npackage AOP.base.SelfProxy;\nimport AOP.base.ClassMake.CharSequenceJavaFileObject;\nimport AOP.base.ClassMake.JdkDynamicCompileClassLoader;\nimport AOP.base.ClassMake.JdkDynamicCompileJavaFileManager;\nimport javax.tools.*;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.List;\n/**\n*自定义代理类生成器，实现切面AOP技术支持\n*/\npublic class ProxySourceMaker {\nprivate Object proxy;\nstatic String SOURCE_CODE = “”;\nprivate String packageName;\nprivate String className;\n/**\n* 编译诊断收集器\n*/\nstatic DiagnosticCollector DIAGNOSTIC_COLLECTOR = new DiagnosticCollector&lt;&gt;();\nProxySourceMaker(Class handlerClass,Class targetClass){\nString packageName = targetClass.getPackage().getName();\nthis.packageName = packageName;\nString className = handlerClass.getSimpleName()+targetClass.getSimpleName();\nthis.className = className;\nStringBuilder stringBuilder = new StringBuilder();\nstringBuilder.append(“package”).append(&quot; “).append(packageName).append(”;“).append(”\\n&quot;);\nstringBuilder.append(“import “).append(targetClass.getName()).append(”;”).append(“\\n”);\nstringBuilder.append(“import “).append(handlerClass.getName()).append(”;”).append(“\\n”);\nstringBuilder.append(“public class “).append(className).append(” extends “).append(targetClass.getName()).append(”{\\n”);\n//组合处理器对象\nstringBuilder.append(handlerClass.getSimpleName()).append(&quot; &quot;).append(handlerClass.getSimpleName()).\nappend(&quot; = &quot;).append(“new “).append(handlerClass.getSimpleName()).append(”();\\n”);\nMethod[] methods = targetClass.getDeclaredMethods();\nfor(Method method:methods){\nstringBuilder.append(“@Override”).append(“\\n”);\nint m = method.getModifiers();\n//方法修饰符\nstringBuilder.append(Modifier.toString(m)).append(&quot; &quot;);\n//方法返回类型\nstringBuilder.append(method.getReturnType().getName()).append(&quot; &quot;);\n//方法名称\nstringBuilder.append(method.getName()).append(&quot;( &quot;);\n//方法参数\nClass&lt;?&gt;[] params = method.getParameterTypes();\nint i=0;\nif(params.length&gt;0){\nfor(Class&lt;?&gt; cl:params){\nstringBuilder.append(cl.getName()).append(&quot; param&quot;).append(i++).append(&quot; &quot;);\n}\n}\nstringBuilder.append(“)”).append(“{”).append(“\\n”);\n//调用前置处理\nstringBuilder.append(handlerClass.getSimpleName()).append(“.before();\\n”);\nString result = “”;\nif(!method.getReturnType().getName().equals(“void”)){\nstringBuilder.append(method.getReturnType().getName()).append(&quot; “).append(“result;”).append(”\\n&quot;);\nstringBuilder.append(&quot;result = &quot;);\nresult = “result”;\n}\n//调用目标方法\nstringBuilder.append(“super.”).append(method.getName()).append(&quot;( &quot;);\nfor(int j=0;j&lt;i;j++){\nstringBuilder.append(“param”).append(j).append(&quot; &quot;);\n}\nstringBuilder.append(“);”).append(“\\n”);\n//调用后置处理\nstringBuilder.append(handlerClass.getSimpleName()).append(“.after();\\n”);\nstringBuilder.append(“return “).append(result).append(”;”).append(“\\n”);\nstringBuilder.append(“}”).append(“\\n”);\n}\nstringBuilder.append(“}\\n”);\nSOURCE_CODE = stringBuilder.toString();\n}\npublic Object getProxy() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {\n// 获取编译器实例\nJavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n// 设置编译参数 - 指定编译版本为JDK1.6以提高兼容性\nList options = new ArrayList&lt;&gt;();\noptions.add(“-source”);\noptions.add(“1.6”);\noptions.add(“-target”);\noptions.add(“1.6”);\n// 获取标准的Java文件管理器实例\nStandardJavaFileManager manager = compiler.getStandardFileManager(DIAGNOSTIC_COLLECTOR, null, null);\n// 初始化自定义类加载器\nJdkDynamicCompileClassLoader classLoader = new JdkDynamicCompileClassLoader(Thread.currentThread().getContextClassLoader());\n// 初始化自定义Java文件管理器实例\nJdkDynamicCompileJavaFileManager fileManager = new JdkDynamicCompileJavaFileManager(manager, classLoader);\nString packageName = this.packageName;\nString className = this.className;\nString qualifiedName = packageName + “.” + className;\n// 构建java文件对象字符序列\nCharSequenceJavaFileObject javaFileObject = new CharSequenceJavaFileObject(className, SOURCE_CODE);\n// 添加Java源文件实例到自定义Java文件管理器实例中\nfileManager.addJavaFileObject(\nStandardLocation.SOURCE_PATH,\npackageName,\nclassName + CharSequenceJavaFileObject.JAVA_EXTENSION,\njavaFileObject\n);\n// 初始化一个编译任务实例并执行编译任务\nList list = new ArrayList&lt;&gt;();\nlist.add(javaFileObject);\nJavaCompiler.CompilationTask compilationTask = compiler.getTask(\nnull,\nfileManager,\nDIAGNOSTIC_COLLECTOR,\noptions,\nnull,\nlist\n);\nBoolean result = compilationTask.call();\n//打印编译结果\nSystem.out.println(String.format(“编译 [%s ]结果:%s”, qualifiedName, result));\n//加载类获得Class实例\nClass&lt;?&gt; klass = classLoader.loadClass(qualifiedName);\n//根据class实例实例化对象\nproxy = klass.getDeclaredConstructor().newInstance();\nreturn proxy;\n}\n}\nok，到此，已经实现了动态代理支持，下面进行使用。我们开始建立一个目标类：\npublic class Hello implements HelloInterface{\n@Override\npublic Integer sayHello() {\nSystem.out.println(“hello world!!”);\nreturn 8;\n}\n@Override\npublic void sayBye() {\nSystem.out.println(“BBye”);\n}\n@Override\npublic void sayHei() {\n}\n@Override\npublic void jojo() {\n}\n}\n然后建立一个处理器类(前置，后置处理)：\npublic class SelfHandler {\npublic void before(){\nSystem.out.println(“前置处理”);\n}\npublic void after(){\nSystem.out.println(“后置处理”);\n}\npublic void around(){\nSystem.out.println(“环绕处理”);\n}\n}\n最后，进行测试，看通过上面两个类能不能生成一个代理类：\nimport AOP.base.Hello;\nimport java.lang.reflect.InvocationTargetException;\npublic class SelfTest {\npublic static void main(String[] args) throws ClassNotFoundException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {\nHello hello = (Hello)new ProxySourceMaker(SelfHandler.class,Hello.class).getProxy();\nhello.sayHello();\n}\n}\n\n成功！！！！\n好了，如果你成功复现出来了，那么恭喜，你即将触及动态代理的精髓，下面就仔细去研读代码吧，如果有想法，就去优化，争取做一个更好的AOP框架出来。\n","tags":["Spring"]},{"title":"1.算法设计的基石","url":"/article/Algorithm-Base-1-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E7%9F%B3/","content":"1.几种基本的算法思想\n首先，我们先认识几个词：分治法，动态规划法，回溯法，分支限界法，贪心法。\n我们必须知道，上面五种思想将贯穿我们的算法学习的全过程，这五种思想并没有啥深度和技术含量，他们更像是一种基石。\n在我们以后写任何算法的时候，我们都要思考，我们写的这个算法是用的那种思想实现的。\n1.1 分治法\n1.1.1 分治法描述\n分治法是计算机领域中最为常用的算法类型，其核心思想是 “分而治之”，其原理是：\n将一个复杂混合的问题拆解为两个或两个以上类型相同的子问题，然后将子问题依然进行分治法处理，直到子问题本身简单到可以求解，\n最终按照问题的拆解顺序，从子问题逐步向大问题结果汇总，层层向上，最终得到原问题的解。\n它的典型的应用就是递归。\n1.1.2 分治法问题实例学习\n分治法解决的最简单的问题是：阶乘问题 ，求解N的阶乘（1234…*n）\n这个问题看起来很简单，但是当N特别大时，是不是就会感到很无助？\n下面我们应用分治法来解决这个问题：\n\n\n第一步：首先我们尝试将这个问题拆分，开始我们可以想到，我们可以将其拆为两个公式的乘积，例如：（123*…(n/2)）和((n/2+1)(n/2+2)*…*n)的乘积。\n拆到最后其实就是两个数相乘的结果。 所以子问题就是：两个数相乘。\n好了，现在子问题找到了，下面我们要思考如何将子问题的结果汇总成大问题的结果？\n\n\n第二步：我们可以保留每个子问题的结果，然后将这个结果以下个子问题的入参进行求解，以此类推，可以得到最后的结果；\n简单来说就是，先算出n*(n-1)的结果，然后将这个结果*(n-2),然后将这个结果*（n-3）依此类推。\n\n\n写成代码就是：\nint jiecheng(int n) &#123;    if (n == 0) return 1;    return jiecheng(n - 1)*n;&#125;\n1.2 动态规划法\n1.2.1 动态规划法概述\n动态规划法又叫中间结果记录法，它的原理是：\n将问题拆分为多个简单的子问题，对于相对重叠的子问题的结果记录在中间结果表中，当遇到相同的问题时直接查询中间结果表的结果即可。\n它有效的避免了重复计算所带来的性能缺陷。\n1.2.2 动态规划问题实例学习\n动态规划法解决的典型的问题有：求斐波那契数\n问题描述：给出一个数，求出它的斐波那契数\n斐波那契数的定义如下：\n1，1，2，3，5，8，13是一个斐波那契数列，当n=5时，它的斐波那契数为8，依次类推。\n很明显我们可以用递归的方式进行问题解决：\npublic int Fib(int n) &#123;    if (n &lt;= 1)&#123;        return 1;    &#125; else&#123;        return Fib(n - 1) + Fib(n - 2);    &#125;&#125;\n但是递归存在重复计算的缺陷，我们先分析下用递归进行计算n=6时的计算过程：\n\n我们可以看到，为了算F6,递归法重复算了F1或F0 最小子问题13次。\n造成这个问题的很明显的原因是大问题之间的重复计算。\n如果我们新建一个中间结果表，在计算的过程中将为计算的大问题结果存入，并在求解新大问题之前先查询这个结果集，看有没有能匹配上的，如果有直接返回，\n这样我们可以节省大量时间！这就是动态规划的精髓所在！！\n代码表示如下：\npublic int FibonacciBetter(int n) &#123;    //存储前一个数    int last = 1;    //存储后一个数    int nextToLast = 1;    //存储结果    int answer;    for (int i = 1; i&lt;n ;i++) &#123;        answer = last + nextToLast;        nextToLast = last;        last = answer;    &#125;    return answer;&#125;\n上面的算法，在计算过程中存储需要用到的中间结果，然后使用，是动态规划的典型应用，在这个问题的解法中，中间结果表是：last,nextToLast,answer组成的集合。（请细细体会）\n1.3 回溯法\n1.3.1 回溯法概述\n回溯法是一种通过不断尝试来获得最终解的方法，但并不是一个漫无目的的过程，它在选择求解目标的过程中会利用当前条件与目标的最优匹配选择进行尝试，\n即使当前失败，也能回溯到上一步继续进行最优匹配。（深度优先） 换句话说，回溯法相当于穷举搜索的巧妙实现。\n1.3.2 回溯法问题实例学习\n用回溯法解决的一个典型的问题就是：背包问题\n问题描述：背包问题简单来说就是给定背包最大承重量，在一堆物品中怎样拿才能尽可能使得拿的物品总价值最大。\n例如，有一个背包承重量15kg\n有如下物品\n物品名称物品质量物品价值A450B660C7100D870\n目标：在不超过背包称重量的情况下拿到最大价值物品集。\n回溯法相当于穷举的巧妙实现, 所以先用普通的穷举方法穷举一下可能的结果:\n1) A+B 110\n2) A+C 150\n3) A+D 120\n4) B+C 160\n5) B+D 130\n6) C+D 170\n注意：这里的穷举法省略了不符合要求的组合，在实际的算法中，其实它也是会算出来的，然后再筛掉。\n最后我们可以得到，拿物品C ,D是最佳的选择。 但是如果我们按照穷举的方法，计算量为6，直到最后一次我们才能得到正确的结果。\n下面我们用回溯法来进行：\n使用回溯法的第一步就是选择起点，通过上面的穷举我们可以知道，一个好的起点可以帮我们节省大量时间(假如开始就选择了C作为起点或D作为起点)\n如何选择起点我个人认为这要根据具体问题进行选择，例如这个问题我们可以选择单位价值最大的物品作为起点：\n物品名称物品质量物品价值单位价值A45012.5B66010C710014.28D8708.75\n现在我们以C作为起点，使用回溯法的过程为：\n1）C+A 150\n2) C+B 160\n3) C+D 170\n注意：这里的穷举法省略了不符合要求的组合，在实际的算法中，其实它也是会算出来的，然后再筛掉。\n得到结果！！！ 只需三次！！\n1.4.分支限界法\n1.4.1 分支界限法概述\n分支界限法，是以最小代价进行尝试（广度优先），它与回溯法稍有不同。\n1.4.2分支界限法解决问题\n用分支界限法法解决的一个典型的问题就是：背包问题\n问题描述：背包问题简单来说就是给定总价值量，在一堆物品中怎样拿才能尽可能使得拿的物品单位价值最大。\n例如，有一个背包承重量15kg\n物品名称物品质量物品价值A450B660C740D820\n这里的标准不再是最大单位价值，而是以质量为维度来进行选择。以最小的代价获取，也就是 100/总质量最大 的组合。\n他其实和回溯法的思想类似，就是维度变了，这里直接给出结果： A+C是最佳选择。\n1.5.贪心法\n1.5.1 贪心法概述\n顾名思义，贪心法是指当前的条件下的最好选择，贪心法没有一个全局对比，也就是说走一步算一步，每步只选择当前最好的一步。\n每一步为局部最优解，所以它只适用于保证每一步选择的最优解能通向下一步最优解的问题，否则，这个方法会出现时灵，时不灵的效果。\n2）贪心法解决问题实例\n贪心法的精髓是每次都要最好的。\n典型的应用场景是，玩扑克时，我们抓牌，连续抓五张，只要保证每次抓的点数是最大的，就能保证最后的五张牌的点数最大。\nOK，下面就是具体的算法基础学习阶段了，我们将学习从简单的递归到各种排序到各种数据结构的使用基础，在学习的过程我们在练习任何一道题时，我希望我们能想到这些算法思想，将其一一对应。\n","tags":["算法基础"]},{"title":"2.分支策略递归学习","url":"/article/Algorithm-Base-2-%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5%E9%80%92%E5%BD%92%E5%AD%A6%E4%B9%A0/","content":"1.什么是分治策略？\n我的总结是：大分小，小合大。\n这句话将贯穿下面所有递归算法。\n首先简单了解下递归：\n1.1.用例子学习递归\n1.1.1 阶乘函数\n阶乘函数的定义：\n当n=0时，n! = 1\n当n&gt;0时，n! = n(n-1)!\n从上面我们可以知道递归的边界条件为n=0,递归方程也就是n(n-1)，由此，我们可以写出下面代码：\nint jieCheng(int n) &#123;    if (n == 0) return 1;    return jieCheng(n - 1) * n;&#125;\n实例展示\npublic class RecursionStudy &#123;    /**     * 阶乘算法的递归实现     * @param n     * @return     */    static int jieCheng(int n) &#123;        if (n == 0) return 1;        return jieCheng(n - 1) * n;    &#125;    public static void main(String[] args) &#123;        System.out.println(jieCheng(4));    &#125;&#125;\n\n1.1.2 斐波那契数\n问题描述：给出一个数，求出它的斐波那契数\n1，1，2，3，5，8，13是一个斐波那契数列，当n=5时，它的斐波那契数为8，依次类推。\n其公式定义为：\nn&lt;=1时, F(n)=1\nn&gt;1时, F(n)=F(n-1)+F(n-2)\n很明显我们可以用递归的方式进行问题解决：\npublic int Fib(int n) &#123;    if (n &lt;= 1)        return 1;    else        return Fib(n - 1) + Fib(n - 2);&#125;\n实例展示\npublic class RecursionStudy &#123;    /**     * 斐波那契数     * @param n     * @return     */    public static int Fib(int n) &#123;        if (n &lt;= 1)            return 1;        else            return Fib(n - 1) + Fib(n - 2);    &#125;    public static void main(String[] args) &#123;        for (int i = 0; i &lt; 10; i++) &#123;            System.out.print(Fib(i) + &quot; &quot;);        &#125;    &#125;&#125;\n\n1.2.解决全排列问题\n1.2.1 问题描述\n设计一个递归算法，生成n个元素{r1,r2,r3,r4,…,rn}的全排列。\n在思考这个问题之前，我们知道了递归是在一个函数中调用自身有限嵌套来实现了。\n所以我们首先可以尝试一层一层地来实现，这种方式当嵌套数很少的时候还好，但是，数量多了，这样根本行不通！\n所以我们要真正理解递归，必须理解这句话**\n：递归的关键是将其抽象成一个递推公式，不要去想一层层的调用关系，不要试图用人脑取分解递归的每个步骤，它是一种思想。**\n解决思路：由此，我们开始重新思考学习如何使用递归来解决这个问题\n首先，我们需要得出递推公式：\nR={r1,r2,r3,r4,r5,…rn}\n我们需要先找出这个问题的最小子问题，其实我们可以发现，这个最小子问题其实就是两个元素的排列。,*\nRmin={r1,r2}的全排列为{r1,r2},{r2,r1} | Rmin={r1} 的全排列为{r1}*\n有了这个基础我们可以得到问题的解的递推公式：\nPerm(R）为R的全排列结果集\nRi=R-{ri}\n当n&gt;1时，有：\nPerm®=(r1)Perm(R1)+(r2)Perm(R2)+…+(rn)Perm(Rn);然后以此类推\n现在我们可以用一个例子来分析验证：R={1，2，3}\nPerm®=(1)Perm({2,3})+(2)Perm({1,3})+(3)Perm({1,2})\n={1,2,3}+{1,3,2}+{2,1,3}+{2,3,1}+{3,1,2}+{3,2,1}\n可以知道有六种情况。发现可行，下面我们用代码实现：\n/** * 全排列问题 * @param a * @param cursor * @param k */public static void allPermutation(int[] a, int cursor, int k) &#123;//递归终止条件    if (cursor == k) &#123;        System.out.println(Arrays.toString(a));    &#125;    for (int i = cursor; i &lt;= k; i++) &#123;        if (!equal(a, cursor, i)) continue;        swap(a, cursor, i);        allPermutation(a, cursor + 1, k);        swap(a, cursor, i);    &#125;&#125;public static void swap(int[] a, int cursor, int i) &#123;    int temp = a[cursor];    a[cursor] = a[i];    a[i] = temp;&#125;public static boolean equal(int[] a, int cursor, int i) &#123;    for (int j = cursor; j &lt; i; j++) &#123;        if (a[j] == a[i]) return false;    &#125;    return true;&#125;@Testpublic void allPermutationTest() &#123;    int[] a = &#123;1, 2, 3&#125;;    allPermutation(a, 0, a.length - 1);&#125;\n\n1.3.解决整数划分问题\n1.3.1 问题描述\n将正整数n表示成一系列正整数之和：n=n1+n2+n3+…+nk;\n其中n1&gt;=n2&gt;=n3&gt;=n4…&gt;=nk&gt;=1 k&gt;=1，正整数n的这种表示称为正整数n的划分。\n求正整数n的不同划分个数\n例如：正整数6有如下划分个数\n6;\n5+1;\n4+2 , 4+1+1;\n3+3 , 3+2+1 , 3+1+1+1\n2+2+2 , 2+2+1+1 , 2+1+1+1+1\n1+1+1+1+1+1+1\n从这个问题我们也能很快找到最小子问题 就是整数n=1时，它的划分为 1 ，n=2时，它的划分为 1+1\nq(6)=0+q(6) + 1+q(5) + 2+q(4） + 3+q(3) 以此类推\n代码如下：\npublic static int intDivision(int n, int m) &#123;    if (n &lt; 1 || m &lt; 1) return 0;    if (n == 1 || m == 1) return 1;    if (n &lt; m) return intDivision(n, n);    if (n == m) return intDivision(n, m - 1) + 1;    return intDivision(n, m - 1) + intDivision(n - m, m);&#125;@Testpublic void intDivisionTest() &#123;    System.out.println(intDivision(6, 6));&#125;\n\n注意：我们不建议使用递归，在算法中，使用递归的缺点大于它的优点，这一节只是对算法有一些基本的了解，了解即可。\n","tags":["算法基础"]},{"title":"3.1 冒泡排序算法","url":"/article/Algorithm-Base-3-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95java%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/","content":"一.冒泡排序理论学习\n冒泡排序就是从第一个数开始，每个数都与其后面的数进行比较，根据比较结果进行位置交换，最后得到一个有序的数列。\n\n二.代码实现及算法分析\n1.Java代码实现\npublic static void maoPaoSort(int a[]) &#123;    int length = a.length;    for (int i = 0; i &lt; length; i++) &#123;        for (int j = 0; j &lt; length; j++) &#123;            if (a[i] &gt; a[j]) &#123;                int temp = a[i];                a[i] = a[j];                a[j] = temp;            &#125;        &#125;    &#125;    for(int i=0;i&lt;length;i++)&#123;        System.out.println(a [i ]);    &#125;&#125;\n2.复杂度分析\n2.1 时间复杂度分析\n我们假设数组的大小为n, 进行一次比较的时间复杂度为1。\n当n=5,且数组是逆序的情况下，其时间消费可以进行如下计算：\nO(n) = 4+3+2+1=10\n我们也很容易可以推算出其计算公式：\nO(n)=1+2+3+4+…+(n-1)\n=1/2n(n-1)\n所以当n无穷大时，O(n)=n^2\n所以其时间负责度为O(n^2);\n2.2空间复杂度\n很容易可以看出其空间复杂度为O(1)\n这种排序方法了解即可！！！\n","tags":["算法基础"]},{"title":"3.2 插入排序算法","url":"/article/Algorithm-Base-3-2-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%80%9D%E8%B7%AF%E5%92%8Cjava%E5%AE%9E%E7%8E%B0/","content":"一.插入排序\n1.理论基础\n插入排序的一个特点是：回溯到前面进行比较，之后再往后进行比较。\n\n2.代码实现\n注意：插入排序只适合少量元素的排序，其时间复杂度为O(n^2)\n/**     * 插入排序方法实现,动态规划实现     * @param array     */    public static void insertSort(int[] array) &#123;        int temp;        int j;        for (int i = 1; i &lt; array.length; i++) &#123;            temp = array[i];            // 如果第i位置的元素小于前一位的元素，则将前一位元素后移            for (j = i; j &gt; 0 &amp;&amp; array[j - 1] &gt; temp; j--) &#123;                array[j] = array[j - 1];            &#125;            // 插入            array[j] = temp;        &#125;    &#125;\n空间复杂度为O(1)，时间复杂度为O(n^2)\n这个排序方法了解即可，因为其时间复杂度非常高。\n","tags":["算法基础"]},{"title":"3.3 希尔排序算法","url":"/article/Algorithm-Base-3-3-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E6%80%9D%E8%B7%AF%E5%92%8Cjava%E5%AE%9E%E7%8E%B0/","content":"希尔排序\n1.希尔排序理论基础\n通过比较相距一定间隔的元素进行插入排序算法，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻的元素的最后一趟位置。\n初始间隔一般为 n/2 (n为元素个数)  \n如图所示：\n\n2.希尔排序代码实现\nclass Test &#123;    /**     * 希尔排序基础实现     * @param array 目标数组     * @param n 初始间距     * @return     */    public static int[] shellSort(int[] array, int n) &#123;        //sub为间距        for (int sub = n; sub &gt; 0; sub /= 2) &#123;            for (int i = sub; i &lt; array.length; i++) &#123;                int tem = array[i];                int j;                // 这里加入了插入排序的思想                for (j = i; j &gt;= sub &amp;&amp; tem &lt; array[j - sub]; j -= sub) &#123;                    array[j] = array[j - sub];                &#125;                array[j] = tem;            &#125;        &#125;        return array;    &#125;    public static void shellSortTest() &#123;        int[] numbs = &#123;3, 9, 2, 5, 7, 1&#125;;        shellSort(numbs, numbs.length / 2);        System.out.println(Arrays.toString(numbs));    &#125;    public static void main(String[] args) &#123;        shellSortTest();    &#125;&#125;\n执行结果：[1, 2, 3, 5, 7, 9]\n其时间复杂度比较优秀：最好为O(n), 最坏时取决于间隔序列 \n空间复杂度：最坏O(n) \n相比与冒泡排序和插入排序，这个排序还是比较优秀的！！\n","tags":["算法基础"]},{"title":"3.4 快速排序算法","url":"/article/Algorithm-Base-3-4-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84java%E5%AE%9E%E7%8E%B0/","content":"快速排序\n1.理论基础\n1.1 什么是快速排序\n快速排序简称快排，它是在实践中最快的已知排序算法，根据相关测试，其平均运行时间为O(N logN) \n它的基本思想是：\n如果我们需要对数组S进行排序\n\n如果S中的元素个数为0或1，直接返回\n取S中任意一个元素v,并称其为key\n以v大小为界限将S-v部分分为S1(小于v的集合),S2(大于v的集合)\n递归的对S1,S2做上面同样的快排操作,最终得到一个有序的数组\n\n如下图所示：\n\n其中关键的一部就是： \n如何通过key对集合S进行划分,划分的过程就是快排的关键。\n并且如何取得这个key也是算法的关键\n1.2 如何得到key\n虽然从算法上看，无论选择那个元素作为key，最后快速排序都能正确的完成工作，但是有些选择明显能让快速排序更快的完成工作。\n(一般没有经过考虑的做法是将第一个元素作为key,如果排序的数组是随机的，这个做法是可以接受的，但是，\n如果数组是预排序或反序的，这样的做法绝对是很糟糕的，还有的做法是选择前两个互异元素的大者，当然这样也是不好的) \n目前已知的较好的做法是： 三数中值法\n选择数组左端，右端，中心位置的三个元素中的中值作为key,这种取值的做法能在一定程度上消除数组特性带来的坏影响。\n1.3 快速排序是如何通过key进行划分的\n我们先看一个数组 , array = {8,4,3,9,0,1},以这个数组为例\n做法如下： \n\n首先使用三数中值法得到array的key = 3\n然后将key元素和最后一个位置的元素交换得到array = {8,4,1,9,0,3}\n定义i=0,j = array.length-2\n使用如何规则对array进行处理：\n\n判断array[i]是否大于key,如果大于则i的值不变,否则i自增向后移动直到array[i]大于key\n判断array[j]是否小于key,如果小于则j的值不变，否则j自减向前移动直到array[j]小于key\n交换i,j位置上的值,并保持i,j不变\n重复前面三步的操作直到i&gt;=j\n将i位置上的元素和key进行交换,划分完毕\n\n\n\n具体图示如下： \n\n2.java代码实现如下\npublic class intQuickSort &#123;  public static void main(String[] args) &#123;    int[] numbs = &#123;5,1,1,2,0,0&#125;;    quickSort(numbs);    System.out.println(Arrays.toString(numbs));  &#125;  /**   * 三数中值找到key并和right位置交换   * @param a 目标数组   * @param left 左位置   * @param right 右位置   * @return   */  public static int median3(int[] a, int left,int right) &#123;    int center = (left+right)/2;    // left为中值    if(a[left]&gt;=a[center]&amp;&amp;a[left]&lt;=a[right]||a[left]&gt;=a[right]&amp;&amp;a[left]&lt;=a[center])&#123;      swap(a,left,right);    &#125;    // center为中值    else if(a[center]&gt;=a[left]&amp;&amp;a[center]&lt;=a[right]||a[center]&gt;=a[right]&amp;&amp;a[center]&lt;=a[left]) &#123;      swap(a,center,right);    &#125;    return a[right];  &#125;  /**   * 随机选取key   * @param a   * @param left   * @param right   * @return   */  public static int randomKey(int[] a,int left,int right) &#123;    Random random = new Random();    int index = random.nextInt(right-left+1)+left;    swap(a,index,right);    return a[right];  &#125;  /**   * 交换left和right位置的元素   * @param a   * @param left   * @param right   */  public static void swap(int[]a ,int left,int right) &#123;    if(left&lt;0||right&lt;0||left&gt;=a.length||right&gt;=a.length)&#123;      System.out.println(&quot;left或right位置错误！！&quot;);    &#125;    int tem = a[left];    a[left] = a[right];    a[right] = tem;  &#125;  /**   * 2个或三个的元素就不用执行主流程了，直接进行普通的排序   * @param a   * @param left   * @param right   */  public static void easySort(int[] a, int left, int right) &#123;    int center = left+1;    if(a[left]&gt;a[center])&#123;      swap(a,left,center);    &#125;    if(a[left]&gt;a[right])&#123;      swap(a,left,right);    &#125;    if(a[center]&gt;a[right])&#123;      swap(a,center,right);    &#125;  &#125;  public static void quickSort(int[] a)&#123;    quickMain(a,0,a.length-1);  &#125;  public static void quickMain(int[] a, int left, int right) &#123;    if(left&gt;=right||right&lt;0||left&gt;=a.length||left&lt;0||right&gt;=a.length) &#123;      return;    &#125;    //如果元素超过3个，执行快排流程    if(left+3 &lt;= right) &#123;      int i ,j = right-1 ,key;      //key = median3(a,left,right);      key = randomKey(a,left,right);      for(i = left;i &lt;= j;) &#123;        if(a[i] &lt;= key) &#123;          i++;        &#125;        if(a[j] &gt;= key)&#123;          j--;        &#125;        if(i&lt;j&amp;&amp;a[i]&gt;key&amp;&amp;a[j]&lt;key)&#123;          swap(a,i,j);        &#125;      &#125;      swap(a,i,right);      // 此时i位置就是中间位置      // 需要对剩下的元素进行快排操作      quickMain(a,left,i-1);      quickMain(a,i+1,right);    &#125;    // 简单排序    else&#123;      easySort(a,left,right);    &#125;  &#125;&#125;\n时间复杂度最坏为：O(n^2)  最好为O(nlogn)  平均为:O(n log(n)) \n空间复杂度：O(1)\n相比于前者，快速排序又优秀了许多！！ 快速排序是必须要掌握的一种排序方法。\n","tags":["算法基础"]},{"title":"3.5 归并排序","url":"/article/Algorithm-Base-3-5-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84java%E5%AE%9E%E7%8E%B0/","content":"归并排序\n1.基础理论\n1.1 基本描述\n归并排序以最坏时间复杂度O(N log N)运行，它所使用到的比较次数几乎是最优的，它是递归算法的一个很好的实例。\n这个排序算法中基本的操作就是合并两个已经排序的表。 \n因为输入的两个表是已排序的，所以若将输出放到第三个表中， 则该算法可以通过对输入数据一趟排序来完成。\n合并算法图示如下：\n\n\n所以归并排序算法的步骤描述为：\n如果N=1,那么只有一个元素直接返回结果，否则递归的将前本部分数据和后半部分数据各自归并排序，\n得到排序后的两部分数据，然后使用上面描述的合并算法再将这两部分合并到一起。\n也就是说最小子问题就是N=2\n例如: \n我们想将这个数组{24,13,26,1,2,27,38,15}排序，\n我们递归的将前四个数据和后四个数据分别排序，得到\n{24},{13},{26},{1},{2},{27},{38},{15}, \n然后使用归并方法对{24} {13} 进行归并得到{13,24}\n对{26} {1} 进行归并得到{1,26}\n对{2},{27} 进行归并得到{2,27}\n对{38},{15} 进行归并得到{15,38}\n接着对 {13,24} ,{1,26}进行归并得到{1,13,24,26}\n对{2,27},{15,38}进行归并得到{2,15,27,38}\n最后 我们将{1,13,24,26},{2,15,27,38}这两部分进行合并，最后得到{1,2,13,15,24,26,27,38} \n该算法使用了经典的分治策略, 它将问题分成一些小的问题然后递归求解。\n2.代码实现\nclass Test&#123;        /**     * 合并两个已经排好序的数组     * @param a 数组     * @param left 左位置     * @param mid 中心位置     * @param right 结尾位置     */    public static void merge(int[] a, int left,int mid,int right) &#123;        int[] result = new int[right-left+1];        // p1,p2是检测指针， index是存放指针        int p1 = left, p2 = mid+1, index = 0;                // 执行双数组元素比较        while (p1&lt;=mid&amp;&amp;p2&lt;=right) &#123;            if(a[p1]&lt;=a[p2])&#123;                result[index++] = a[p1++];            &#125;            else&#123;                result[index++] = a[p2++];            &#125;        &#125;        while (p1&lt;=mid) result[index++] = a[p1++];        while (p2&lt;=right) result[index++] = a[p2++];        System.arraycopy(result, 0, a, left, result.length);    &#125;    /**     * 归并排序，采用分治，递归思想     * @param a     * @param start     * @param end     */    public static void mergeSort(int[] a,int start,int end) &#123;        if(start &lt; end)&#123;            int mid = (start+end)/2;            mergeSort(a,start,mid);            mergeSort(a,mid+1,end);            merge(a,start,mid,end);        &#125;    &#125;    public static void mergeSortTest() &#123;        int[] numbs = &#123;24,13,26,1,2,27,38,15&#125;;        mergeSort(numbs,0,numbs.length-1);        System.out.println(Arrays.toString(numbs));    &#125;    public static void main(String[] args) &#123;        mergeSortTest();    &#125;&#125;","tags":["算法基础"]},{"title":"3.6 计数排序算法","url":"/article/Algorithm-Base-3-6-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9A%84java%E5%AE%9E%E7%8E%B0/","content":"1.什么是计数排序？\n计数排序的应用场景是假设n个输入元素中的每一个都是在0到k区间内的整数。\n排序的时间复杂度为O(n),但是空间复杂度是不稳定的,为O(k),也就是说，空间复杂度取决于k \n此排序的一个重要的特性是稳定,它的时间复杂度是很稳定的。\n2.基本思想\n对每一个输入元素x，确定小于x的元素个数，直接将x放在输出数组的正确位置。\n例如，有17个元素小于等于x的话，则x应放在输出数组的第18个输出位置。\n这种排序方法的前提是，已知目标数组中的最大元素，\n例如我们现在需要对 [2,5,3,0,2,3,0,3] 进行排序且已知数组的元素的范围是0~5：\n\n3.实现\nJava实现代码如下\nclass Test&#123;    //a为输入数组，b为输出数组，k为范围最大值    void CountingSort(int a[],int b[],int k)&#123;        int c[]=new int [k];        int j,i;        // 填充c数组初始化        for(j=0;j&lt;a.length;j++)            c[a[j]] = c[a[j]] + 1;        // 计算c数组初始位置        for (i=1; i &lt; k; i++)            c[i] = c[i] + c[i-1];        //开始填充B数组        for (j = a.length - 1; j &gt;= 0; j--) &#123;            //注意这里的b数组里面一定要-1            b[c[a[j]]-1] = a[j];            c[a[j]] = c[a[j]] - 1;        &#125;    &#125;    public static void main(String[] args) &#123;        int[] numbs = &#123;2,5,3,0,2,3,0,3&#125;;        int[] result = new int[numbs.length];        CountingSort(numbs,result,5);        System.out.println(Arrays.toString(result));    &#125;&#125;\n结果：\n[0, 0, 2, 2, 3, 3, 3, 5]\n","tags":["算法基础"]},{"title":"3.7 二维数组排序","url":"/article/Algorithm-Base-3-7-%E9%92%88%E5%AF%B9%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%90%E4%B8%80%E9%A1%B9%E5%AF%B9%E4%BA%8C%E7%BB%B4%E7%9A%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/","content":"针对二维数组的某一项对二维的数组排序我的思路是：降维排序\n\n* 首先将需要排序的一维提取出来进行排序\n* 然后对其进行二维还原\nclass Test&#123;    public static void main(String[] args) &#123;        //定义一个二维数组并赋值        int[][] in = &#123;&#123;4, 50&#125;, &#123;6, 50&#125;, &#123;9, 100&#125;, &#123;8, 50&#125;&#125;;        in = sort(in,1);        for(int i=0;i&lt;in.length;i++)&#123;            for(int m=0;m&lt;in[i].length;m++)&#123;                System.out.print(in[i][m]+&quot; &quot;);            &#125;            System.out.println();        &#125;    &#125;    /**     * 针对二维数组的其中一维进行排序     * @param in 二维数组     * @param n 维度     * @return 排序后的二维数组     */    public static int[][] sort(int[][] in,int n) &#123;        //用于降维        Integer[] a = new Integer[in.length];        //还原时需要用到的中转数组        int[][] b=new int[1][1];        /*首先是降维，将要针对的那个维度降维成一维数组        这里是将数组thing中的50,60,100,70变为一维数组赋给数组a        */        for(int i=0;i&lt;in.length;i++)&#123;            a[i]=in[i][n];        &#125;        //SortUtil的排序方法        SortUtil.sort(a,SortUtil.INSERT);       /*  下面的操作是还原为二维数组的排序            其主要思想是以a为基准对thing中的元素进行排序,            例如a[0]=50,就在thing中找到thing[m][1]=50的,            将thing[m]放到第一位，以此类推        */        for (int j=0;j&lt;in.length;j++) &#123;            for (int m=0;m&lt;in.length;m++)&#123;                if(a[j]==in[m][n])&#123;                    in[m][n]=-in[m][n];//解决重复问题                    b[0]=in[j];//由于这里还原时是地址赋值                    //为了避免地址覆盖所以需要一个中间量存储被换数组的地址                    in[j]=in[m];                    in[m]=b[0];                    break;                &#125;            &#125;        &#125;        for(int j=0;j&lt;in.length;j++) &#123;            in[j][n]=-in[j][n];        &#125;        return in;    &#125;&#125;","tags":["算法基础"]},{"title":"4.1 单向链表实现","url":"/article/Algorithm-Base-4-1-Java%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/","content":"1.什么是单向链表？\n单向链表由多个节点组成，每个 节点（用于存储数据） 通过next指针相互连接，\n下一个节点的引用存放在上一个节点的next指针中， 从而构成了一个线性的链表（它与数组的区别就是它可以不具空间连续性）\n在java中一般通过定义节点Node类和API类的方式来实现链表 \nJDK中对链表LinkedList的节点的实现结构如下：\n可以看到链表节点组成分为三部分:\n存储数据的元素item ， 当前节点下一节点的引用next， 当前节点上一节点的引用prev\nprivate static class Node&lt;E&gt; {    E item;    Node&lt;E&gt; next;    Node&lt;E&gt; prev;    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {        this.item = element;        this.next = next;        this.prev = prev;    }}\n节点定义一般就放在API内部作为内部静态类使用，也就是我们使用链表数据结构都是通过API对外开放的接口进行调用的，\n我们不允许直接对链表内部属性直接访问。\n1.1 单向链表基本结构\n单向链表节点的定义中没有上一节点的引用。\n下面我们学习最基本的链表结构,我们默认链表中的元素就是int类型数字。\n如图所示：\ngraph LR\n   node1 --node1.next--&gt; node2 --node2.next--&gt; node3 --node3.next--&gt; null\n其中节点的数据结构为：\n/** * 链表节点数据结构 */static class Node {    /**     * 存储节点数据     */    private int data;    /**     * 存储下一个节点引用     */    private Node next;    /**     * 本节点名称     */    private String nodeName;    /**     * 节点构造方法，仅构造出其存储的数据，并不构造下一节点的引用     * @param data 节点数据     */    public Node(int data, String nodeName) {        this.data=data;        if(nodeName==null){            nodeName=\"\"+data;        }        this.nodeName=nodeName;    }}\n我们该如何实现操作单向链表的方法来让我们正确单向链表存储数据呢？\n1.2 实现对单向链表基本的增删改查\n1.2.1 插入方法\n给出一个节点nodeToInsert和指定位置,在链表指定位置插入该节点\n主要思路是：\n\n\n首先判断链表是否为空,如果为空则直接放入第一个节点\n\n\n再先判断链表中存不存在position位置，\n若不存在输出错误信息并返回\n若存在则进行插入操作：从第一个节点开始\n\n首先判断position是不是为0,因为这种情况不同于其他的,如果是则直接进行头节点插入\n否则，先找到第position-1个节点和position个节点。\n将前一个节点的下一节点设为nodeToInsert ,将nodeToInsert的下一个节点设置为position节点\n\n\n\n这样就完成了元素插入\n\n\n代码实现如下：\nclass Test{    /**     * 链表节点插入     * 主要思路是：先判断链表中存不存在position位置，若没有输出错误信息并返回头节点；     *      若存在则进行插入操作：首先判断position是不是为1，因为这种情况不同于其他的。     *      否则，先找到第position-1个节点和position个节点，将前一个节点的下一节点设为nodeToInsert     *      将nodeToInsert的下一个节点设置为position节点，这样完成插入操作     * @param head 链表头节点     * @param insert 要插入的节点     * @param position 指定插入的位置     * @return 插入后的链表头节点     */    static Node insertInLinkedList(Node head, Node insert, int position) {        if(head == null) {            return insert;        }        //获得输入链表的长度        int size = listLength(head);        //判断链表内是否存在此位置        if(position&gt;size||position&lt;0) {            System.out.println(\"链表不存在该位置： \"+ position +\"链表最大位置索引： \"+(size-1));            return head;        }        //在链表开头插入        if(position==0) {            insert.next = head;            return insert;        }        //在中间或末尾插入        else{            Node pre = head;            //找到那个位置的前一个节点            for(int index = 0;index &lt; position-1;index++){                //获得第position-1位置的节点                pre = pre.next;            }            //插入操作            insert.next = pre.next;            pre.next = insert;        }        return head;    }    /**     * 以输入节点为头，计算出链表长度     * @param head 头节点     * @return 链表长度     */    static int listLength(Node head) {        int length = 0;        Node current = head;        while(current!=null){            length++;            current = current.next;        }        return length;    }}\n1.2.2 如何删除链表的元素\n主要思路是找到position的前一个节点和后一个节点，然后将他们连接。\n代码实现：\nclass Test{    /**     * 方法和前面的插入方法有异曲同工之妙：     *  主要思想是找到position的前一个节点和后一个节点，然后将他们连接     * @param head 头节点     * @param position 删除的位置     * @return 删除后的链表头节点     */    static Node deleteNodeFromLinkedList(Node head, int position) {        int size = listLength(head);        if(position &gt; size||position &lt; 0) {            System.out.println(\"Position of node to delete is invalid. The valid inputs are 1 to\"+size);            return head;        }        //删除表头        if(position == 0){            return head.next;            //删除中间或结尾节点        }else{            Node pre = head;            int index = 0;            //获得目标节点的上一个节点            while(index &lt; position-1) {                pre = pre.next;                index++;            }            //要删除目标节点            Node cur = pre.next;            pre.next = cur.next;        }        return head;    }    /**     * 以输入节点为头，计算出链表长度     * @param head 头节点     * @return 链表长度     */    static int listLength(Node head) {        int length = 0;        Node current = head;        while(current!=null){            length++;            current = current.next;        }        return length;    }}\n1.2.3 如何修改指定位置节点的值\nclass Test{    /**     * 修改指定位置的值     * @param head     * @param position     * @param element     * @return     */    static Node updateNode(Node head, int position,int element) {        int size = listLength(head);        if(position &lt; 0 || position &gt;= size) {            System.out.println(\"链表不存在该位置： \"+ position +\"链表最大位置索引： \"+(size-1));        }        Node cur = head;        for(int index = 0;index &lt; position;index++){            cur = cur.next;        }        cur.data = element;        return head;    }        }\n1.2.4 如何得到指定位置的值\nclass Test{    /**     * 获取链表指定位置的元素     * @param head     * @param position     * @return     */    static Node get(Node head,int position) {        int size = listLength(head);        if(position&lt;0||position&gt;=size) {            System.out.println(\"链表不存在该位置： \"+ position +\"链表最大位置索引： \"+(size-1));        }        Node cur = head;        for (int index = 0;index &lt; position;index++){            cur = cur.next;        }        return cur;    }    }\n","tags":["算法基础"]},{"title":"4.3 循环链表实现","url":"/article/Algorithm-Base-4-3-Java%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/","content":"1.循环链表\n1.1 什么是循环链表？\n顾名思义，就是可以循环的链表哈哈哈，说白了就是收尾相连的链表，\n也就是说在这个链表里，任何节点都可能是头节点，也可以是尾节点。\n为了简单理解，这里只演示单向循环链表。\n\n从图中可以看出，他和单向链表基本没差别，无非就是将尾节点的next设置为头节点即可（注意这个点就理解了），\n也就是说单向循环链表的定义和单向链表的定义基本一致，只是多了一个标志，用于结束循环。\n2.循环链表的实现\n2.1 节点定义\n/** * 单向循环链表 */public class Node &#123;    //存储数据的变量    public int data;    //它存储了下一个节点对象引用    public Node next;    //节点名称    public String nodeName;    //是否头节点标识    public boolean isHead = false;    public Node(int data, String nodeName)&#123;        this.data=data;        if(nodeName==null)&#123;            nodeName=&quot;&quot;+data;        &#125;        this.nodeName = nodeName;    &#125;&#125;\n2.2 操作方法定义\n2.2.1 计算链表长度\n/** * 以输入节点为头，计算出链表长度 * @param head 任意节点 * @return 链表长度 */static int ListLength(Node head) &#123;    int length = 0;    Node cur = head;    if(cur==null) return length;    //先把第一个节点设置为头节点    cur.isHead = true;    length++;    cur = cur.next;    while (!cur.isHead) &#123;        length++;        cur = cur.next;    &#125;    // 还原    head.isHead = false;    return length;&#125;\n2.2.2 打印链表内容\n/** * 遍历打印链表内容 * @param headNode 链表头节点 */static void toString(Node headNode) &#123;    Node check = headNode;    int size = ListLength(headNode);    if(check==null)&#123;        System.out.print(&quot;null&quot;);        return;    &#125;    for(int i=0; i &lt; size+1; i++)&#123;        System.out.print(check.nodeName+&quot;-&gt;&quot;);        check = check.next;    &#125;&#125;\n2.2.3 获取链表最后一个节点\n/** * 此方法用于获得链表的最后一个节点 * @param head 头节点 * @return 循环链表的最后一个节点 */static Node getLastNode(Node head) &#123;    Node cur = head;    Node pre = head;    if(cur==null) return null;    cur.isHead = true;    cur = cur.next;    while (cur!=null&amp;&amp;!cur.isHead)&#123;        pre = cur;        cur = cur.next;    &#125;    head.isHead = false;    return pre;&#125;\n2.2.4 插入节点\n/** * 主要思路是： *      先判断链表中存不存在position位置，若没有输出错误信息并返回头节点； *      若存在则进行插入操作：首先判断position是不是为1，因为这种情况不同于其他的。 *      否则，先找到第position-1个节点和position个节点，将前一个节点的下一节点设为nodeToInsert *      将nodeToInsert的下一个节点设置为position节点，这样完成插入操作 * @param headNode 链表头节点 * @param nodeToInsert 要插入的节点 * @param position 指定插入的位置 * @return 插入后的链表头节点 */static Node Insert(Node headNode, Node nodeToInsert, int position ) &#123;    if(headNode == null) &#123;        return nodeToInsert;    &#125;    //获得输入链表的长度    int size = ListLength(headNode);    //判断链表内是否存在此位置    if(position&gt;size || position&lt;0) &#123;        System.out.println(&quot;Position of node to insert is invalid.The valid inputs are 0 to&quot;+(size));        return headNode;    &#125;    //获取尾节点    Node lastNode = getLastNode(headNode);    //在链表开头插入    if(position == 0) &#123;        nodeToInsert.next = headNode;        //让尾节点指向该节点        if(lastNode!=null)            lastNode.next = nodeToInsert;        return nodeToInsert;    &#125;    //在末尾插入    else if(position == size) &#123;        //插入操作        nodeToInsert.next = headNode;        if(lastNode!=null)            lastNode.next = nodeToInsert;    &#125;    //在中间插入    else &#123;        Node pre = headNode;        int count = 0;        //找到那个位置的前一个节点        while(count &lt; position-1) &#123;            //获得第position-1位置的节点            pre = pre.next;            count++;        &#125;        //获得第position位置的节点        Node currentNode = pre.next;        //插入操作        nodeToInsert.next = currentNode;        pre.next = nodeToInsert;    &#125;    return headNode;&#125;\n2.2.5 删除指定位置的节点\n/** * 方法和前面的插入方法有异曲同工之妙： *  主要思想是找到position的前一个节点和后一个节点，然后将他们连接 * @param headNode 头节点 * @param position 删除的位置 * @return 删除后的链表头节点 */static Node Delete(Node headNode, int position) &#123;    if(headNode == null) return null;    int size = ListLength(headNode);    if(position &gt; size-1||position &lt; 0) &#123;        System.out.println(&quot;Position of node to delete is invalid. The valid inputs are 0 to &quot;+(size-1));        return headNode;    &#125;    Node lastNode = getLastNode(headNode);    //删除表头    if(position == 0) &#123;        if(lastNode!=null) &#123;            lastNode.next = headNode.next;            return headNode.next;        &#125;else return null;    &#125;    //删除中间或结尾节点    else &#123;        Node previousNode = headNode;        int count = 0 ;        //获得目标节点的上一个节点        while(count &lt; position-1) &#123;            previousNode = previousNode.next;            count++;        &#125;        //要删除目标节点        Node currentNode = previousNode.next;        previousNode.next = currentNode.next;    &#125;    return headNode;&#125;\n3.循环链表测试\n3.1 编写循环链表自动生成方法\n/** * 生成一个min 到 max之间的随机数 * @param min 最小数 * @param max 最大数 * @return 随机数 */public static int numberGenerator(int min,int max) &#123;    int number= (int) (Math.random()*max);    while (number&lt;min)&#123;        number= (int) (Math.random()*max);    &#125;    return number;&#125;\n/** * 自动随机创建循环链表，用于测试 * @param length 链表长度 * @param min 链表最小值 * @param max 链表最大值 * @return 生成的循环链表 */public static Node generatorCycleList(int length, int min, int max) &#123;    Node headNode = null;    Node nextNode = null;    for(int i=0;i&lt;length;i++)&#123;        int num = numberGenerator(min,max);        if(headNode==null)&#123;            headNode = new Node(num,null);            nextNode = headNode;        &#125;        else &#123;            Node node = new Node(num,null);            nextNode.next = (node);            nextNode = node;            if(i==length-1)&#123;                node.next = headNode;            &#125;        &#125;    &#125;    return headNode;&#125;\n3.2 然后进行测试用例编写\npublic void LengthTest() &#123;    Node cycleListNode= generatorCycleList(10,1,18);    System.out.print(&quot;循环链表长度：&quot;);    System.out.println(CycleList.ListLength(cycleListNode));    CycleList.toString(cycleListNode);&#125;public void InsertTest() &#123;    Node cycleListNode= generatorCycleList(10,1,18);    System.out.print(&quot;循环链表长度：&quot;);    System.out.println(CycleList.ListLength(cycleListNode));    CycleList.toString(cycleListNode);    System.out.println();    System.out.println(&quot;插入操作：&quot;);    Node test1 = new Node(23,null);    cycleListNode= CycleList.Insert(cycleListNode,test1,9);    CycleList.toString(cycleListNode);    System.out.println();&#125;public void DeleteTest() &#123;    Node cycleListNode= generatorCycleList(10,1,18);    System.out.print(&quot;循环链表长度如下：&quot;);    System.out.println(CycleList.ListLength(cycleListNode));    CycleList.toString(cycleListNode);    System.out.println();    System.out.println(&quot;删除操作：&quot;);    cycleListNode= CycleList.Delete(cycleListNode,10);    CycleList.toString(cycleListNode);&#125;\n最后，就可以进行各种场景的测试与进一步学习了！！\n","tags":["算法基础"]},{"title":"4.2 双向链表","url":"/article/Algorithm-Base-4-2-Java%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/","content":"1.什么是双向链表？\n双向链表由多个节点组成，每个 节点（用于存储数据） 通过prev,next指针和前,后节点相互连接，\n下一个节点的引用存放在上一个节点的next指针中， 上一个节点的引用存放在下一个节点的prev指针中，\n从而构成了一个线性的链表 （它与数组的区别就是它可以不具空间连续性）\n在java中一般通过定义节点Node类和API类的方式来实现链表 \nJDK中对链表LinkedList的节点的实现结构如下：\n可以看到链表节点组成分为三部分:\n存储数据的元素item ， 当前节点下一节点的引用next， 当前节点上一节点的引用prev\nprivate static class Node&lt;E&gt; {    E item;    Node&lt;E&gt; next;    Node&lt;E&gt; prev;    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {        this.item = element;        this.next = next;        this.prev = prev;    }}\n可以知道JDK的链表实现就是双向链表.\n节点定义一般就放在API内部作为内部静态类使用，我们使用链表数据结构都是通过LinkedList API对外开放的接口进行调用的，\n我们不允许直接对链表内部属性直接访问。\n1.1 双向链表基本结构\n下面我们学习最基本的链表结构,我们默认链表中的元素就是int类型数字。\n如图所示：\nflowchart LR\n   node1 &lt;--prev.node1.next--&gt; node2 &lt;--prev.node2.next--&gt; node3 &lt;--prev.node3.next--&gt; null\n其中节点的数据结构为：\n/** * 双向链表节点数据结构 */public class Node {  /**   * 存储节点数据   */  public int data;  /**   * 存储下一个节点引用   */  public Node next;  /**   * 本节点名称   */  public String nodeName;  /**   * 上一个节点的引用   */  public Node previous;  /**   * 节点构造方法，仅构造出其存储的数据，并不构造下一节点的引用   * @param data 节点数据   */  public Node(int data, String nodeName){    this.data = data;    if(nodeName==null){      nodeName=\"\"+data;    }    this.nodeName = nodeName;  }}\n我们该如何实现操作双向链表的方法来让我们正确双向链表存储数据呢？\n1.2 实现对双向链表基本的增删改查\n1.2.1 插入方法\n给出一个节点nodeToInsert和指定位置position,在链表指定位置插入该节点\n主要思路分为正向插入或反向插入，这两种插入的方法的不同点在于使用不同的起始位置和指针进行遍历查找，\n正向插入使用的是head为起始位置next指针查找，反向插入使用的是tail为起始位置previous指针查找。\n具体流程如下：\n\n\n首先判断链表是否为空,如果为空则直接放入第一个节点\n\n\n再先判断链表中存不存在position位置，\n若不存在输出错误信息并返回\n若存在则进行插入操作：(正向插入逻辑)\n\n首先判断position是不是为0,因为这种情况不同于其他的,如果是则直接进行头节点插入\n否则，先找到第position-1个节点和position个节点。\n将前一个节点的下一节点设为nodeToInsert ,将nodeToInsert的下一个节点设置为position节点\n\n\n\n这样就完成了元素插入\n\n\n代码实现如下：\nclass Test{  /**   * 正向插入   * 主要思路是：   *      先判断链表中存不存在position位置，若没有输出错误信息并返回头节点；   *      若存在则进行插入操作：首先判断position是不是为0，因为这种情况不同于其他的。   *      否则，先找到第position-1个节点和position个节点，将前一个节点的下一节点设为nodeToInsert   *      将nodeToInsert的下一个节点设置为position节点，这样完成插入操作   * @param headNode 链表头节点   * @param nodeToInsert 要插入的节点   * @param position 指定插入的位置   * @return 插入后的链表头节点   */  static Node insertByHead(Node headNode, Node nodeToInsert, int position) {    if(headNode==null) {      return nodeToInsert;    }    //获得输入链表的长度    int size = ListLengthByHead(headNode);    //判断链表内是否存在此位置    if(position &gt; size || position &lt; 0) {      System.out.println(\"位置异常！！ position不能超过 \"+size);      return headNode;    }    //在链表开头插入    if(position == 0) {      nodeToInsert.next = headNode;      headNode.previous = nodeToInsert;      return nodeToInsert;    }    //在中间或末尾插入    else {      Node prev = headNode;      int count = 0;      //找到那个位置的前一个节点      while(count &lt; position-1) {        //获得第position-1位置的节点        prev = prev.next;        count++;      }      //获得第position位置的节点      Node currentNode = prev.next;      // 在cur不为空的时候才进行insert和cur之间的关系改变      if(currentNode!=null) {        nodeToInsert.next = currentNode;        currentNode.previous = nodeToInsert;      }      prev.next =nodeToInsert;      nodeToInsert.previous = prev;    }    return headNode;  }  /**   * 反向插入,以尾节点尾开始节点进行插入操作   * @param tailNode 链表尾节点   * @param nodeToInsert 要插入的节点   * @param position 指定插入的位置   * @return 插入后的链表头节点   */  static Node insertByTail(Node tailNode, Node nodeToInsert, int position) {    if(tailNode == null) {      return nodeToInsert;    }    //获得输入链表的实际长度    int size = ListLengthByTail(tailNode);    //判断链表内是否存在此位置    if(position &gt; size || position &lt; 0) {      System.out.println(\"位置异常！！ position不能超过 \"+size);      return tailNode;    }    //在链表结尾插入    if(position == size) {      nodeToInsert.previous = tailNode;      tailNode.next = nodeToInsert;      return nodeToInsert;    }    //在中间或开头插入    else {      Node previousNode = tailNode;      int count = 0;      //找到那个位置的前一个节点      while(count &lt; size-position-1) {        //获得第position-1位置的节点        previousNode = previousNode.previous;        count++;      }      //获得第position位置的节点      Node currentNode = previousNode.previous;      //插入操作      if(currentNode!=null) {        currentNode.next = nodeToInsert;        nodeToInsert.previous = currentNode;      }      nodeToInsert.next = previousNode;      previousNode.previous = nodeToInsert;    }    return tailNode;  }  /**   * 以输入节点为头，计算出链表长度   * @param head 头节点   * @return 链表长度   */  static int ListLengthByHead(Node head) {    int length = 0;    Node cur = head;    while(cur!=null){      length++;      cur = cur.next;    }    return length;  }  /**   * 以输入节点为尾，计算出链表长度   * @param tail 尾节点   * @return 链表长度   */  static int ListLengthByTail(Node tail) {    int length = 0;    Node cur = tail;    while (cur!=null){      length++;      cur = cur.previous;    }    return length;  }}\n1.2.2 如何删除链表的元素\n主要思路是找到position的前一个节点和后一个节点，然后将他们连接,\n这里展示头节点处理，尾节点处理方法可以结合上下文自己试着写一下\n代码实现：\nclass Test{  /**   * 方法和前面的插入方法有异曲同工之妙：   *  主要思想是找到position的前一个节点和后一个节点，然后将他们连接   * @param headNode 头节点   * @param position 删除的位置   * @return 删除后的链表头节点   */  static Node deleteByHead(Node headNode, int position) {    int size = ListLengthByHead(headNode);    if(position&gt;=size||position&lt;0) {      System.out.println(\"位置异常！！ position位置不能超过 \"+(size-1));      return headNode;    }    //删除表头    if(position==0) {      //将第二个节点的上一节点引用删除      headNode.next.previous = null;      return headNode.next;    }    //删除中间或结尾节点    else {      Node previousNode = headNode;      int count = 0;      //获得目标节点的上一个节点      while(count &lt; position-1) {        previousNode = previousNode.next;        count++;      }      //要删除目标节点      Node currentNode = previousNode.next;      previousNode.next = currentNode.next;      if(currentNode.next!=null)        currentNode.next.previous = previousNode;    }    return headNode;  }    /**     * 以输入节点为头，计算出链表长度     * @param head 头节点     * @return 链表长度     */    static int ListLengthByHead(Node head) {        int length = 0;        Node current = head;        while(current!=null){            length++;            current = current.next;        }        return length;    }}\n1.2.3 如何得到指定位置的值\nclass Test{  /**   * 获取链表指定位置的元素   * @param head   * @param position   * @return   */  static Node getByHead(Node head,int position) {    int size = ListLengthByHead(head);    if( position &lt; 0 || position &gt;= size) {      System.out.println(\"链表不存在该位置： \"+ position +\"链表最大位置索引： \"+(size-1));      return null;    }    Node cur = head;    for (int index = 0;index &lt; position;index++){      cur = cur.next;    }    return cur;  }  static Node getByTail(Node tail,int position) {    int size = ListLengthByTail(tail);    if(position&lt;0 || position &gt;= size){      System.out.println(\"链表不存在该位置： \"+ position +\"链表最大位置索引： \"+(size-1));      return null;    }    Node cur = tail;    for(int index = 0;index&lt; (size-position-1);index++){      cur = cur.previous;    }    return cur;  }    }\n","tags":["算法基础"]},{"title":"4.4 松散链表","url":"/article/Algorithm-Base-4-4-Java%E5%AE%9E%E7%8E%B0%E6%9D%BE%E6%95%A3%E9%93%BE%E8%A1%A8/","content":"1.什么是松散链表？\n1.1 松散链表定义\n松散链表是单向链表和(循环链表/数组/双向链表/单向链表)的一种有效结合，松散链表中的每个节点存储一个块，每个块中可以有多个元素，\n这些元素由(循环链表/数组/双向链表/单向链表)存放链接在一起。\n如图所示：\n这是松散链表的结构，它的节点也是链表结构\nflowchart LR\n   List1 --List1.next--&gt; List2 --List2.next--&gt; List3 --List3.next--&gt; null\n其中链表的结构如下\nflowchart LR\n   node1 --node1.next--&gt; node2 --node2.next--&gt; node3 --node3.next--&gt; null\n假设在任何时候松散链表中的块的个数不超过n。\n为了进一步简化问题，我们假设除了最后一块外，其他块恰好含有n个元素。\n在这样的情况下，在任何时候，松散链表中总元素的个数不会超过n^2。\n1.2 在松散链表中查找一个元素\n在松散链表中查找第k个块的时间开销最大为O(n),同理在一个块中找到第m个元素的时间开销最大为O(n)\n所以，在松散链表中查找一个元素的最大时间开销为O(n^2)，这和其他链表查找元素的时间复杂度一致。\n1.3 在松散链表中查找指定位置的元素\n这个操作相对于普通链表，松散链表的优势就体现出来了。在元素个数为n^2的链表中\n普通链表查找指定位置的元素的时间复杂度为O(n^2)\n松散链表查找指定位置的元素的时间复杂度为O(n), 由于块的原因，我们可以避免大量不必要的遍历。\n1.4 在松散链表中插入一个元素\n与其他类型的链表不同的是，当插入元素时，可能需要重新调整松散链表中的元素的位置来维护松散链表的属性。\n假如每个块中包含n个元素，假设要在第i个元素的后面插入元素x，且将x放在第j块中。\n如果链表中块的空间不足，则还需要在当前块后面添加一个新块。\n如图所示：\n例如，现在有下面的松散链表结构：\n\n进行插入操作我们很容易知道其时间复杂度为O(i)\n这个维护的时间复杂度我们需要进行分析一下：\n其实，从直观的角度看，插入一个元素后，可能存在结构调整的情况，但是这个调整的时间复杂度也是极低的。\n所以进行一次插入操作的总体时间复杂度为：O(n),这相比于普通链表提升了一个量级！！\n2. Java实现松散链表\n2.1 首先是节点定义\nimport lombok.Data;@Datapublic class Node {    /**     * 下一个块     */    Node next;    /**     * 前一个块     */    Node previous;    /**     * 此块的实际元素数量     */    int numElements = 0;    /**     * 块存储元素的数组     */    Object[] elements;    //构造新块    public Node(int nodeCapacity) {        elements = new Object[nodeCapacity];    }}\n2.2 然后就是具体的实现\npackage course.p4_list.s5_RelaxList;import java.lang.reflect.Array;import java.util.AbstractList;import java.util.Collection;import java.util.Iterator;import java.util.List;import java.util.ListIterator;import java.util.NoSuchElementException;import java.io.Serializable;import java.util.ConcurrentModificationException;/** * 松散链表定义类 * @param &lt;E&gt; */public class RelaxList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, Serializable {    /**     * 链表中块的容量     */    private final int RelaxNodeCapacity;    /**     * 链表元素总个数     */    private int size = 0;    /**     *  链表第一个块     */    private final Node firstRelaxNode;    /**     *  链表最后一个块     */    private Node lastRelaxNode;    private static final long serialVersionUID = -674052309103045211L;    /**     * 松散链表带参构造方法     * @param RelaxNodeCapacity 指定松散链表的块大小,这里必须不小于8     * @throws IllegalArgumentException 如果定义的块大小小于8，抛出异常     */    public RelaxList(int RelaxNodeCapacity) throws IllegalArgumentException {        if (RelaxNodeCapacity &lt; 8) {            throw new IllegalArgumentException(\"RelaxNodeCapacity &lt; 8\");        }        this.RelaxNodeCapacity = RelaxNodeCapacity;        firstRelaxNode = new Node(RelaxNodeCapacity);        lastRelaxNode = firstRelaxNode;    }    /**     * 松散链表无参构造方法，默认构造出块大小为16的松散链表     */    public RelaxList() {        this(16);    }    /**     * 将指定的元素添加到链表的末尾     * @param e 指定元素     * @return 返回true     */    @Override    public boolean add(E e) {        insertIntoRelaxNode(lastRelaxNode, lastRelaxNode.numElements, e);        return true;    }    /**     * 返回链表大小     * @return int     */    public int size() {        return size;    }    /**     * 判断链表是否为空     * @return boolean     */    @Override    public boolean isEmpty() {        return (size == 0);    }    /**     * 查询链表是否包含指定元素，如果包含返回true     * @param o 指定元素     * @return boolean     */    @Override    public boolean contains(Object o) {        return (indexOf(o) != -1);    }    /**     * 查找链表中是否存在指定元素     * @param o 指定元素     * @return 元素所在的位置     */    @Override    public int indexOf(Object o) {        int index = 0;        Node RelaxNode = firstRelaxNode;        if (o == null) {            while (RelaxNode != null) {                for (int ptr = 0; ptr &lt; RelaxNode.numElements; ptr++) {                    if (RelaxNode.elements[ptr] == null) {                        return index + ptr;                    }                }                index += RelaxNode.numElements;                RelaxNode = RelaxNode.next;            }        } else {            while (RelaxNode != null) {                for (int ptr = 0; ptr &lt; RelaxNode.numElements; ptr++) {                    if (o.equals(RelaxNode.elements[ptr])) {                        return index + ptr;                    }                }                index += RelaxNode.numElements;                RelaxNode = RelaxNode.next;            }        }        return -1;    }    /**     * 获得松散链表的迭代器     * @return 迭代器     */    @Override    public Iterator&lt;E&gt; iterator() {        return new RelaxIterator(firstRelaxNode, 0, 0);    }    /**     * 将链表元素集合转化为Object数组返回     * @return 数组     */    @Override    public Object[] toArray() {        Object[] array = new Object[size];        int p = 0;        for (Node RelaxNode = firstRelaxNode; RelaxNode != null; RelaxNode = RelaxNode.next) {            for (int i = 0; i &lt; RelaxNode.numElements; i++) {                array[p] = RelaxNode.elements[i];                p++;            }        }        return array;    }    /**     * 返回指定类型的数组     * @param a 指定类型的空数组     * @param &lt;T&gt; 泛型变量     * @return 类型数组对象     */    @Override    @SuppressWarnings({ \"unchecked\" })    public &lt;T&gt; T[] toArray(T[] a) {        //如果传入的数组大小小于链表大小，则重新新建一个数组        if (a.length &lt; size) {            //新建一个指定类型的数组            a = (T[])Array.newInstance(a.getClass().getComponentType(),size);        }        Object[] result = a;        int p = 0;        for (Node RelaxNode = firstRelaxNode; RelaxNode != null; RelaxNode = RelaxNode.next) {            for (int i = 0; i &lt; RelaxNode.numElements; i++) {                result[p] = RelaxNode.elements[i];                p++;            }        }        return a;    }    /**     * 删除链表中指定元素     * 如果成功删除返回true 如果不存在此元素返回false     * @param o 指向元素对象     * @return 是否成功删除     */    @Override    public boolean remove(Object o) {        int index = 0;        Node RelaxNode = firstRelaxNode;        if (o == null) {            while (RelaxNode != null) {                for (int ptr = 0; ptr &lt; RelaxNode.numElements; ptr++) {                    if (RelaxNode.elements[ptr] == null) {                        removeFromRelaxNode(RelaxNode, ptr);                        return true;                    }                }                index += RelaxNode.numElements;                RelaxNode = RelaxNode.next;            }        } else {            while (RelaxNode != null) {                for (int ptr = 0; ptr &lt; RelaxNode.numElements; ptr++) {                    if (o.equals(RelaxNode.elements[ptr])) {                        removeFromRelaxNode(RelaxNode, ptr);                        return true;                    }                }                index += RelaxNode.numElements;                RelaxNode = RelaxNode.next;            }        }        return false;    }    /**     * 判断链表是否包含入参集合的所有元素     * @param c 集合     * @return 全包含返回true 不全包含返回false     */    @Override    public boolean containsAll(Collection&lt;?&gt; c) {        if (c == null) {            throw new NullPointerException();        }        for (Object o : c) {            if (!contains(o)) {                return false;            }        }        return true;    }    /**     * 将指定集合中所有元素加入到链表中     * @param c 指向集合     * @return 成功返回true 失败返回false     */    @Override    public boolean addAll(Collection&lt;? extends E&gt; c) {        if (c == null) {            throw new NullPointerException();        }        boolean changed = false;        for (E e : c) {            add(e);            changed = true;        }        return changed;    }    /**     * 从链表中删除集合c中所有元素     * @param c 集合c     * @return 成功标志     */    @Override    public boolean removeAll(Collection&lt;?&gt; c) {        if (c == null) {            throw new NullPointerException();        }        Iterator&lt;?&gt; it = c.iterator();        boolean changed = false;        while (it.hasNext()) {            if (remove(it.next())) {                changed = true;            }        }        return changed;    }    /**     *删除链表中除包含在集合c中的其他所有元素，仅保留c中有的     * @param c 指定集合c     * @return 成功标志     */    @Override    public boolean retainAll(Collection&lt;?&gt; c) {        if (c == null) {            throw new NullPointerException();        }        boolean changed = false;        for (Node RelaxNode = firstRelaxNode; RelaxNode != null; RelaxNode = RelaxNode.next) {            for (int i = 0; i &lt; RelaxNode.numElements; i++) {                if (!c.contains(RelaxNode.elements[i])) {                    removeFromRelaxNode(RelaxNode, i);                    i--;                    changed = true;                }            }        }        return changed;    }    /**     *清空链表，只剩一个头，且头中元素都清除了     */    @Override    public void clear() {        Node RelaxNode = firstRelaxNode.next;        while (RelaxNode != null) {            Node next = RelaxNode.next;            RelaxNode.next = null;            RelaxNode.previous = null;            RelaxNode.elements = null;            RelaxNode = next;        }        lastRelaxNode = firstRelaxNode;        for (int ptr = 0; ptr &lt; firstRelaxNode.numElements; ptr++) {            firstRelaxNode.elements[ptr] = null;        }        firstRelaxNode.numElements = 0;        firstRelaxNode.next = null;        size = 0;    }    /**     *获得指定位置的元素     * @param index 指定位置     * @return 返回指定位置元素     * @throws IndexOutOfBoundsException 如果传入的位置不合法，抛出异常     */    @SuppressWarnings({ \"unchecked\" })    public E get(int index) throws IndexOutOfBoundsException {        if (index &lt; 0 || index &gt;= size) {            throw new IndexOutOfBoundsException();        }        Node RelaxNode;        int p = 0;        if (size - index &gt; index) {            RelaxNode = firstRelaxNode;            while (p &lt;= index - RelaxNode.numElements) {                p += RelaxNode.numElements;                RelaxNode = RelaxNode.next;            }        } else {            RelaxNode = lastRelaxNode;            p = size;            while ((p -= RelaxNode.numElements) &gt; index) {                RelaxNode = RelaxNode.previous;            }        }        return (E) RelaxNode.elements[index - p];    }    /**     *更新指定位置的元素     * @param index 指定位置     * @param element 指定元素     * @return 返回此位置的原来的元素     */    @Override    @SuppressWarnings({ \"unchecked\" })    public E set(int index, E element) {        if (index &lt; 0 || index &gt;= size) {            throw new IndexOutOfBoundsException();        }        E el = null;        Node RelaxNode;        int p = 0;        if (size - index &gt; index) {            RelaxNode = firstRelaxNode;            while (p &lt;= index - RelaxNode.numElements) {                p += RelaxNode.numElements;                RelaxNode = RelaxNode.next;            }        } else {            RelaxNode = lastRelaxNode;            p = size;            while ((p -= RelaxNode.numElements) &gt; index) {                RelaxNode = RelaxNode.previous;            }        }        el = (E) RelaxNode.elements[index - p];        RelaxNode.elements[index - p] = element;        return el;    }    /**     *在指定位置添加元素     * @param index 指定位置     * @param element 指定元素     * @throws IndexOutOfBoundsException     */    @Override    public void add(int index, E element) throws IndexOutOfBoundsException {        if (index &lt; 0 || index &gt; size) {            throw new IndexOutOfBoundsException();        }        Node RelaxNode;        int p = 0;        if (size - index &gt; index) {            RelaxNode = firstRelaxNode;            while (p &lt;= index - RelaxNode.numElements) {                p += RelaxNode.numElements;                RelaxNode = RelaxNode.next;            }        } else {            RelaxNode = lastRelaxNode;            p = size;            while ((p -= RelaxNode.numElements) &gt; index) {                RelaxNode = RelaxNode.previous;            }        }        insertIntoRelaxNode(RelaxNode, index - p, element);    }    /**     *删除指定位置的元素     * @param index 指定位置     * @return 返回删除之前这个位置的元素     * @throws IndexOutOfBoundsException 如果位置不合法，抛出异常     */    @Override    @SuppressWarnings({\"unchecked\"})    public E remove(int index) throws IndexOutOfBoundsException {        if (index &lt; 0 || index &gt;= size) {            throw new IndexOutOfBoundsException();        }        E element = null;        Node RelaxNode;        int p = 0;        if (size - index &gt; index) {            RelaxNode = firstRelaxNode;            while (p &lt;= index - RelaxNode.numElements) {                p += RelaxNode.numElements;                RelaxNode = RelaxNode.next;            }        } else {            RelaxNode = lastRelaxNode;            p = size;            while ((p -= RelaxNode.numElements) &gt; index) {                RelaxNode = RelaxNode.previous;            }        }        element = (E) RelaxNode.elements[index - p];        removeFromRelaxNode(RelaxNode, index - p);        return element;    }    /**     *找出指定元素在链表中最后出现的位置索引     * @param o 指定元素     * @return 返回位置索引     */    @Override    public int lastIndexOf(Object o) {        int index = size;        Node RelaxNode = lastRelaxNode;        if (o == null) {            while (RelaxNode != null) {                index -= RelaxNode.numElements;                for (int i = RelaxNode.numElements - 1; i &gt;= 0; i--) {                    if (RelaxNode.elements[i] == null) {                        return (index + i);                    }                }                RelaxNode = RelaxNode.previous;            }        } else {            while (RelaxNode != null) {                index -= RelaxNode.numElements;                for (int i = RelaxNode.numElements - 1; i &gt;= 0; i--) {                    if (o.equals(RelaxNode.elements[i])) {                        return (index + i);                    }                }                RelaxNode = RelaxNode.previous;            }        }        return -1;    }    /**     *得到这个链表的迭代器     * @return 链表迭代器     */    @Override    public ListIterator&lt;E&gt; listIterator() {        return new RelaxIterator(firstRelaxNode, 0, 0);    }    /**     *得到从指定位置后的松散链表迭代器     * @param index 指定位置     * @return 链表迭代器     */    @Override    public ListIterator&lt;E&gt; listIterator(int index) {        if (index &lt; 0 || index &gt; size) {            throw new IndexOutOfBoundsException();        }        Node RelaxNode;        int p = 0;        if (size - index &gt; index) {            RelaxNode = firstRelaxNode;            while (p &lt;= index - RelaxNode.numElements) {                p += RelaxNode.numElements;                RelaxNode = RelaxNode.next;            }        } else {            RelaxNode = lastRelaxNode;            p = size;            while ((p -= RelaxNode.numElements) &gt; index) {                RelaxNode = RelaxNode.previous;            }        }        return new RelaxIterator(RelaxNode, index - p, index);    }    /**     * 向指定块的指定位置插入指定元素     * @param RelaxNode 指定块     * @param ptr 指定位置     * @param element 指定元素     */    private void insertIntoRelaxNode(Node RelaxNode, int ptr, E element) {        //如果这个块满了        if (RelaxNode.numElements == RelaxNodeCapacity) {            // 创建一个新块            Node newRelaxNode = new Node(RelaxNodeCapacity);            // 将一半的元素移到新块中            int elementsToMove = RelaxNodeCapacity / 2;            int startIndex = RelaxNodeCapacity - elementsToMove;            int i;            for (i = 0; i &lt; elementsToMove; i++) {                newRelaxNode.elements[i] = RelaxNode.elements[startIndex + i];                RelaxNode.elements[startIndex + i] = null;            }            RelaxNode.numElements -= elementsToMove;            newRelaxNode.numElements = elementsToMove;            // 将新块插入到链表指定块后面            newRelaxNode.next = RelaxNode.next;            newRelaxNode.previous = RelaxNode;            if (RelaxNode.next != null) {                RelaxNode.next.previous = newRelaxNode;            }            RelaxNode.next = newRelaxNode;            if (RelaxNode == lastRelaxNode) {                lastRelaxNode = newRelaxNode;            }            // 如果插入位置大于原始块的实际元素数,此元素应该插入新块中            if (ptr &gt; RelaxNode.numElements) {                RelaxNode = newRelaxNode;                ptr -= RelaxNode.numElements;            }        }        //由于块是数组是实现，所以插入位置后的元素都后移一位        for (int i = RelaxNode.numElements; i &gt; ptr; i--) {            RelaxNode.elements[i] = RelaxNode.elements[i-1];        }        //执行插入操作        RelaxNode.elements[ptr] = element;        RelaxNode.numElements++;        //维护链表大小        size++;        modCount++;    }    /**     * 删除块指定位置的元素     * @param RelaxNode 指定块     * @param ptr 指定位置     */    private void removeFromRelaxNode(Node RelaxNode, int ptr) {        RelaxNode.numElements--;        //后面的元素向前移动一位        for (int i = ptr; i &lt; RelaxNode.numElements; i++) {            RelaxNode.elements[i] = RelaxNode.elements[i + 1];        }        RelaxNode.elements[RelaxNode.numElements] = null;        //如果此块不是最后一个块且此块和它的下一个块的元素总数小于块大小，则进行块合并操作        if (RelaxNode.next != null &amp;&amp; (RelaxNode.next.numElements + RelaxNode.numElements) &lt;= RelaxNodeCapacity) {            mergeWithNextRelaxNode(RelaxNode);            //如果此块不是最后一个块且它和上一个块的元素总数小于块大小，则进行合并操作        } else if (RelaxNode.previous != null &amp;&amp; (RelaxNode.previous.numElements + RelaxNode.numElements) &lt;= RelaxNodeCapacity) {            mergeWithNextRelaxNode(RelaxNode.previous);        }        size--;        modCount++;    }    /**     * 块合并操作：将指定块和它的下一个块进行合并     * @param RelaxNode 指定块     */    private void mergeWithNextRelaxNode(Node RelaxNode) {        Node next = RelaxNode.next;        for (int i = 0; i &lt; next.numElements; i++) {            RelaxNode.elements[RelaxNode.numElements + i] = next.elements[i];            next.elements[i] = null;        }        //块的元素总数变量维护        RelaxNode.numElements += next.numElements;        if (next.next != null) {            next.next.previous = RelaxNode;        }        RelaxNode.next = next.next;        if (next == lastRelaxNode) {            lastRelaxNode = RelaxNode;        }    }    /**     * 松散链表迭代器     */    private class RelaxIterator implements ListIterator&lt;E&gt; {        Node currentRelaxNode;        int ptr;        int index;        private final int expectedModCount = modCount;        RelaxIterator(Node RelaxNode, int ptr, int index) {            this.currentRelaxNode = RelaxNode;            this.ptr = ptr;            this.index = index;        }        //下一个位置        @Override        public boolean hasNext() {            return (index &lt; size - 1);        }        @Override        @SuppressWarnings({\"unchecked\"})        public E next() {            ptr++;            if (ptr &gt;= currentRelaxNode.numElements) {                if (currentRelaxNode.next != null) {                    currentRelaxNode = currentRelaxNode.next;                    ptr = 0;                } else {                    throw new NoSuchElementException();                }            }            index++;            checkForModification();            return (E) currentRelaxNode.elements[ptr];        }        //判断        @Override        public boolean hasPrevious() {            return (index &gt; 0);        }        @Override        @SuppressWarnings({\"unchecked\"})        public E previous() {            ptr--;            if (ptr &lt; 0) {                if (currentRelaxNode.previous != null) {                    currentRelaxNode = currentRelaxNode.previous;                    ptr = currentRelaxNode.numElements - 1;                } else {                    throw new NoSuchElementException();                }            }            index--;            checkForModification();            return (E) currentRelaxNode.elements[ptr];        }        @Override        public int nextIndex() {            return (index + 1);        }        @Override        public int previousIndex() {            return (index - 1);        }        @Override        public void remove() {            checkForModification();            removeFromRelaxNode(currentRelaxNode, ptr);        }        @Override        public void set(E e) {            checkForModification();            currentRelaxNode.elements[ptr] = e;        }        @Override        public void add(E e) {            checkForModification();            insertIntoRelaxNode(currentRelaxNode, ptr + 1, e);        }        private void checkForModification() {            if (modCount != expectedModCount) {                throw new ConcurrentModificationException();            }        }    }}\n2.3 最后就是测试工作\nimport org.junit.Test;import java.util.LinkedList;public class TestDemo {    public static void main(String[] args) {        //统计jdk自带链表add 500万个元素所需时间        LinkedList&lt;Integer&gt; ll = new LinkedList&lt;Integer&gt;();        long endTime;        long startTime = System.currentTimeMillis();        for (int i = 0; i &lt; 5000000; i++) {            ll.add(i);        }        endTime = System.currentTimeMillis();        System.out.println(\"Jdk实现的普通链表add500万个元素所需时间 -&gt; \" + (endTime - startTime)+\"ms\");        //统计长度为500万的普通链表删除第250万个位置的元素所需时间        startTime = System.currentTimeMillis();        ll.remove(2500000);        endTime = System.currentTimeMillis();        System.out.println(\"普通链表删除第250万个元素所需要的时间-&gt;\" + (endTime - startTime)+\"ms\");        ll = null;        System.gc();        //相同条件下松散链表的表现        RelaxList&lt;Integer&gt; ull = new RelaxList&lt;&gt;(16);        startTime = System.currentTimeMillis();        for (int i = 0; i &lt; 5000000; i++) {            ull.add(i);        }        System.out.println(ull.size());        endTime = System.currentTimeMillis();        System.out.println(\"松散链表add 500万个元素所需时间 -&gt; \" + (endTime - startTime)+\"ms\");        startTime = System.currentTimeMillis();        System.out.println(ull.remove(2500000));        endTime = System.currentTimeMillis();        System.out.println(\"松散链表删除第250万个元素所需时间-&gt;\" + (endTime - startTime)+\"ms\");    }    @Test    public void Test(){        RelaxList&lt;String&gt; test1=new RelaxList&lt;&gt;(10);        RelaxList&lt;String&gt; test2=new RelaxList&lt;&gt;(12);    }}\n测试结果如下：\n\n","tags":["算法基础"]},{"title":"4.5 双向链表存储优化","url":"/article/Algorithm-Base-4-5-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E7%A7%8D%E4%BC%98%E5%8C%96%EF%BC%88%E5%AD%98%E5%82%A8%E4%BC%98%E5%8C%96%EF%BC%89/","content":"一.为什么优化？\n当我们学习双向链表的时候，我们会发现双向链表的定义是这样的：\npublic class BothWayListNode &#123;//存储数据的变量    private int data;//它存储了下一个节点对象引用    private BothWayListNode next;//节点名称    private String nodeName;//上一节点    private BothWayListNode previous;    /**     * 节点构造方法，仅构造出其存储的数据，并不构造下一节点的引用     * @param data 节点数据     */    public BothWayListNode(int data, String nodeName) &#123;        this.data = data;        if (nodeName == null) &#123;            nodeName = &quot;&quot; + data;        &#125;        this.nodeName = nodeName;    &#125;&#125;\n我们可以知道一个节点占用的存储空间有：\n一个int类型的变量 4个字节。\n两个BothWayListNode引用类型的变量 存储地址，字节数不定。\n一个String类型变量，字节数不定。\n我们会发现，有连个BothWayListNode的引用，能不能用某种方法只用一个BothWayListNode的引用就可以完成相应的功能呢？\n这样存储空间不就降下来了吗？\n二.解决方案\n答案是肯定的，当然有那么一种设计思路去简洁的实现双向链表。\n1.节点定义\npackage Exa04.BetterTwoNextList;/** * 这是对普通双向链表的一种存储优化，从原来的两个引用表示上，下节点变为用一个节点表示 * 公式： * ptrdiff = 下一个节点的引用 异或 上一个节点的引用 * 通过这个公式我们可以计算出上一个节点和下一个节点，这样每个节点就可以减少一个存储节点引用的空间 */public class BetterBothWayNode &#123;//存储数据的变量    private int data;//它存储了上，下一个节点对象引用计算变量    private BetterBothWayNode ptrdiff;//节点名称    private String nodeName;    /**     * 节点构造方法，仅构造出其存储的数据，并不构造下一节点的引用     * @param data 节点数据     */    public BetterBothWayNode(int data, String nodeName) &#123;        this.data = data;        if (nodeName == null) &#123;            nodeName = &quot;&quot; + data;        &#125;        this.nodeName = nodeName;    &#125;&#125;\n我们先来个例子来形象的描述这个设计：\n下面有一个链表\n\n其中：\nA的ptrdiff指针地址为：NULL ^ B\nB的ptrdiff指针地址为：A^C\nC的ptrdiff指针地址为：B^D\nD的ptrdiff指针地址为：C^NULL\n从A节点移动到B节点，B=A的ptrdiff^NULL\n从A节点移到C节点：B=A的ptrdiff^NULL, C=B的ptrdiff^A\n从A节点移动到D节点：B=A的ptrdiff^NULL, C=B的ptrdiff^A ，D=B^C节点的ptrdiff\n同理反过来一样的。\n从上面的描述我们可以知道，这样以来，对于这种双向链表的操作实现会出现比较大的特点。\n但是如果真的向上面的定义的话，用Java是无法实现的，因为Java其实不推荐直接对物理内存进行操作的，\n而上面的ptrdiff的计算就是对地址的计算，所以这在Java中是不被允许的！！（不信动手试一试）\n但是我们可以用下面的方式替代它：\n@Datapublic class BetterBothWayNode &#123;//存储数据的变量    private int data;//它存储了上，下一个节点对象索引计算变量    private int ptrdiff;//节点名称    private String nodeName;//当前节点的地址索引    private int npx;    /**     * 节点构造方法，仅构造出其存储的数据，并不构造下一节点的引用     * @param data 节点数据     */    public BetterBothWayNode(int data, String nodeName) &#123;        this.data = data;        if (nodeName == null) &#123;            nodeName = &quot;&quot; + data;        &#125;        this.nodeName = nodeName;    &#125;&#125;\n我们用数组存储这个双向链表的节点，然后我们的这里的ptrdiff可以用节点所在数组位置的下标进行计算！！\n但是这样就是为了计算而计算，明显得不偿失，所以不推荐进行进一步学习，Java语言并不适合这个算法。\n","tags":["算法基础"]},{"title":"5.栈的Java实现","url":"/article/Algorithm-Base-5-%E6%A0%88%E7%9A%84java%E5%AE%9E%E7%8E%B0/","content":"1.什么是栈？\n栈是一个有序的线性表，只能在栈顶进行操作插入和删除操作。所以也叫先进后出表。\n2.栈的应用场景\n\n符号匹配\n中缀表达式转换为后缀表达式\n计算后缀表达式\n实现函数调用\n求范围误差\n网页浏览器中已访问页面的历史纪录\n文本编辑器中的撤销序列\n作为算法辅助数据结构(二叉树的非递归遍历)\n\n3.栈的具体实现\n3.1 基于简单数组的实现\n顾名思义，就是用数组实现栈的应用\n性能表：\n\n\n\n操作\n时间复杂度\n空间复杂度\n\n\n\n\npush()\nO(1)\nO(n)\n\n\npop()\nO(1)\nO(1)\n\n\nsize()\nO(1)\nO(1)\n\n\nisEmpty()\nO(1)\nO(1)\n\n\nisFull()\nO(1)\nO(1)\n\n\ndeleteStack()\nO(1)\nO(1)\n\n\n\n3.2 动态数组的实现\n它其实就是在简单数组基础上实现重复倍增来实现的：\n以上面的简单数组实现为基础，增加一个倍增方法：\n/** * 栈空间扩增方法 */private void doubleStack() &#123;    int[] newArray = new int[capacity*2];    System.arraycopy(array,0,newArray,0,capacity);    capacity = capacity*2;    array = newArray;&#125;\n性能表：\n\n\n\n操作\n时间复杂度\n空间复杂度\n\n\n\n\npush()\nO(1)\nO(n)\n\n\npop()\nO(1)\nO(1)\n\n\nsize()\nO(1)\nO(1)\n\n\nisEmpty()\nO(1)\nO(1)\n\n\nisFull()\nO(1)\nO(1)\n\n\ndeleteStack()\nO(1)\nO(1)\n\n\n\n3.3 链表的实现\n使用链表实现栈，通过在链表的表头插入元素的方式实现push，删除链表的表头节点实现pop.\n但，使用它还需要实现节点的构造，相比数组麻烦些，而且链表不太符合栈的顺序特性，\n且它的性能表如下：\n\n\n\n操作\n时间复杂度\n空间复杂度\n\n\n\n\npush()\nO(1)\nO(n)\n\n\npop()\nO(1)\nO(1)\n\n\nsize()\nO(1)\nO(1)\n\n\nisEmpty()\nO(1)\nO(1)\n\n\nisFull()\nO(1)\nO(1)\n\n\ndeleteStack()\nO(n)\nO(1)\n\n\n\n相比之下它的deleteStack复杂度比动态数组大。所以推荐使用动态数组实现栈。\n3.4 Java动态数组实现栈结构\npackage course.p5_stack;/** * 栈的基础实现 * 栈比较适合使用数组实现,因为使用数组实现栈的push，pop的时间复杂度都为O(1),且操作简单 */public class ArrayStack &#123;    /**     * 存储栈顶元素的索引     */    private int top;    /**     * 栈的空间大小,默认起始为10     */    private int capacity = 10;    /**     * 存储栈元素的数组     */    private int[] array;    /**     * 无参构造方法     */    public ArrayStack() &#123;        array = new int[capacity];        top = -1;    &#125;    /**     * 定义大小构造方法     * @param a 定义栈的大小     */    public ArrayStack(int a) &#123;        capacity = a;        array = new int[a];        top = -1;    &#125;    /**     * 判断此栈是否为空     * @return true--空 false--不空     */    public boolean isEmpty() &#123;        return top == -1;    &#125;    /**     * 判断栈是否已满     * @return     */    public boolean isStackFull() &#123;        return top == capacity-1;    &#125;    /**     * 将数据压入栈中     * @param data     */    public void push(int data) &#123;        if(isStackFull()) &#123;            doubleStack();        &#125;        array[++top] = data;    &#125;    /**     * 弹出栈顶元素     * @return     */    public int pop() &#123;        if(isEmpty()) &#123;            System.out.println(&quot;Stack is Empty!&quot;);            return -1;        &#125;        else&#123;            return array[top--];        &#125;    &#125;    /**     * 删除栈     */    public void deleteStack() &#123;        top = -1;        array = null;        capacity = 0;    &#125;    /**     * 栈空间扩增方法     */    private void doubleStack() &#123;        int[] newArray = new int[capacity*2];        System.arraycopy(array,0,newArray,0,capacity);        capacity = capacity*2;        array = newArray;    &#125;&#125;\n测试方法编写：\npackage course.p5_stack;import org.junit.Assert;import org.junit.Test;import java.util.Optional;import java.util.Random;import java.util.Stack;public class StackTest &#123;    private final Stack&lt;Integer&gt; stackRight = new Stack&lt;&gt;();    @Test    public void stackTest()&#123;        ArrayStack stack = new ArrayStack();        for (int i=0;i&lt;1000;i++)&#123;            boolean active = new Random().nextBoolean();            if(active)&#123;                stack.push(i);                stackRight.push(i);            &#125;else &#123;                Assert.assertEquals(stackRight.isEmpty(),stack.isEmpty());                if(!stackRight.isEmpty())&#123;                    Assert.assertEquals(Optional.ofNullable(stackRight.pop()),Optional.ofNullable(stack.pop()));                &#125;            &#125;        &#125;    &#125;&#125;\n运行结果：(没有任何报错)\nProcess finished with exit code 0\n","tags":["算法基础"]},{"title":"6.队列的Java实现","url":"/article/Algorithm-Base-6-%E9%98%9F%E5%88%97%E7%9A%84java%E5%AE%9E%E7%8E%B0/","content":"1.什么是队列？\n队列和栈不同，它是一个先进先出表，它的特性是先进先出,先被存进的元素先被取出。 \n我们可以使用数组去实现队列，但是对于数组实现而言，队列用链表来实现更为简单。\n2.应用\n\n操作系统的顺序任务调度\n模拟现实世界中的队列\n多道程序设计\n异步数据传输\n作为辅助数据结构(二叉树层次遍历)\n\n3.Java实现\n3.1 基于链表的实现\n/** * 链表实现队列 */public class LinkQueue implements Queue&#123;    //队列头部    Node head;    // 队列尾部    Node tail;    // 队列元素数量    int size;    // 队列容量    int capacity;    static class Node &#123;        int data;        Node next;        Node(int data)&#123;            this.data = data;        &#125;    &#125;    public LinkQueue() &#123;        this.capacity = 16;        this.size = 0;    &#125;    public LinkQueue(int capacity)&#123;        this.capacity = capacity;        this.size = 0;    &#125;    @Override    public boolean isEmpty() &#123;        return size == 0;    &#125;    @Override    public boolean isFull() &#123;        return size == capacity;    &#125;    @Override    public int size() &#123;        return size;    &#125;    @Override    public void offer(int data) &#123;        if(head==null)&#123;            head = new Node(data);            tail = head;            size++;        &#125;        else&#123;            if(isFull())&#123;                System.out.println(&quot;queue is Full!!&quot;);            &#125;else&#123;                tail.next = new Node(data);                tail = tail.next;                size++;            &#125;        &#125;    &#125;    @Override    public int poll() &#123;        int res  = -1;        if(isEmpty()) &#123;            System.out.println(&quot;queue is empty!!&quot;);        &#125;        else&#123;            res = head.data;            head = head.next;            size--;        &#125;        return res;    &#125;&#125;\n性能表：\n\n\n\n操作\n时间复杂度\n空间复杂度\n\n\n\n\noffer()\nO(1)\nO(n)\n\n\npoll()\nO(1)\nO(1)\n\n\nsize()\nO(1)\nO(1)\n\n\nisEmpty()\nO(1)\nO(1)\n\n\nisFull()\nO(1)\nO(1)\n\n\n\n测试方法：\nimport org.junit.Assert;import org.junit.Test;import java.util.ArrayDeque;import java.util.Optional;import java.util.Queue;import java.util.Random;public class QueueTest &#123;    private final Queue&lt;Integer&gt; rightQueue = new ArrayDeque&lt;&gt;();    @Test    public void queueTest()&#123;        LinkQueue queue = new LinkQueue(100);        for (int i=0;i&lt;1000;i++)&#123;            boolean active = new Random().nextBoolean();            if(active)&#123;                rightQueue.offer(i);                queue.offer(i);            &#125;else &#123;                Assert.assertEquals(rightQueue.isEmpty(),queue.isEmpty());                if(!rightQueue.isEmpty())&#123;                    Assert.assertEquals(Optional.ofNullable(rightQueue.poll()),Optional.of(queue.poll()));                &#125;            &#125;        &#125;    &#125;&#125;\n运行结果：(没有任何报错)\nProcess finished with exit code 0\n","tags":["算法基础"]},{"title":"7.0 简单二叉树实现","url":"/article/Algorithm-Base-7-0-%E7%AE%80%E5%8D%95%E6%A0%91%E5%8F%8A%E5%85%B6java%E5%AE%9E%E7%8E%B0/","content":"1.什么是树？\n树是一种类似于链表的数据结构，只不过链表中节点之间的关系是1对1，\n而在树中就变成了一对多的关系，树结构是表达具有层次结构的图的一种方式。\n如下图所示：\n每个节点都会有0/1/2个子节点和一个父节点，只有根节点没有父节点\ngraph TB\n\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n\n1--&gt;2\n1--&gt;3\n2--&gt;4\n2--&gt;5\n3--&gt;6\n3--&gt;null\n对于树这种数据结构的应用，\n元素的顺序并不是考虑的重点，如果我们需要用到元素的顺序信息, 我们大可去使用链表，栈，队列等这些较为简单的数据结构\n那么使用树的关键在于哪里呢？ 接着往下看\n1.1 树结构在计算机的应用\n下面是树的一些重要应用：\n\n编译器中的表达式树\n数据压缩算法的霍夫曼编码树(比较重要)\n支持在集合中查找，插入和删除，其平均时间复杂度为O(logn)的 二叉搜索树 (重要)\n实现优先队列，支持以对数时间对集合中最小或最大数据元素进行搜索和删除的 最大/小堆 (重要)\n\n综上,在性能上，树的关键在于支持大量数据下数据的快速查找，插入和删除（时间复杂度最小化）\n2.学习树的相关术语\n\n根节点：唯一一个没有父母节点的节点(就是最上面的节点root)\n边：它表示父母节点到孩子节点的连接线(就是节点的引用)\n叶子节点：没有孩子节点的节点。(就是最下面的节点)\n兄弟节点：拥有相同的父母节点的节点，他们以兄弟相称\n祖先节点： 隔了1层以上的节点可以统称为祖先节点\n节点的大小：指的是其所有子孙加上自己节点的总个数\n树的层：位于相同深度的节点的集合称为一层，一颗树有多少种这样的层就称这个树有多少层\n节点的深度：从根节点到目标节点的路径长度，自上而下\n节点的高度：从目标节点到最深节点的路径长度，自下而上\n树的高度：树中所有节点中高度的最大值\n树的深度： 树中所有节点中深度的最大值\n斜树：它是特殊的树，除了叶子节点没有孩子节点外，其余每个节点只有一个孩子节点\n\n3.二叉树\n3.1 二叉树的定义\n一颗树中的所有节点的子节点最多为两个的树叫二叉树，空树也是一颗有效的二叉树。\n3.1.1 二叉树的几个类型\n\n严格二叉树：每个节点要么有两个孩子节点，要么一个都没有。\n\ngraph TB\n\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n\n1--&gt;2\n1--&gt;3\n3--&gt;4\n3--&gt;5\n\n满二叉树：每个节点刚好有两个孩子节点且所有叶子节点都在同一层。（结构左右对称）\n\ngraph TB\n\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n8((8))\n\n1--&gt;2\n1--&gt;3\n2--&gt;4\n2--&gt;5\n3--&gt;6\n3--&gt;8\n\n完全二叉树：如果二叉树中除去最后一层节点为满二叉树且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。\n\ngraph TB\n\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n\n1--&gt;2\n1--&gt;3\n2--&gt;4\n2--&gt;5\n3.2.用java实现简单二叉树\n3.2.1 简单二叉树节点的要素\n节点数据data，左孩子引用left，右孩子引用right\n其节点Node结构定义为：\npublic class Node {    //用于存储节点数据    public Integer data;    //左孩子节点引用    public Node left;    //右孩子节点引用    public Node right;    public Node(){    }    public Node(int data){        this.data = data;    }}\n3.2.2 二叉树的基本操作\n\n向树中插入一个元素\n从树中删除一个元素\n遍历树\n查找一个元素\n更新树节点的值\n辅助操作：\n获取树的大小，获取树的高度，获取其和最大的层，对于给定的两个或多个结点，找出它们的最近公共祖先\n\n3.2.2.1 插入操作\n向树中插入一个元素，普通二叉树对插入元素并没有什么限制，所以我们可以选择层次按顺序添加，例如下面的树结构\ngraph TB\n\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n\n1--&gt;2\n1--&gt;3\n2--&gt;4\n2--&gt;5\n我们现在需要上面的树结构插入元素6,则6的位置应该是3的左节点\ngraph TB\n\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n6((6))\n\n1--&gt;2\n1--&gt;3\n2--&gt;4\n2--&gt;5\n3--&gt;6\n3--&gt;null\n代码实现如下：\npublic class NorBinaryTree {    //根节点    private Node root;    //树大小    private int size;    public NorBinaryTree() {        this.root = new Node();    }    /**     * 向树中添加节点(从上到下层次顺序添加)     * @param data 添加的数值     */    public void add(int data) {        if(root.getData()==null){            root.setData(data);            size = 1;        } else {            //通过队列来辅助进行层次遍历            Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();            queue.add(root);            while(!queue.isEmpty()){                boolean isSuccess = false;                for(int i=queue.size();i&gt;0;i--){                    Node node = queue.poll();                    assert node != null;                    if(node.getLeft()!=null) {                        queue.add(node.getLeft());                    }else{                        node.setLeft(new Node(data));                        isSuccess = true;                        break;                    }                    if(node.getRight()!=null) {                        queue.add(node.getRight());                    }else{                        node.setRight(new Node(data));                        isSuccess = true;                        break;                    }                }                if(isSuccess) break;            }            size++;        }    }}\n3.2.2.2 遍历方法定义(必须的)\n有四种：\n\n前序遍历：根左右\n\n/** * 递归版前序遍历(根左右) * @param root 根节点 */private void beforeTraverse(Node root,List&lt;Integer&gt; result) {    if(root!=null) {        System.out.print(root.getData()+\" \");        result.add(root.getData());        beforeTraverse(root.getLeft(),result);        beforeTraverse(root.getRight(),result);    }}\n\n中序遍历：左根右\n\n/** * 递归版中序遍历(左根右) * @param root */private void middleTraverse(Node root,List&lt;Integer&gt; result) {    if(root!=null) {        middleTraverse(root.getLeft(),result);        System.out.print(root.getData()+\" \");        result.add(root.getData());        middleTraverse((root.getRight()),result);    }}\n\n后序遍历：左右根\n\n/** * 递归版后序遍历二叉树（左右根） * @param root */private void afterTraverse(Node root,List&lt;Integer&gt; result) {    if(root!=null) {        afterTraverse(root.getLeft(),result);        afterTraverse((root.getRight()),result);        System.out.print(root.getData()+\" \");        result.add(root.getData());    }}\n\n层次遍历：从上倒下，送左到右\n\n/** * 将层次遍历的结果存入二维数组中(层次遍历用到的辅助数据结构是队列) * @param root * @return */public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) {    Queue&lt;Node&gt; queue= new LinkedList&lt;&gt;();    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    if(root!=null) queue.add(root);    while(!queue.isEmpty()) {        List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();        int size = queue.size();        for(int i=0;i&lt;size;i++) {            Node node = queue.poll();            assert node != null;            temp.add(node.getData());            if(node.getLeft()!=null) queue.add(node.getLeft());            if(node.getRight()!=null) queue.add(node.getRight());        }        result.add(temp);    }    return result;}\n遍历的时间复杂度都为：O(n)  空间复杂度也是：O(n)\n3.2.2.3 删除元素\n这里的二叉树的删除操作仅仅删除节点的值，并非删除节点本身\n/** * 通过前序遍历查找元素 * @param data * @return */private void findOneBeforeTra(int data,Node root,List&lt;Node&gt; result) {    if(root!=null) {        if(root.getData()==data) {            result.add(root);        }        findOneBeforeTra(data,root.getLeft(),result);        findOneBeforeTra(data,root.getRight(),result);    }}\n/** * 树的删除操作,删除第一个和data相等的节点 * @param data 需要删除的值 */public void delete(int data) {    Node father = root;    if(father.getData().equals(data)){        root = null;        return;    }    List&lt;Node&gt; result = new ArrayList&lt;&gt;();    // 递归前序遍历    findOneBeforeTra(data,root,result);    if(result.size() == 0){        System.out.println(\"不存在该元素： \"+data);        return;    }    result.get(0).setData(null);}\n3.2.2.4 更新树节点的值\n/**     * 将直到旧值更新为新值     * @param oldData 旧值     * @param newData 新值     */    public void update(int oldData,int newData) {        Node first = root;        if(first==null)  return ;        //通过栈来辅助进行树的遍历        Stack&lt;Node&gt; S = new Stack&lt;&gt;();        while(true){            while(first!=null){                if(first.getData().equals(oldData)){                    first.setData(newData);                    return;                }                S.push(first);                first = first.getLeft();            }            if(S.isEmpty()) break;            first = S.pop();            first = first.getRight();        }    }\n通过上面的简单二叉树的实现学习，是不是不禁疑惑： 貌似也看不出二叉树相对于链表的优势在哪儿啊？\n增加节点的时间复杂度是O(n),删除节点的时间复杂度也是O(n),修改节点的时间复杂度也是O(n),\n查找也是的，貌似没啥有时啊\n确实，如果我们的实现普通二叉树，树给我们带来的优势很难体现出来，但是，如果我们使用相应的规则来使用树结构，\n我们将看到树的巨大潜力！比如搜索二叉树(BST)\n","tags":["算法基础"]},{"title":"7.1 线索二叉树","url":"/article/Algorithm-Base-7-1-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95-%E6%9B%B4%E4%BC%98/","content":"一.什么是线索二叉树遍历？\n相较于利用辅助结构来实现遍历的方法，它提供一种既不需要栈也不需要队列的更优秀的遍历方法，可以很大程度上节省空间。\n其时间复杂度为：O(n)\n空间复杂度为：O(1)\n二.什么是线索二叉树？\n线索二叉树是在普通二叉树的基础上进行的改进版本，\n只需要在普通二叉树结构中加入存储前驱或后驱节点信息的变量即可。\n1.若只在空左指针中存储前驱信息，称为左线索二叉树。\n2.若只在空右指针中存储后驱信息，称为右线索二叉树。\n3.若在空左指针中存储前驱信息，在空右指针中存储后驱信息，称为线索二叉树。\n它的类型可以分为三类：\n1.前序线索二叉树：空左指针中存储前序序列前驱信息，在空右指针中存储前序序列后驱信息。\n2.中序线索二叉树：空左指针中存储中序序列前驱信息，在空右指针中存储中序序列后驱信息。\n3.后序线索二叉树：空左指针中存储后序序列前驱信息，在空右指针中存储后序序列后驱信息。\n下面以中序为例：\n节点定义：\n在普通节点上加了两个附加字段：\n\n@Data\nclass BinaryTreeNode{\nprivate int data;\nprivate int LTag;//用于存储前驱信息\nprivate int RTag;//用于存储后驱信息\nprivate BinaryTreeNode left;\nprivate BinaryTreeNode right;\n}\n加了这两个字段之后，二叉树和线索二叉树的区别有：\n\n","tags":["算法基础"]},{"title":"7.2 BST二叉搜索树实现","url":"/article/Algorithm-Base-7-2-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88BST%EF%BC%89%E7%9A%84java%E5%AE%9E%E7%8E%B0/","content":"1 搜索二叉树（BST）\n1.1 搜索二叉树的定义\n简单来说，它是一个加了限定条件的二叉树，\n它可以使最坏情况下的平均搜索的时间复杂度降低到O(log n). \n其中的限定条件是：\n\n一个节点的左子树只能包含值小于该节点的值的节点\n一个节点的右子树只能包含值大于该节点的值的节点\n左右子树也都必须是二叉搜索树\n\n比如我们想向一颗空树中添加下面元素：3,2,1,4,5\n最后我们得到的树结构应该如下：\ngraph TB\n\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n\n3--&gt;2\n2--&gt;1\n2--&gt;null1\n3--&gt;4\n4--&gt;null2\n4--&gt;5\n通过限制节点存储值的方式，使得这样的二叉树的搜索效率极高(二分查找),这样的结构查找很快，\n但是在试图修改树结构的时候我们也要维护树结构。\n在上面的树中删除元素4,我们则需要调整树结构为：\ngraph TB\n\n1((1))\n2((2))\n3((3))\n5((5))\n\n3--&gt;2\n2--&gt;1\n2--&gt;null1\n3--&gt;5\n但是真实的情况远比上面的复杂，我们可以分情况来进行讨论：\n\n情况1：如果待删除的元素为叶子节点，这个很简单，直接将其父节点的左/右指向null即可\n\ngraph TB\n\n1((1))\n2((2))\n3((3))\n5((5))\n2.5((2.5))\n\n3--&gt;2\n2--&gt;1\n2--&gt;2.5\n3--&gt;5\n现在需要删除上面树中的2.5这个元素，很简单，我们只需要将2的右孩子节点置空\ngraph TB\n\n1((1))\n2((2))\n3((3))\n5((5))\n\n3--&gt;2\n2--&gt;1\n2--&gt;null\n3--&gt;5\n\n情况2：如果待删除节点有一个孩子节点，这种情况下，只需要将其待删除节点和孩子节点设置为其父亲节点的左/右节点即可\n例如我们要删除下面的树结构中的元素4\n\ngraph TB\n\n1((1))\n2((2))\n3((3))\n4((4))\n5((5))\n\n3--&gt;2\n2--&gt;1\n2--&gt;null1\n3--&gt;4\n4--&gt;null2\n4--&gt;5\n我们则可以直接将5设置为3的右孩子\ngraph TB\n\n1((1))\n2((2))\n3((3))\n5((5))\n\n3--&gt;2\n2--&gt;1\n2--&gt;null\n3--&gt;5\n\n情况3：如果待删除节点有两个孩子节点，\n通常的做法是从其左子树中找到最大的元素替代它， 然后删除左子树的那个最大的元素.\n\ngraph TB\n\n1((1))\n2((2))\n3((3))\n5((5))\n7((7))\n10((10))\n8((8))\n6((6))\n\n3--&gt;2\n2--&gt;1\n2--&gt;null1\n3--&gt;8\n8--&gt;5\n8--&gt;10\n5--&gt;null2\n5--&gt;7\n7--&gt;6\n7--&gt;null3\n现在需要删除元素8，我们可以先将7替换掉8得到：\ngraph TB\n\n1((1))\n2((2))\n3((3))\n5((5))\n7((7))\n10((10))\n8((7))\n6((6))\n\n3--&gt;2\n2--&gt;1\n2--&gt;null1\n3--&gt;8\n8--&gt;5\n8--&gt;10\n5--&gt;null2\n5--&gt;7\n7--&gt;6\n7--&gt;null3\n然后删除5的右节点7，可以知道删除5的右节点7属于情况2，我们直接将5的右节点设置为6即可：\ngraph TB\n\n1((1))\n2((2))\n3((3))\n5((5))\n10((10))\n8((7))\n6((6))\n\n3--&gt;2\n2--&gt;1\n2--&gt;null1\n3--&gt;8\n8--&gt;5\n8--&gt;10\n5--&gt;null2\n5--&gt;6\n这样就完成了BST的删除操作。\n1.2 Java实现二叉搜索树\n1.2.1 二叉搜索树节点的要素\n节点数据data，左孩子节点引用left，右孩子节点引用right\n其节点数据结构为：\npublic class Node {    //用于存储节点数据    public Integer data;    //左孩子节点引用    public Node left;    //右孩子节点引用    public Node right;    public Node(){    }    public Node(int data){        this.data = data;    }}\n1.2.2 二叉搜索树插入操作实现\nclass BSTree{    /**     *  插入元素     *  基本思想是顺着树往下走，根据规则将其插入合适的位置，     *  找个图，对着这个过程走一遍即可理解, 此树很明显不能存储相同值的节点     * @param root 根节点     * @param data     * @return     */    Node insert(Node root ,int data) {        // 这一步很简单，就是root为空去情况        if(root == null) {            root = new Node();            root.setData(data);        } else {            if(data &lt; root.getData()){                root.setLeft(insert(root.getLeft(),data));            } else if(data &gt; root.getData()) {                root.setRight(insert(root.getRight(),data));            }        }        return root;    }}\n1.2.3 二叉搜索树删除操作实现\n注意： 删除操作可能会修改二叉树的整体结构\nclass BSTree {    /**     * 基本思想是先找到目标节点，     * 若此节点的左右孩子都不为空     * 找到其左子树的最大值，将其设置为目标节点数据     * 后面的递归进行删除原来的那个左子树的最大值操作,     * 二叉搜索树的删除操作需要修改树的结构     * 若有一个孩子为空则只需将其设置为孩子节点即可     * @param root     * @param data     * @return     */    Node delete(Node root,int data) {        Node temp;        Node find = find(root,data);        if(find==null) {            System.out.println(\"没有该元素\");        }        else {            Node father = root;            Node son = root;            //找到待删除节点            while (son != null) {                if (data == son.getData())                    break;                else if (data &gt; son.getData()) {                    father = son;                    son = son.getRight();                } else {                    father = son;                    son = son.getLeft();                }            }            // oldSon为待删除节点            Node oldSon = son;            //情况3            if(son.getLeft()!=null &amp;&amp; son.getRight()!=null) {                temp = findMax(son.getLeft());                son.setData(temp.getData());                son.setLeft(delete(son.getLeft(), son.getData()));            }            // 情况1,2            else {                //情况2                if(son.getLeft()==null)                    son = son.getRight();                else if(son.getRight()==null)                    son = son.getLeft();                    // 情况1                else son = null;                if(father.getRight()==oldSon){                    father.setRight(son);                }                else if(father.getLeft()==oldSon){                    father.setLeft(son);                }            }        }        return root;    }}\n1.2.4 二叉搜索树的查找操作\n注意： 由于二叉搜索树的存储性质，二叉搜索树的查找操作效率很高，相当于二分查找\nclass BSTree{    /**     * 返回目标节点     * @param root 二叉树根节点     * @param data 要寻找的数据     * @return 值等于data的节点     */    Node find(Node root,int data) {        if(root==null) return null;        while (root!=null) {            if(data==root.getData())                return root;            else if(data&gt;root.getData())                root = root.getRight();            else root = root.getLeft();        }        return null;    }}\n1.2.5 获得树的极值\n由于二叉搜索树是顺序存储的，所以，我们可以通过方法获取到树的最大值,最小值,\nclass BSTree{    /**     * 寻找树中最小元素     * 基本思想是此树的最小元素一定在最左边     * @param root     * @return     */    Node findMin(Node root) {        if(root==null) return null;        while(root.getLeft()!=null)            root = root.getLeft();        return root;    }    /**     * 寻找树中最大元素     * 基本思想是此树的最大元素一定在最右边     * @param root     * @return     */    Node findMax(Node root) {        if(root==null) return null;        while(root.getRight()!=null)            root = root.getRight();        return root;    }}\n1.2.6 按大小顺序打印元素\n由于二叉搜索树的存储特性, 我们可以用中序遍历获取元素顺序\n/** * 树的中序遍历(左根右) * 中序遍历出来的数据是有顺序的 * @param root 根节点 */public void middleTraverse(Node root) {    if(root!=null) {        middleTraverse(root.getLeft());        System.out.print(root.getData()+\" \");        middleTraverse((root.getRight()));    }}\n","tags":["算法基础"]},{"title":"7.3 平衡二叉树AVL","url":"/article/Algorithm-Base-7-3-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%8A%E5%85%B6java%E5%AE%9E%E7%8E%B0/","content":"1. 平衡二叉搜索树\n1.1 什么是平衡二叉搜索树？\nAVL树是在二叉搜索树的基础上满足如下条件之一的树：\n\n\n每个左右子树的高度差为0，此时的二叉树称为完全平衡二叉搜索树。\n\n\n每个左右子树的高度差不大于1时，此时的二叉树称为AVL树。（就是平衡二叉搜索树）\n\n\n1.2 旋转\n当树的结构发生变化时（插入，删除节点），它可能变得不符合AVL结构了，\n所以我们需要一个操作来保证树维持AVL结构。  这个操作就是旋转\n旋转的中心思想是：将从插入点到根节点路径上第一个不满足AVL性质的节点修复。\n以插入为例，存在四种情况的插入：\n1.2.1 情况1：在节点的左孩子的左子树插入元素\n例如：我们在9的左孩子的左子树插入7\ngraph TB\n\n6((6))\n5((5))\n9((9))\n3((3))\n8((8))\n7((7))\n\n6--&gt;5\n6--&gt;9\n5--&gt;3\n5--&gt;null1\n9--&gt;8\n9--&gt;null2\n8--&gt;7\n8--&gt;null3\n显然，这个结构并不符合AVL的特性：每个左右子树的高度差不大于1  9的左子树和右子树的高度差为2 \n我们的解决方案是：\n首先将9变成8的右子树 ,\n然后将8的位置移到9的位置（我个人理解为7,8,9 整体向右旋转）\n结果为：\ngraph TB\n\n6((6))\n5((5))\n9((9))\n3((3))\n8((8))\n7((7))\n\n6--&gt;5\n6--&gt;8\n5--&gt;3\n5--&gt;null1\n8--&gt;7\n8--&gt;9\n这个操作我称之为右旋\n1.2.2 情况2.在节点的右孩子的右子树插入元素\n例如：我们在12的右子树插入20\ngraph TB\n\n8((8))\n6((6))\n10((10))\n3((3))\n12((12))\n20((20))\n\n8--&gt;6\n8--&gt;10\n6--&gt;3\n6--&gt;null1\n10--&gt;null2\n10--&gt;12\n12--&gt;null3\n12--&gt;20\n我们的解决方案是：\n首先将10变成12的左子树,\n然后将12的位置移到10的位置（我个人理解为10,12,20整体向左旋转）\n结果为：\ngraph TB\n\n8((8))\n6((6))\n10((10))\n3((3))\n12((12))\n20((20))\n\n8--&gt;6\n8--&gt;12\n6--&gt;3\n6--&gt;null1\n12--&gt;10\n12--&gt;20\n1.2.3 情况3 在节点的左孩子的右子树插入元素\n例如：在9节点的左孩子节点的右孩子添加8\ngraph TB\n\n6((6))\n5((5))\n9((9))\n3((3))\n7((7))\n8((8))\n\n6--&gt;5\n6--&gt;9\n5--&gt;3\n5--&gt;null1\n9--&gt;7\n9--&gt;null2\n7--&gt;null3\n7--&gt; 8\n其解决策略是：\n首先以下一个节点为目标节点向左旋转，然后整体向右旋转\ngraph TB\n\n6((6))\n5((5))\n9((9))\n3((3))\n7((7))\n8((8))\n\n6--&gt;5\n6--&gt;9\n5--&gt;3\n5--&gt;null1\n9--&gt;8\n9--&gt;null2\n8--&gt; 7\n8--&gt;null3\ngraph TB\n\n6((6))\n5((5))\n9((9))\n3((3))\n7((7))\n8((8))\n\n6--&gt;5\n6--&gt;8\n5--&gt;3\n5--&gt;null1\n8--&gt; 7\n8--&gt; 9\n1.2.4 情况4 在节点的右孩子的左子树插入元素\n例如：在9节点的右孩子节点的左孩子添加8\ngraph TB\n\n6((6))\n5((5))\n9((9))\n3((3))\n10((10))\n9.5((9.5))\n\n6--&gt;5\n6--&gt;9\n5--&gt;3\n5--&gt;null1\n9--&gt;null2\n9--&gt;10\n10--&gt; 9.5\n10--&gt; null3\n其解决策略是：以下一个节点为目标节点向右旋转，然后整体向左旋转\ngraph TB\n\n6((6))\n5((5))\n9((9))\n3((3))\n10((10))\n9.5((9.5))\n\n6--&gt;5\n6--&gt;9\n5--&gt;3\n5--&gt;null1\n9--&gt;null2\n9--&gt;9.5\n9.5--&gt; null3\n9.5--&gt; 10\ngraph TB\n\n6((6))\n5((5))\n9((9))\n3((3))\n10((10))\n9.5((9.5))\n\n6--&gt;5\n6--&gt;9.5\n5--&gt;3\n5--&gt;null1\n9.5--&gt;9\n9.5--&gt; 10\n1.3 AVL java实现\n1.3.1 节点定义\n相比于BST, AVL的定义多了个height，它用来记载树高，\n决定是否维护的二叉树结构的依据就是它\npublic class Node {    //用于存储节点数据    public Integer data;    //左孩子节点引用    public Node left;    //右孩子节点引用    public Node right;    /**     * 树的高度,平衡二叉搜索树属性     */    private int height ;    public Node(){    }    public Node(int data){        this.data = data;    }}\n1.3.2 操作方法定义\n1.3.2.1 旋转操作\n\n右旋\n\n/** * 在节点的左孩子的左子树插入 * 右旋操作,操作步骤是： * 首先得到root的左孩子left * 然后将root的左孩子设置left的右孩子 * 然后将left的右孩子设置为root * @param root * @return */Node SingleRotataLeft(Node root) {    // 得到root的左节点    Node left = root.getLeft();    // 将root的左子树设置为left的右子树    root.setLeft(left.getRight());    // 将left的右节点设为root    left.setRight(root);    // 维护root和left的高度    root.setHeight(Math.max(Height(root.getLeft()),Height(root.getRight()))+1);    left.setHeight(Math.max(Height(left.getLeft()),Height(left.getRight()))+1);    return left;}\n\n左旋\n\n/** * 在右孩子的右子树插入元素 * 左旋操作,操作步骤是： * 首先得到root的右孩子right * 然后将root的右孩子设置为right的左孩子 * 最后将right的左孩子设置为root * @param root * @return */Node SingleRotataRight(Node root) {    Node right = root.getRight();    root.setRight(right.getLeft());    right.setLeft(root);    root.setHeight(Math.max(Height(root.getRight()),Height(root.getLeft()))+1);    right.setHeight(Math.max(Height(right.getRight()),Height(right.getLeft()))+1);    return right;}\n\n左右双旋\n\n/** * 在左孩子的右子树插入元素 * 先将左孩子节点整体向左旋转，然后将root整体向右旋转 * @param root * @return */Node DoubleRotatewithLeft(Node root) {    root.setLeft(SingleRotataRight(root.getLeft()));    return SingleRotataLeft(root);}\n\n右左双旋\n\n/** * 在右孩子的左子树插入元素 * 先将左孩子节点整体向右旋转，然后将root整体向左旋转 * @param root * @return */Node DoubleRotatewithRight(Node root) {    root.setRight(SingleRotataLeft(root.getRight()));    return SingleRotataRight(root);}\n1.3.2.2 插入操作\nAVL的插入操作中需要维护树的结构\n/** * 平衡二叉搜索树的插入操作 * @param root 根节点 * @param data 插入的数据 * @return */Node insert(Node root,int data) {    // root为叶子节点时，直接插入    if(root == null) {        root = new Node();        root.setData(data);        root.setHeight(0);        root.setLeft(null);        root.setRight(null);    }    // 向左子树插入    else if(data &lt; root.getData()) {        root.setLeft(insert(root.getLeft(),data));        // 检查左右子树树高进行修正        if(Height(root.getLeft())-Height(root.getRight())&gt;1) {            // 左左插入,进行右旋操作            if(data &lt; root.getLeft().getData())                root = SingleRotataLeft(root);            // 左右插入, 进行双旋操作            else                root = DoubleRotatewithLeft(root);        }    }    // 向右子树插入    else if(data &gt; root.getData()) {        root.setRight(insert(root.getRight(),data));        // 检查左右子树树高进行修正        if(Height(root.getRight())-Height(root.getLeft())&gt;1){            // 右右插入，进行左旋            if(data &gt; root.getRight().getData())                root = SingleRotataRight(root);            // 右左插入，双旋操作            else                root = DoubleRotatewithRight(root);        }    }    root.setHeight(Math.max(Height(root.getLeft()),Height(root.getRight()))+1);    return root;}\n测试代码：\npublic class AVLTreeTest {    @Test    public void insertTest(){        AVLTree one = new AVLTree();        Node node = new Node(6);        one.insert(node,5);        System.out.println(node.getHeight());        one.insert(node,9);        one.insert(node,7);        System.out.println(node.getHeight());        one.insert(node,8);        one.insert(node,3);        one.insert(node,2);        System.out.println(node.getHeight());        one.Check3(node);        System.out.println();        List&lt;List&lt;Integer&gt;&gt; result = one.levelOrder(node);        for(List&lt;Integer&gt; item:result){            System.out.println(item);        }    }}\n结果：\n1222 3 5 6 7 8 9 [6][3, 8][2, 5, 7, 9]Process finished with exit code 0\n","tags":["算法基础"]},{"title":"7.4 红黑树","url":"/article/Algorithm-Base-7-4-%E7%BA%A2%E9%BB%91%E6%A0%91/","content":"1. 红黑树\n1.1 何为红黑树？\n红黑树是许多平衡(AVL)搜索树中的一种，它可以保证在最坏情况下基本动态集合的操作时间复杂度为O(logn)，\n这相对于其他树非常高效。\n但既然它能被分支出来作为一颗单独的树学习，就一定有其特别之处。\n一颗红黑树的基本特征如下：\n1.1.1 节点属性 (节点定义)\n\ncolor(标注此节点的颜色),\nkey(存储此节点的信息),\nleft(存储其左孩子引用),\nright(存储右孩子引用),\np(存储父节点引用)\n\n1.1.2 节点间的连接规则：（红黑树的性质）\n\n每个节点的color非黑即红\n根节点一定为黑色\n每个叶子节点一定为黑色\n若一个节点为红色,则其孩子节点一定为黑色，若一个节点为黑色, 则其孩子节点红黑都可\n对于每个节点，从该节点到其所有叶子节点的简单路径上一定包含相同数目的黑色节点\n\n一颗典型的红黑树如下图所示：\n其中null叶子节点不画出,都为黑色\ngraph TB\n11((11))\n2((2))\n14((14))\n1((1))\n7((7))\n5((5))\n8((8))\n15((15))\n13((13))\n\n11--&gt;2\n11--&gt;14\n2--&gt;1\n2--&gt;7\n7--&gt;5\n7--&gt;8\n14--&gt;13\n14--&gt;15\n\nstyle 2 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 5 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 8 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 15 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 13 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\n由于它的性质我们需要知道：\n黑高：从每个节点x出发（不含该节点）到达一个叶节点的任意一条简单路径上的黑色节点的个数称为该节点的黑高\n1.2 为什么红黑树可以作为一种优秀的搜索树被使用？\n我们知道一颗树的高度很大程度决定了一些操作的时间复杂度。\n高度越大，其平均时间复杂度越大，效率越低。\n而在红黑树中，由于其构造的特殊性，一颗有n个内部节点的红黑树的高度最大为2log(n+1)\n因此动态集合的一系列操作均可在红黑树上O(lgn)时间内执行。\n1.3 红黑树是如何实现一系列的操作的？\n1.3.1 红黑树的插入操作\n毋庸置疑，对于红黑树普通的插入操作会打乱其性质，所以我们需要采取一定的措施还原它的性质。\n但在此之前我们需要搞清楚：\n如果我们需要向一颗红黑树插入一个元素的话我们一定会想到：插入后的节点颜色是设置为红色还是黑色呢？\n如果设置为黑色，则一定会违反： 对于每个节点，从该节点到其所有后代节点的简单路径上一定包含相同数目的黑色节点\n如果设置为红色，则可能违反：若一个节点为红色则其孩子节点一定为黑色 \n所以相比之下，选择红色会更合理一点。\n下面我们以一个例子正式开始分析红黑树的插入操作：\ngraph TB\n\n11((11))\n2((2))\n14((14))\n1((1))\n7((7))\n5((5))\n8((8))\n15((15))\n13((13))\n\n11--&gt;2\n11--&gt;14\n2--&gt;1\n2--&gt;7\n7--&gt;5\n7--&gt;8\n14--&gt;13\n14--&gt;15\n\nstyle 2 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 5 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 8 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 15 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 13 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\n现在我们向树中插入元素4这个节点\ngraph TB\n\n11((11))\n2((2))\n14((14))\n1((1))\n7((7))\n5((5))\n8((8))\n15((15))\n13((13))\n4((4))\n\n11--&gt;2\n11--&gt;14\n2--&gt;1\n2--&gt;7\n7--&gt;5\n7--&gt;8\n14--&gt;13\n14--&gt;15\n5--&gt;4\n5--&gt;null\n\nstyle 2 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 5 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 8 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 15 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 13 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 4 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\n如上图所示，此树现在变为了一颗不合理的红黑树，节点5颜色为红色，其子节点为黑色才是合理的。\n我们将插入的节点定义为z,在上面的树中,4这个节点就是z\n所以，我们必须寻找一个普遍策略用于应对所有的插入操作\n常用的策略大致分为2个操作：\n\n变换颜色\n旋转调节\n于是现在我们要学习如何变换颜色，如何旋转调节？\n\n\n这个需要分情况讨论：\n\n\n情况1：如果z的叔叔节点是红色的\nz的父节点，叔叔节点，祖父节都变色\n然后把z.p.p作为新节点进行检测\n\n\n情况2：z的叔叔节点是黑色的且z是一个右孩子\nz=z.p;\nz向左旋转\n\n\n情况3：z的叔叔节点是黑色的且z是一个左孩子\nz.p.color=black;\nz.p.p.color=red;\nz.p.p向右旋转\n\n\n流程图如下：\n现在上面这个红黑树中,z节点的情况满足情况1，我们需要将其父节点5，叔叔节点8，祖父节点7都进行变色得到下面红黑树：\n\n\ngraph TB\n\n11((11))\n2((2))\n14((14))\n1((1))\n7((7))\n5((5))\n8((8))\n15((15))\n13((13))\n4((4))\n\n11--&gt;2\n11--&gt;14\n2--&gt;1\n2--&gt;7\n7--&gt;5\n7--&gt;8\n14--&gt;13\n14--&gt;15\n5--&gt;4\n5--&gt;null\n\nstyle 2 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 7 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 15 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 13 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 4 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\n现在上面的红黑树节点z.p.p = 7 不满足特性：红节点的子节点为黑色 z=7\n所以接着进行维护，发现它满足了情况1,但是不满足情况2,所以需要按照情况2进行修复\n将2这个子树进行向左旋转，得到\ngraph TB\n\n11((11))\n2((2))\n14((14))\n1((1))\n7((7))\n5((5))\n8((8))\n15((15))\n13((13))\n4((4))\n\n11--&gt;7\n11--&gt;14\n2--&gt;1\n2--&gt;5\n7--&gt;2\n7--&gt;8\n14--&gt;13\n14--&gt;15\n5--&gt;4\n5--&gt;null\n\nstyle 2 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 7 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 15 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 13 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 4 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\n现在发现节点z.p=2不符合红黑树特性，所以2为z进行继续修复z=2，\n发现它满足情况3,所以进行情况3的处理得到下面：\ngraph TB\n\n11((11))\n2((2))\n14((14))\n1((1))\n7((7))\n5((5))\n8((8))\n15((15))\n13((13))\n4((4))\n\n7--&gt;2\n7--&gt;11\n2--&gt;1\n2--&gt;5\n11--&gt;8\n11--&gt;14\n14--&gt;13\n14--&gt;15\n5--&gt;4\n5--&gt;null\n\nstyle 2 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 11 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 15 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 13 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\nstyle 4 fill: #FF0000, stroke: #FF0000, stroke-width: 4px;\n通过上面的调节我们可以在插入操作后还原了红黑树的正常特性。\n1.3.2 红黑树的删除操作\n与n个节点的红黑树上的其他操作一样，删除一个节点要花费O(lgn)时间，但与插入操作相比，删除操作要稍微复杂一点。\n它分为两个情况：\n\n如果被删除节点是红色的，红黑性质将继续保持，\n如果被删除节点是黑色的话，就有可能发生一个或多个红黑性质被破坏的情况。\n\n其核心在于，进行删除操作后的红黑树如果不符合其性质，我们如何进行调节。\n调节过程有四种情况:\n\n\n情况1：x的兄弟节点w是红色的\n\n\n情况2：x的兄弟节点w是黑色且w的两个孩子都为黑色\n\n\n情况3：x的兄弟节点w是黑色且w的左孩子为红色，右孩子是黑色\n\n\n情况4：x的兄弟节点w是黑色且w的右孩子是红色的\n\n\n","tags":["算法基础"]},{"title":"1.Java编程语言入门","url":"/article/JavaPrograming-JavaBase-1-Java%E5%B0%8F%E7%99%BD%E5%85%A5%E9%97%A8/","content":"牧之Java学习日记\n之前其实已经稍微学了一点点java。\n那么作为自己的第一篇博客，我希望还是从头开始，用博客记录自己的java学习历程，通过写博客来记录一些在学习过程中遇到的问题与积累，希望在以后回头能在这里看看自己的一些东西，想起自己曾经的努力和理想。\n1.安装java环境\n一般按照网上的教程安装很简单\n百度经验新手搭建Java开发环境\n2.了解java原理\n按照我的理解，java的工作原理其实是将我们写的代码先编译一遍形成一个class文件，然后通过安装在各种机器上的虚拟机进行运行，从而消除了平台差别性。\n过程如下：\n\n已经是老手了？进阶一下\n我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，\n然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。\n而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，\n所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。\n当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。\n而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言 。\n\nHotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，\n消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。\nJVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。\nJDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，\n这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。\n\n为什么不全部使用AOT呢? 那样的话执行效率不是很好吗？\nAOT 可以提前编译节省启动时间，那为什么不全部使用这种编译方式呢？\n长话短说，这和 Java 语言的动态特性有千丝万缕的联系了。举个例子，CGLIB 动态代理使用的是 ASM 技术，\n而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 .class 文件，\n如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。\n3.第一个java程序\n首先，我在D目录的一个叫JAVA程序设计里的day01文件夹里建立了一个HelloWorld.java文件，\n然后在cmd里输入d:回车，然后输入cd D:\\JAVA程序设计\\day01来到day01文件夹。\n然后输入javac  HelloWorld.java（使用java编译器将java文件编程成class字节码文件）。\n之后用java虚拟机运行，输入java HelloWorld（使用java虚拟机运行class字节码文件）。得到答案\n大概就是这么个过程。这只是用记事本来开发的，真正的开发一般用各大厂商发布的官方集成开发工具，\n它能将上述过程自动完成，所以我们只需要写代码就可以了。\n4.JDK和JRE\nJDK是java开发工具包，它是编写java程序的程序员使用的软件，它包含了JRE。\nJRE是允许java程序的用户使用的软件,是java运行环境，它包含JVM。\n5.在进行下一步学习之前，我们可以了解下java关键特性\n\n简单性（java简单易学（相对于C++））\n面向对象（Java的面向对象特性与C++旗鼓相当甚至更胜一筹,封装,继承,多态）\n平台无关性(JVM实现了操作系统平台无关性)\n分布式，健壮性，安全性，体系结构中立，可移植性，解释型，高性能，多线程，动态性\n支持网络编程并且很方便\n\n6.学习最简单的java程序\npublic class FirstSample&#123;  public static void main(String[] args)&#123;    System.out.println(&quot;Hello World&quot;); &#125;&#125;\n通过编写上面的代码我们能学到什么？\n\nJava区分大小写\nJava中的主方法写法\nJava中的输出打印语句写法\n\n7.可能遇到的问题\n当我们得到了上面的运行结果的时候，我们就已经具备一个完备的学习Java的环境了。\n对于初学者来说，想要获得上面的运行结果可能并不简单，下面是可能出现的问题：\n1.如何安装Jdk： 安装Jdk的步骤很简单，首先下载Jdk的安装包，Java Platform, Standard Edition 8 Reference Implementations  。 下载完成后，进行傻瓜式安装，然后需要配置环境变量，就是将jdk中的一些java组件的执行命令导入到全局系统变量中，让我们在cmd命令行下能使用jdk。\n2.如何安装IDEA,这个我们直接去IDEA官网下载社区版的就好了。Download IntelliJ IDEA: The Capable &amp; Ergonomic Java IDE by JetBrains\n下载完成后进行傻瓜式安装就好了。\n3.如何在IDEA中创建一个项目并运行，这个自行百度即可。例如IntelliJ IDEA 如何创建一个 Java 项目_小小张自由—&gt;张有博的博客-CSDN博客_idea怎么创建java项目\n","tags":["Java基础"]},{"title":"1.JDBC基础","url":"/article/ORMFramework-JDBC-1-JDBC%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/","content":"1.什么是JDBC?\nJDBC可以说是一种标准，它是Java和数据库的桥梁，各大数据库软件厂商通过实现JDBC的标准，并提供相应的驱动包，让Java语言能够很容易的操作各个数据库，对数据库进行读写操作。\n2.JDBC编程步骤\n简单来说就是：\n加载驱动程序-&gt;建立连接-&gt;操作数据-&gt;释放资源\n具体而言：\n* 加载驱动程序：通过DriverManager加载驱动程序driver；\n* 建立连接：通过DriverManager类获得表示数据库连接的Connection类对象；\n* 操作数据：通过Connection对象绑定要执行的语句，生成Statement类对象；\n通过Statement执行SQL语句，接收执行结果集ResultSet；\n可选的对结果集ResultSet类对象的处理；\n* 释放资源：必要的关闭ResultSet、Statement和Connection ，实现资源回收。\n2.1 如何加载驱动程序\n想要加载驱动程序，首先得引入对应数据的驱动包:\n普通Java项目得先下载对应数据库版本的jar包，然后放到Libraries中即可。\n\nmaven项目直接在项目的pom文件中添加类似如下配置即可：\n\n\nmysql\nmysql-connector-java\n8.0.12\n\n\n然后执行：\n//加载驱动程序\nClass.forName(“com.mysql.cj.jdbc.Driver”);\n即可，实际上除了这种方式，还有一种加载驱动的方式：\nDriverManager.registerDriver(new Driver());\n但是这种方式并不常用，原因如下：\n原因有两个：\n* 查看Driver的源代码可以看到，如果采用此种方式，会导致驱动程序注册两次，也就是在内存中会有两个Driver对象。\n* 程序依赖mysql的api，脱离mysql的jar包，程序将无法编译，将来程序切换底层数据库将会非常麻烦。\n所以，最佳的加载驱动的方式如下：\n//加载驱动程序\nClass.forName(“com.mysql.cj.jdbc.Driver”);\n2.1.1 示例\nimport com.mysql.cj.jdbc.Driver;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\npublic class loadDriverManager {\npublic static void main(String[] args) throws ClassNotFoundException, SQLException {\n//推荐这种方式\ntry{\nClass.forName(“com.mysql.cj.jdbc.Driver”);\nSystem.out.println(“成功mysql加载驱动！！”);\n}catch (Exception e){\ne.printStackTrace();\n}\ntry{\n//这种方式依赖了驱动jar包\nDriverManager.registerDriver(new Driver());\nSystem.out.println(“成功mysql加载驱动！！”);\n}catch (Exception e){\ne.printStackTrace();\n}\n}\n}\n\n2.2 如何与数据库建立连接\n当我们在程序中加载完驱动后，我们便可以如下编程获取连接对象：\nString url=“jdbc:mysql://localhost:3306/world?&amp;useSSL=false&amp;serverTimezone=UTC”;\nString username=“root”;\nString password=“root”;\nConnection conn = DriverManager.getConnection(url,username,password);\n2.2.1 编程实例\nimport java.sql.Connection;\nimport java.sql.DriverManager;\npublic class CreateConnector {\npublic static void main(String[] args) {\n//驱动加载\ntry{\nClass.forName(“com.mysql.cj.jdbc.Driver”);\nSystem.out.println(“成功mysql加载驱动！！”);\n}catch (Exception e){\ne.printStackTrace();\n}\n//和数据库建立连接\nString url=“jdbc:mysql://localhost:3306/world?&amp;useSSL=false&amp;serverTimezone=UTC”;\nString username=“root”;\nString password=“root”;\ntry {\nConnection conn = DriverManager.getConnection(url,username,password);\nSystem.out.println(“成功获取数据库连接！！”);\n}catch (Exception e){\ne.printStackTrace();\n}\n}\n}\n\n获得连接对象Connection后，我们便可以通过它来创建数据库操作对象。\n2.3 如何操作数据库\n获取完连接对象后，我们就可以从连接对象中获得操作对象对数据库进行操作\n步骤如下：\n//通过Connection获取Statement对象\nStatement stmt=conn.createStatement();\n//定义要执行的sql语句\nString sql = “select * from city”;\n//执行sql\nstmt.executeQuery(sql);\n然后我们可以通过Statement对象来执行指定的SQL语句。\n这一步可以随着需求的不同，我们可以采用不同的编程方式来满足业务需求。\n2.3.1 Statement中需要熟悉的方法\nJdbc程序中的Statement对象用于向数据库发送SQL语句， Statement对象常用方法：\nexecuteQuery(String sql) ：用于向数据发送查询语句。select语句，返回值ResultSet结果集。\nexecuteUpdate(String sql)：用于向数据库发送insert、update或delete语句。返回值为int：受影响行数。\nexecute(String sql)：用于向数据库发送任意sql语句，返回值为boolean：如果第一个结果为 ResultSet 对象，则返回 true；如果其为更新计数或者不存在任何结果，则返回 false 。\n批处理：\naddBatch(String sql) ：把多条sql语句放到一个批处理中。\nexecuteBatch()：向数据库发送一批sql语句执行。\n2.3.1.1 编程示例\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.Statement;\npublic class CreateStatement {\npublic static void main(String[] args) {\n//驱动加载\ntry{\nClass.forName(“com.mysql.cj.jdbc.Driver”);\nSystem.out.println(“成功mysql加载驱动！！”);\n}catch (Exception e){\ne.printStackTrace();\n}\n//和数据库建立连接\nString url=“jdbc:mysql://localhost:3306/world?&amp;useSSL=false&amp;serverTimezone=UTC”;\nString username=“root”;\nString password=“root”;\ntry {\nConnection conn = DriverManager.getConnection(url,username,password);\nSystem.out.println(“成功获取数据库连接！！”);\nStatement stmt = conn.createStatement();\nSystem.out.println(“成功获取数据库操作对象”);\nString sql = “select * from city”;\nstmt.executeQuery(sql);\nSystem.out.println(&quot;成功执行sql语句：\\“select * from city\\” &quot;);\n}catch (Exception e){\ne.printStackTrace();\n}\n}\n}\n\n到现在为止我们知道了如何让数据库执行指定的SQL，那么我们该如何得到数据库执行SQL语句产生的结果呢？\n这个时候，我们需要学习ResultSet，并使用它来获取数据库返回的数据。\nResultSet对象由Statement执行类似于executeQuery(String sql)的方法产生。\n2.3.2 ResultSet需要熟悉的方法\nJdbc程序中的ResultSet用于代表Sql语句的执行结果。Resultset封装执行结果时，采用的类似于表格的方式。ResultSet 对象维护了一个指向表格数据行的\n游标cursor，初始的时候，游标在第一行之前，调用ResultSet.next() 方法，可以使游标指向具体的数据行，进而调用方法获取 该行的数据。\nResultSet既然用于封装执行结果的，所以该对象提供的大部分方法都是用于获取数据的get方法：\n获取任意类型的数据：\ngetObject(int index）\ngetObject(string columnName)\n获取指定类型的数据，例如：\ngetString(int index)\ngetString(String columnName)\ngetInt(int index)\ngetInt(String columnNmae)\n常用数据类型转换表：\n\nrs游标示意图：\n\n2.3.2.1 编程示例\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\npublic class ResultSetStudy {\npublic static void main(String[] args) {\n//驱动加载\ntry{\nClass.forName(“com.mysql.cj.jdbc.Driver”);\nSystem.out.println(“成功mysql加载驱动！！”);\n}catch (Exception e){\ne.printStackTrace();\n}\n//和数据库建立连接\nString url=“jdbc:mysql://localhost:3306/world?&amp;useSSL=false&amp;serverTimezone=UTC”;\nString username=“root”;\nString password=“root”;\ntry {\nConnection conn = DriverManager.getConnection(url,username,password);\nSystem.out.println(“成功获取数据库连接！！”);\nStatement stmt = conn.createStatement();\nSystem.out.println(“成功获取数据库操作对象”);\nString sql = “select * from city”;\nResultSet rs = stmt.executeQuery(sql);\nSystem.out.println(&quot;成功执行sql语句：\\“select * from city\\” &quot;);\nSystem.out.println(“id|name|countryCode|”);\nwhile(rs.next()) {\nint id = rs.getInt(“id”);\nString name = rs.getString(“name”);\nString countryCode = rs.getString(“countryCode”);\nSystem.out.println(id +&quot; | “+name+” | &quot;+countryCode);\n}\n}catch (Exception e){\ne.printStackTrace();\n}\n}\n}\n\n2.3.3 ResultSet滚动结果集\nResultSet还提供了对结果集进行滚动和更新的方法。\n若想设置可滚动的结果集，则在创建Statement对象时，不能像前文那样调用无参方法，而应该如下设置：\nStatement stmt = conn.createStatement\n(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE);\nnext()：移动到下一行\nprevious()：移动到前一行\nabsolute(int row)：移动到指定行\nbeforeFirst()：移动resultSet的最前面\nafterLast() ：移动到resultSet的最后面\nupdateString(int columnIndex, String x) ：用 String 值更新指定列。\nupdateString(String columnLabel, String x) ：用 String 值更新指定列。\nupdateRow() ：更新行数据，最后要调用这个方法来确认\n2.3.3.1 编程示例\npackage Orm.jdbc.base;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\npublic class MoveResultSet {\npublic static void main(String[] args) {\n//驱动加载\ntry{\nClass.forName(“com.mysql.cj.jdbc.Driver”);\nSystem.out.println(“成功mysql加载驱动！！”);\n}catch (Exception e){\ne.printStackTrace();\n}\n//和数据库建立连接\nString url=“jdbc:mysql://localhost:3306/world?&amp;useSSL=false&amp;serverTimezone=UTC”;\nString username=“root”;\nString password=“root”;\ntry {\nConnection conn = DriverManager.getConnection(url,username,password);\nSystem.out.println(“成功获取数据库连接！！”);\nStatement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE);\nSystem.out.println(“成功获取数据库操作对象”);\nString sql = “select * from city”;\nResultSet rs = stmt.executeQuery(sql);\nSystem.out.println(&quot;成功执行sql语句：\\“select * from city\\” &quot;);\nSystem.out.println(“id|name|countryCode|”);\nwhile(rs.next()) {\nint id = rs.getInt(“id”);\nString name = rs.getString(“name”);\nString countryCode = rs.getString(“countryCode”);\nSystem.out.println(id +&quot; | “+name+” | &quot;+countryCode);\n}\nSystem.out.println(“数据遍历完毕！！------”);\nSystem.out.println(“移动到倒数第一行：”);\nrs.previous();\nint id = rs.getInt(“id”);\nString name = rs.getString(“name”);\nString countryCode = rs.getString(“countryCode”);\nSystem.out.println(id +&quot; | “+name+” | &quot;+countryCode);\nSystem.out.println(“移动到100行：”);\nrs.absolute(100);\nid = rs.getInt(“id”);\nname = rs.getString(“name”);\ncountryCode = rs.getString(“countryCode”);\nSystem.out.println(id +&quot; | “+name+” | &quot;+countryCode);\nSystem.out.println(“移动到最后面”);\nrs.afterLast();\nrs.previous();\nid = rs.getInt(“id”);\nname = rs.getString(“name”);\ncountryCode = rs.getString(“countryCode”);\nSystem.out.println(id +&quot; | “+name+” | &quot;+countryCode);\nrs.updateString(“name”,“Rafahh”);\nrs.updateRow();\nrs.moveToInsertRow();\nrs.updateInt(1,4080);\nrs.updateString(2,“Yanjid”);\nrs.updateString(3,“PSE”);\nrs.updateString(4,“Rafah”);\nrs.updateInt(5,92021);\nrs.insertRow();\nrs.moveToCurrentRow();\nid = rs.getInt(“id”);\nname = rs.getString(“name”);\ncountryCode = rs.getString(“countryCode”);\nSystem.out.println(id +&quot; | “+name+” | &quot;+countryCode);\nrs.close();\nstmt.close();\nconn.close();\n}catch (Exception e){\ne.printStackTrace();\n}\n}\n}\n\n\n可以看到数据库确实更新了。\n可以用以下两种方式使用更新方法：\n更新当前行中的列值。在可滚动的 ResultSet 对象中，可以向前和向后移动光标，将其置于绝对位置或相对于当前行的位置。以下代码片段更新 ResultSet 对象 rs 第五行中的 NAME 列，然后使用方法 updateRow 更新导出 rs 的数据源表。\nrs.absolute(5);\nrs.updateString(“name”, “Rafahh”);\nrs.updateRow();\n将列值插入到插入行中。可更新的 ResultSet 对象具有一个与其关联的特殊行，该行用作构建要插入的行的暂存区域\n以下代码片段将光标移动到插入行，构建一个三列的行，并使用方法 insertRow 将其插入到 rs 和数据源表中。\nrs.moveToInsertRow(); // moves cursor to the insert row\nrs.updateString(1, “AINSWORTH”); // updates the\n// first column of the insert row to be AINSWORTH\nrs.updateInt(2,35); // updates the second column to be 35\nrs.updateBoolean(3, true); // updates the third column to true\nrs.insertRow();\nrs.moveToCurrentRow();\n2.4 如何释放资源\n最后，在finally中执行close操作\n//释放资源\nif(rs!=null){\ntry{\nrs.close();\n}catch(SQLException e){\ne.printStackTrace();\n}\nrs=null;\n}\nif(stmt!=null){\ntry{\nstmt.close();\n} catch(SQLException e) {\ne.printStackTrace();\n}\nstmt=null;\n}if(conn!=null){\ntry{\nconn.close();\n}catch(SQLException e){\ne.printStackTrace();\n}\nconn=null;\n}\n代码地址：\nJava动手做一做/src/main/java/Orm/jdbc/base · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["JDBC"]},{"title":"2.JDBC连接池","url":"/article/ORMFramework-JDBC-2-JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/","content":"1、传统JDBC的缺点\n用户每次请求都需要向数据库实时获得连接，而数据库创建连接通常需要消耗相对较大的资源，创建时间也较长。\n假设网站一天10万访问量，数据库服务器就需要创建10万次连接，极大的浪费数据库的资源，并且极易造成数据库服务器内存溢出、拓机。\n2、连接池原理\n在服务器端一次性创建多个连接，将多个连接保存在一个连接池对象中，当应用程序的请求需要操作数据库时，不会为每一个请求创建新的连接，而是直接从连接池中获得一个已经创建的连接，操作数据库结束之后，并不需要真正关闭连接，而是将连接放回到连接池中等待请求使用。\n连接池的好处：节省创建连接、释放连接资源\n3、自定义连接池\n编写连接池需实现javax.sql.DataSource接口。\nDataSource接口中定义了两个重载的getConnection方法：\nConnection.getConnection()\nConnection.getConnection(String username, String password)\n自定义一个类，实现DataSource接口，并实现连接池功能的步骤：\n在自定义类的构造函数中批量创建Connection，并把创建的连接保存到一个集合对象中（LinkedList）。\n在自定义类中实现Connection.getConnection方法，让getConnection方法每次调用时，\n从集合对象中取出一个Connection返回给用户。\n当用户使用完Connection，不能调用Connection.close()方法，而要使用连接池提供关闭方法，\n即将Connection放回到连接池之中（把Connection存入集合对象中）。\nConnection对象应保证将自己返回到连接池的集合对象中，而不要把Connection还给数据库。\n如果用户习惯调用Connection.close()方法，则可以使用动态代理来增强原有方法。\ndemo\n首先编写\npackage Orm.jdbc.connectorPool;\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\npublic class JDBCUtils {\npublic static DataSource dataSource = new MyDataSource();\nstatic {\n//驱动加载\ntry{\nClass.forName(“com.mysql.cj.jdbc.Driver”);\nSystem.out.println(“成功mysql加载驱动！！”);\n}catch (Exception e){\ne.printStackTrace();\n}\n}\npublic static Connection getConnection(){\n//和数据库建立连接\nString url=“jdbc:mysql://localhost:3306/world?&amp;useSSL=false&amp;serverTimezone=UTC”;\nString username=“root”;\nString password=“root”;\ntry {\nConnection conn = DriverManager.getConnection(url,username,password);\nSystem.out.println(“成功获取数据库连接！！”);\nreturn conn;\n}catch (Exception e){\ne.printStackTrace();\n}\nreturn null;\n}\npublic static Connection getConnection(String username,String password){\n//和数据库建立连接\nString url=“jdbc:mysql://localhost:3306/world?&amp;useSSL=false&amp;serverTimezone=UTC”;\ntry {\nConnection conn = DriverManager.getConnection(url,username,password);\nSystem.out.println(“成功获取数据库连接！！”);\nreturn conn;\n}catch (Exception e){\ne.printStackTrace();\n}\nreturn null;\n}\n}\n然后编写：\npackage Orm.jdbc.connectorPool;\nimport javax.sql.DataSource;\nimport java.io.PrintWriter;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.sql.SQLFeatureNotSupportedException;\nimport java.util.LinkedList;\nimport java.util.logging.Logger;\n/**\n* 连接池管理数据库连接相关工作\n*/\npublic class MyDataSource implements DataSource {\nprivate final LinkedList dataSources = new LinkedList&lt;&gt;();\n/**\n* 初始化创建10个连接\n*/\npublic MyDataSource(){\nfor(int i=0;i&lt;10;i++){\ntry {\nConnection conn = JDBCUtils.getConnection();\n// 将连接加入连接池中\ndataSources.add(conn);\n} catch (Exception e) {\ne.printStackTrace();\n}\n}\n}\n@Override\npublic Connection getConnection() throws SQLException {\n// 取出连接池中一个连接\nfinal Connection conn = dataSources.removeFirst(); // 删除第一个连接返回\nSystem.out.println(&quot;取出一个连接剩余 &quot; + dataSources.size() + “个连接！”);\n// 将目标Connection对象进行close增强,将close方法逻辑替换为放回连接池\nConnection connProxy = (Connection) Proxy.newProxyInstance(conn\n.getClass().getClassLoader(), conn.getClass().getInterfaces(),\nnew InvocationHandler() {\n// 执行代理对象任何方法 都将执行 invoke\n@Override\npublic Object invoke(Object proxy, Method method,\nObject[] args) throws Throwable {\nif (method.getName().equals(“close”)) {\n// 需要加强的方法\n// 不将连接真正关闭，将连接放回连接池\nreleaseConnection(conn);\nreturn null;\n} else {\n// 不需要加强的方法\nreturn method.invoke(conn, args); // 调用真实对象方法\n}\n}\n});\nreturn connProxy;\n}\n// 将连接放回连接池\npublic void releaseConnection(Connection conn) {\ndataSources.add(conn);\nSystem.out.println(“将连接 放回到连接池中 数量:” + dataSources.size());\n}\n/**\n* 根据用户名，密码 实时获取连接\n* @param username\n* @param password\n* @return\n* @throws SQLException\n*/\n@Override\npublic Connection getConnection(String username, String password) throws SQLException {\nreturn JDBCUtils.getConnection(username,password);\n}\n/**\n*\n* @param iface\n* @param \n* @return\n* @throws SQLException\n*/\n@Override\npublic  T unwrap(Class iface) throws SQLException {\nreturn null;\n}\n/**\n*\n* @param iface\n* @return\n* @throws SQLException\n*/\n@Override\npublic boolean isWrapperFor(Class&lt;?&gt; iface) throws SQLException {\nreturn false;\n}\n/**\n*\n* @return\n* @throws SQLException\n*/\n@Override\npublic PrintWriter getLogWriter() throws SQLException {\nreturn null;\n}\n/**\n*\n* @param out\n* @throws SQLException\n*/\n@Override\npublic void setLogWriter(PrintWriter out) throws SQLException {\n}\n/**\n*\n* @param seconds\n* @throws SQLException\n*/\n@Override\npublic void setLoginTimeout(int seconds) throws SQLException {\n}\n/**\n*\n* @return\n* @throws SQLException\n*/\n@Override\npublic int getLoginTimeout() throws SQLException {\nreturn 0;\n}\n/**\n*\n* @return\n* @throws SQLFeatureNotSupportedException\n*/\n@Override\npublic Logger getParentLogger() throws SQLFeatureNotSupportedException {\nreturn null;\n}\n}\n最后编写示例：\npackage Orm.jdbc.connectorPool;\nimport java.sql.*;\npublic class UseConnectorPool {\npublic static void main(String[] args) {\n//声明数据库操作对象\nConnection conn = null;\nStatement stmt = null;\nResultSet rs = null;\ntry {\n//使用连接池获取数据库连接\nconn = JDBCUtils.dataSource.getConnection();\nSystem.out.println(“成功获取数据库连接！！”);\nstmt = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE);\nSystem.out.println(“成功获取数据库操作对象”);\nString sql = “select * from city”;\nrs = stmt.executeQuery(sql);\nSystem.out.println(&quot;成功执行sql语句：\\“select * from city\\” &quot;);\nSystem.out.println(“id|name|countryCode|”);\nwhile(rs.next()) {\nint id = rs.getInt(“id”);\nString name = rs.getString(“name”);\nString countryCode = rs.getString(“countryCode”);\nSystem.out.println(id +&quot; | “+name+” | &quot;+countryCode);\n}\nSystem.out.println(“数据遍历完毕！！------”);\nSystem.out.println(“移动到倒数第一行：”);\nrs.previous();\nint id = rs.getInt(“id”);\nString name = rs.getString(“name”);\nString countryCode = rs.getString(“countryCode”);\nSystem.out.println(id +&quot; | “+name+” | &quot;+countryCode);\nSystem.out.println(“移动到100行：”);\nrs.absolute(100);\nid = rs.getInt(“id”);\nname = rs.getString(“name”);\ncountryCode = rs.getString(“countryCode”);\nSystem.out.println(id +&quot; | “+name+” | &quot;+countryCode);\nSystem.out.println(“移动到最后面”);\nrs.afterLast();\nrs.previous();\nid = rs.getInt(“id”);\nname = rs.getString(“name”);\ncountryCode = rs.getString(“countryCode”);\nSystem.out.println(id +&quot; | “+name+” | &quot;+countryCode);\nrs.updateString(“name”,“Rafahh”);\nrs.updateRow();\nrs.moveToInsertRow();\nrs.updateInt(1,4080);\nrs.updateString(2,“Yanjid”);\nrs.updateString(3,“PSE”);\nrs.updateString(4,“Rafah”);\nrs.updateInt(5,92021);\nrs.insertRow();\nrs.moveToCurrentRow();\nid = rs.getInt(“id”);\nname = rs.getString(“name”);\ncountryCode = rs.getString(“countryCode”);\nSystem.out.println(id +&quot; | “+name+” | &quot;+countryCode);\nrs.close();\nstmt.close();\nconn.close();\n}catch (Exception e){\ne.printStackTrace();\n}finally {\n//释放资源\nif(rs!=null){\ntry{\nrs.close();\n}catch(SQLException e){\ne.printStackTrace();\n}\nrs=null;\n}\nif(stmt!=null){\ntry{\nstmt.close();\n} catch(SQLException e) {\ne.printStackTrace();\n}\nstmt=null;\n}if(conn!=null){\ntry{\nconn.close();\n}catch(SQLException e){\ne.printStackTrace();\n}\nconn=null;\n}\n}\n}\n}\n\n成功运行！！\n代码地址：\nJava动手做一做/src/main/java/Orm/jdbc/connectorPool · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["JDBC"]},{"title":"3.JDBC元数据","url":"/article/ORMFramework-JDBC-3-JDBC%E5%85%83%E6%95%B0%E6%8D%AE/","content":"1.DatabaseMetaData 获取数据库定义信息\n1.1 什么是元数据？\n在数据库领域，元数据是数据库、表、列的定义信息，关于数据库的整体综合信息。\n1.2 如果获得元数据？\n在Java中，首先我们可以通过下面的方式获得DatabaseMetaData对象：\nConnection connection = JDBCUtils.getConnection();\nDatabaseMetaData metaData = connection.getMetaData();\n然后通过DatabaseMetaData的方法就可以获得关于数据库的定义信息了。\nDataBaseMetaData类常用方法:\ngetURL()：返回一个String类对象，代表数据库的URL。\ngetUserName()：返回连接当前数据库管理系统的用户名。\ngetDriverName()：返回驱动驱动程序的名称。\ngetPrimaryKeys(String catalog, String schema, String table)：返回指定表主键的结果集，一般catalog、schema都传入null，得到一个结果集resultset。\n1.3 编程实例\npackage Orm.jdbc.jdbcMetadata;\nimport Orm.jdbc.connectorPool.JDBCUtils;\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n/**\n* 数据库元数据获取学习\n*/\npublic class DatabaseMetaDataStudy {\npublic static void main(String[] args) throws SQLException {\nConnection connection = JDBCUtils.getConnection();\nDatabaseMetaData metaData = connection.getMetaData();\n// 获得JDBC连接参数信息\nSystem.out.println(“数据库的URL为：”+metaData.getURL());\nSystem.out.println(“驱动程序的名称为：”+metaData.getDriverName());\nSystem.out.println(“当前数据库的连接者为：”+metaData.getUserName());\n/**\n* Catalog—目录名称;必须与存储在数据库中的目录名称匹配;&quot;检索那些没有目录的;Null表示不应使用编目名称来缩小搜索范围\n* Schema—模式名称;必须匹配存储在数据库中的模式名称;&quot;检索那些没有模式的;Null意味着不应该使用模式名来缩小搜索范围\n* Table—表名;必须匹配表名，因为它存储在数据库中\n*\n* 这个方法查询的结果集描述如下：\n* TABLE_CAT String =表类别（可为 null）\n* TABLE_SCHEM String =表模式（可为 null）\n* TABLE_NAME String =表名称\n* COLUMN_NAME String =列名称\n* KEY_SEQ short =主键中的序列号（值 1 表示主键中的第一列，值 2 表示主键中的第二列）。\n* PK_NAME String =主键的名称（可为 null）\n*\n*/\nResultSet rs = metaData.getPrimaryKeys(“world”, null, “city”);\nSystem.out.println(“TABLE_CAT|TABLE_SCHEM|TABLE_NAME|COLUMN_NAME|KEY_SEQ|PK_NAME”);\nwhile (rs.next()) {\nStringBuffer buffer = new StringBuffer();\nbuffer.append(rs.getString(“TABLE_CAT”)).append(“|”);\nbuffer.append(rs.getString(“TABLE_SCHEM”)).append(“|”);\nbuffer.append(rs.getString(“TABLE_NAME”)).append(“|”);\nbuffer.append(rs.getString(“COLUMN_NAME”)).append(“|”);\nbuffer.append(rs.getShort(“KEY_SEQ”)).append(“|”);\nbuffer.append(rs.getString(“PK_NAME”));\nSystem.out.println(buffer.toString());\n}\n}\n}\n\n2. ParameterMetaData 获取列定义信息（存在缺陷）\nParameterMetaData可以用来获得代表PreparedStatement元数据的ParameterMetaData对象。\n简单来说： 获得预编译SQL语句中 “?” 信息。\nSelect * from user where name=? And password=?\n如何获取对象：PreparedStatement.getParameterMetaData()\nParameterMetaData类的常用方法：\ngetParameterCount()\n获得指定参数的个数\ngetParameterType(int param)\n获得指定参数的sql类型\ngetParameterTypeName(int param) — 参数类型名称\n2.1 编程实例\npackage Orm.jdbc.jdbcMetadata;\nimport Orm.jdbc.connectorPool.JDBCUtils;\nimport java.sql.Connection;\nimport java.sql.ParameterMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\n/**\n* 获得预执行SQL语句中 “?” 信息。\n*/\npublic class ParameterMetaDataStudy {\npublic static void main(String[] args) throws SQLException {\nConnection conn = JDBCUtils.getConnection();\nString sql = “select * from city where ID=? And name=?”;\n/**\n* 预执行sql语句\n*/\nPreparedStatement stmt = conn.prepareStatement(sql);\n// 通过ParameterMetaData 获得 ？ 相关信息\nParameterMetaData parameterMetaData = stmt.getParameterMetaData();\n// 获得个数\nint count = parameterMetaData.getParameterCount();\nSystem.out.println(&quot;参数个数为： &quot;+count);\n/**\n* 我们可以根据这个getParameterType根据返回的type进行参数填充，但是对于mysql\n* 返回的都是varchar，这个就不好办了,所以说，如果我们需要编写ORM自动填充逻辑，我们不应该根据这个来\n*/\nfor (int i = 1; i &lt;= count; i++) {\n// 该方法并不是所有数据库都支持 — MySQL不支持（所有返回类型都是varchar）\nint type = parameterMetaData.getParameterType(i);\nSystem.out.println(&quot;参数类型编号为： &quot;+type);\nSystem.out.println(&quot;参数类型为： &quot;+parameterMetaData.getParameterTypeName(i));\n}\n}\n}\n\n可能遇到的问题：Parameter metadata not available for the given statement\n解决方法：url后面拼接参数\n&amp;generateSimpleParameterMetadata=true\n3.ResultSetMetaData 获取列定义信息\n通过这个对象，我们可以获取指定表的列定义信息，我们可以通过这个列定义信息来编写一些通用程序来帮助提升编程效率。\n如何获得ResultSetMetaData对象：ResultSet.getMetaData()\nResultSetMetaData类常用方法：\ngetColumnCount()\n返回resultset对象的列数\ngetColumnName(int column)\n获得指定列的名称\ngetColumnTypeName(int column)\n获得指定列的类型\n3.1 编程实例\npackage Orm.jdbc.jdbcMetadata;\nimport Orm.jdbc.connectorPool.JDBCUtils;\nimport java.sql.*;\nimport java.util.*;\n/**\n* 通过ResultSetMetaData对象，我们可以获取表的列的类型信息\n* 这对于构造ORM框架进行自填充起到了很大的作用\n*/\npublic class ResultSetMetaDataStudy {\npublic static void main(String[] args) throws SQLException {\n//获取连接\nConnection conn = JDBCUtils.getConnection();\n//定义sql\nString sql = “select * from city”;\n//预编译\nPreparedStatement stmt = conn.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();\n// 获得结果集元数据\nResultSetMetaData resultSetMetaData = rs.getMetaData();\nint count = resultSetMetaData.getColumnCount();\nList columnNameList = new ArrayList&lt;&gt;();\nMap&lt;String,String&gt; columnTypeMap = new HashMap&lt;&gt;();\n// 打印table 第一行\nfor (int i = 1; i &lt;= count; i++) {\nString columnName = resultSetMetaData.getColumnName(i);\n//System.out.print( columnName+ “\\t”);\ncolumnNameList.add(columnName);\n}\nSystem.out.println();\n// 打印每列类型\nfor (int i = 1; i &lt;= count; i++) {\nString type = resultSetMetaData.getColumnTypeName(i);\n//System.out.print( type+ “\\t”);\ncolumnTypeMap.put(columnNameList.get(i-1),type);\n}\nSystem.out.println();\nSystem.out.println(columnTypeMap);\n}\n}\n\n4.使用元数据简化JDBC代码\n现在系统中所有实体对象都涉及到基本的CRUD（create、read、update、delete）操作：\n所有实体的CRUD操作代码基本相同，仅仅发送给数据库的SQL语句不同而已，因此可以把CRUD操作的所有相同代码抽取到工具类的一个update，query方法中，并定义参数接收变化的SQL语句。\n写框架思路：\n将不变的内容留在框架内部\n将变的内容作为参数或者配置文件\n具体步骤：\n1.通用CUD方法设计\nframework代码\n/**\n* 通用insert update delete方法\n* @param sql 预执行需要SQL\n* @param args 根据SQL中? 准备参数\n*/\npublic static void update(String sql, Object… args) throws SQLException {\nConnection conn = null;\nPreparedStatement stmt = null;\ntry {\nconn = JDBCUtils.getConnection();\nstmt = conn.prepareStatement(sql);\n// 设置参数 — 根据？设置参数\nParameterMetaData parameterMetaData = stmt.getParameterMetaData();\nint count = parameterMetaData.getParameterCount();\nfor (int i = 1; i &lt;= count; i++) {\nstmt.setObject(i, args [i - 1 ]);\n}\nstmt.executeUpdate();\n} catch (SQLException e) {\ne.printStackTrace();\n} finally {\nstmt.close();\nconn.close();\n}\n}\nDAO代码：\npublic void updateCity(City city) throws SQLException {\nString sql = “update city set name=?,countryCode=? where id =?”;\nObject[] params = { city.getName(),city.getCountryCode(),city.getId() };\nWaterRepositoryImp.update(sql, params);\n}\n4.1 使用实例\npublic static void main(String[] args) throws SQLException {\nCity city = new City();\ncity.setId(4080);\ncity.setName(“yanjd”);\ncity.setCountryCode(“PSE”);\nnew Test().updateCity(city);\n}\n\n通用R方法设计\n接口代码\n/**\n* 此接口用来定义结果集封装类能力\n* @param  用来接收结果集的类\n*/\npublic interface ResultHandler {\n/**\n* 用户自定义结果集封装方式\n* @param rs\n* @return\n*/\npublic R handle(ResultSet rs);\n/**\n* 根据传入的Class对象，根据结果集和Class对象生成Class对象描述的实体类返回\n* @param rs\n* @param domainClass\n* @return\n*/\npublic R handle(ResultSet rs,Class&lt;?&gt; domainClass);\n}\n并提供一个默认实现：\nimport java.beans.BeanInfo;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.Method;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.util.Locale;\npublic class DefaultResultHandler implements ResultHandler{\n@Override\npublic R handle(ResultSet rs) {\nreturn null;\n}\n@Override\npublic R handle(ResultSet rs, Class&lt;?&gt; domainClass) {\ntry {\n// 结果集元数据\nResultSetMetaData resultSetMetaData = rs.getMetaData();\nint count = resultSetMetaData.getColumnCount();\nBeanInfo beanInfo = Introspector.getBeanInfo(domainClass);\n//获取属性描述器数组\nPropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors();\nif (rs.next()) {\n//因为不能通过泛型获得T的实例，所以通过反射技术来获得T的实例！！！\nR t = ® domainClass.newInstance();\nfor (int i = 1; i &lt;= count; i++) {\nString columnName = resultSetMetaData.getColumnName(i);\n// 获得列名 — 需要去查找匹配属性\nfor (PropertyDescriptor propertyDescriptor : descriptors) {\nString columnName1 = columnName.toLowerCase(Locale.ROOT);\nString beanName = propertyDescriptor.getName().toLowerCase(Locale.ROOT);\n// 列名 存在 同名属性 ---- 列值 存到属性里\nif (columnName1.equals(beanName)) {\n// 得到属性的写方法，如同setName、setMoney等方法\nMethod writeMethod = propertyDescriptor.getWriteMethod();\nwriteMethod.invoke(t, rs.getObject(columnName));\n}\n}\n}\nreturn t;\n}\n} catch (Exception e) {\ne.printStackTrace();\n}\nreturn null;\n}\n}\nframework代码：\n/**\n* 通用select方法\n*/\npublic static  R query(String sql, Class&lt;?&gt; clazz ,Object… args) throws SQLException {\nResultHandler handler = new DefaultResultHandler&lt;&gt;();\nR obj = null;\nConnection conn = null;\nPreparedStatement stmt = null;\nResultSet rs = null;\ntry {\nconn = JDBCUtils.getConnection();\nassert conn != null;\nstmt = conn.prepareStatement(sql);\n// 设置参数\nParameterMetaData parameterMetaData = stmt.getParameterMetaData();\nint count = parameterMetaData.getParameterCount();\nfor (int i = 1; i &lt;= count; i++) {\nstmt.setObject(i, args [i - 1 ]);\n}\nrs = stmt.executeQuery();\nobj = handler.handle(rs,clazz);\n} catch (SQLException e) {\ne.printStackTrace();\n} finally {\nrs.close();\nstmt.close();\nconn.close();\n}\nreturn obj;\n}\n4.2 使用实例\npublic void queryCity() throws SQLException {\nCity city = WaterRepositoryImp.query(“select * from city where id = ?”,City.class,4080);\nSystem.out.println(city);\n}\n\n代码地址：\nJava动手做一做/src/main/java/Orm/jdbc/ormdiy · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["JDBC"]},{"title":"4.DBUtils学习","url":"/article/ORMFramework-JDBC-4-DBUtils%E5%AD%A6%E4%B9%A0/","content":"1.DbUtils简介\ncommons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，创建连接、执行sql , 结果集封装、释放资源，同时也不会影响程序的性能。创建连接、结果集封装、释放资源因此dbutils成为很多不喜欢hibernate的公司的首选。\nAPI介绍：\norg.apache.commons.dbutils.QueryRunner — 核心\norg.apache.commons.dbutils.ResultSetHandler — 结果集封装器\norg.apache.commons.dbutils.DbUtils — 工具类\n官方地址：\nhttp://commons.apache.org/proper/commons-dbutils/\n学习重点：多看看API，多看看官网的example！\n2.DbUtils类\nDbUtils是提供如加载驱动、关闭连接、事务提交、回滚等常规工作的工具类，里面的所有方法都是静态的。\n主要方法如下：\n装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。\npublic static boolean loadDriver(java.lang.String driverClassName)\n示例：\n/**\n* 加载驱动学习\n*/\npublic static void loadDriverStudy(){\nDbUtils.loadDriver(“com.mysql.cj.jdbc.Driver”);\n}\nDbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。\npublic static void close(…) throws java.sql.SQLException\n这一类&quot;quietly&quot;方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLException。\npublic static void closeQuietly(Connection conn, Statement stmt, ResultSet rs)\n用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。\npublic static void commitAndCloseQuietly(Connection conn)\n示例：\n/**\n* 关闭连接\n* @throws SQLException\n*/\npublic static void closeConnectionStudy() throws SQLException {\nDbUtils.loadDriver(“com.mysql.cj.jdbc.Driver”);\nConnection connection = JDBCUtils.getConnection();\nDbUtils.close(connection);\n//提交并关闭\nDbUtils.commitAndCloseQuietly(connection);\nDbUtils.commitAndClose(connection);\n}\n3.QueryRunner类\n该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。\nQueryRunner类提供了两个构造方法：\n默认的构造方法：QueryRunner()\n需要一个 javax.sql.DataSource 来作参数的构造方法：QueryRunner(DataSource ds)\n常用方法（主要分为两种情况:使用连接池和不使用连接池的)\n查询操作\npublic Object query(Connection conn, String sql, ResultSetHandler rsh, Object… params)\npublic Object query(String sql, ResultSetHandler rsh, Object… params)\n示例：\n/**\n*\n* @throws SQLException\n*/\npublic static void queryStudy() throws SQLException {\nDbUtils.loadDriver(“com.mysql.cj.jdbc.Driver”);\nQueryRunner runner = new QueryRunner(JDBCUtils.dataSource);\nCity city = (City) runner.query(“select * from city limit 1”, new BeanHandler(City.class));\nSystem.out.println(city);\nCity city1 = (City) runner.query(“select * from city where id=?”, new BeanHandler(City.class),4079);\nSystem.out.println(city1);\n}\n批处理\nbatch(Connection conn, String sql, Object[][] params) // 传递连接批处理\nbatch(String sql, Object[][] params) // 不传递连接批处理\n示例：\n/**\n* 批量更新\n*/\npublic static void batchStudy() throws SQLException {\nDbUtils.loadDriver(“com.mysql.cj.jdbc.Driver”);\nQueryRunner runner = new QueryRunner(JDBCUtils.dataSource);\nString sql = &quot;update city set name = ‘YanKing’ where id = ? &quot;;\nInteger[][] params= new Integer [2 ] [1 ];\nparams [0 ] [0 ] = 4080;\nparams [1 ] [0 ] = 4081;\nint[] res = runner.batch(sql,params);\nfor(int n:res){\nSystem.out.println(n);\n}\n}\n更新操作\npublic int update(Connection conn, String sql, Object… params)\npublic int update(String sql, Object… params)\n示例：\n/**\n*更新操作\n*/\npublic static void updateStudy() throws SQLException {\nDbUtils.loadDriver(“com.mysql.cj.jdbc.Driver”);\nQueryRunner runner = new QueryRunner(JDBCUtils.dataSource);\nString sql = &quot;update city set name = ‘YanQuque’ where id = ? &quot;;\nint resNum = runner.update(sql,4081);\nSystem.out.println(resNum);\n}\n4、ResultSetHandler接口\n该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。\nResultSetHandler 接口提供了一个单独的方法：\nObject handle(ResultSet rs){}\nResultSetHandler 接口的实现类（构造方法不唯一，在这里只用最常见的构造方法）：\nArrayHandler()：把结果集中的第一行数据转成对象数组（存入Object[]）。\n/**\n* ArrayHandler将结果集的第一行数据按照顺序存入数组中，数据中一个元素代表一列的一个值\n*/\npublic static void ArrayHandlerStudy() throws SQLException {\nDbUtils.loadDriver(“com.mysql.cj.jdbc.Driver”);\nQueryRunner runner = new QueryRunner(JDBCUtils.dataSource);\nObject[] city = runner.query(“select * from city limit 1”, new ArrayHandler());\nfor(Object o:city){\nSystem.out.print(o+&quot;| &quot;);\n}\n}\nArrayListHandler()：把结果集中的每一行数据都转成一个对象数组，再存放到List中。\n/**\n* ArrayListHandler\n*/\npublic static void ArrayListHandlerStudy() throws SQLException {\nDbUtils.loadDriver(“com.mysql.cj.jdbc.Driver”);\nQueryRunner runner = new QueryRunner(JDBCUtils.dataSource);\nList&lt;Object[]&gt; cityList = runner.query(“select * from city limit 5”, new ArrayListHandler());\nfor(Object[] city:cityList){\nfor(Object o:city){\nSystem.out.print(o+&quot;| &quot;);\n}\nSystem.out.println();\n}\n}\nBeanHandler(Class** type)**：将结果集中的第一行数据封装到一个对应的JavaBean实例中。\n/**\n* BeanHandler支持直接将查询到的数据赋值给实体的属性中，使用频率高\n* @throws SQLException\n*/\npublic static void BeanHandlerStudy() throws SQLException {\nDbUtils.loadDriver(“com.mysql.cj.jdbc.Driver”);\nQueryRunner runner = new QueryRunner(JDBCUtils.dataSource);\nCity city = runner.query(“select * from city limit 1”, new BeanHandler&lt;&gt;(City.class));\nSystem.out.println(city);\n}\nBeanListHandler(Class** type)**：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。\n/**\n* BeanHandler支持直接将查询到的数据赋值给实体的属性中,并放入List中，使用频率高\n* @throws SQLException\n*/\npublic static void BeanListHandlerStudy() throws SQLException {\nDbUtils.loadDriver(“com.mysql.cj.jdbc.Driver”);\nQueryRunner runner = new QueryRunner(JDBCUtils.dataSource);\nList cityList = runner.query(“select * from city limit 5”, new BeanListHandler&lt;&gt;(City.class));\nfor(City city:cityList){\nSystem.out.println(city);\n}\n}\nColumnListHandler(String columnName/int columnIndex)：将结果集中某一列的数据存放到List中。\n/**\n*将结果集中某一列的数据存放到List中,比较常用\n*/\npublic static void ColumnListHandlerStudy() throws SQLException {\nDbUtils.loadDriver(“com.mysql.cj.jdbc.Driver”);\nQueryRunner runner = new QueryRunner(JDBCUtils.dataSource);\nList cityList = runner.query(“select * from city limit 5”, new ColumnListHandler&lt;&gt;(“Name”));\nfor(Object city:cityList){\nSystem.out.println(city);\n}\n}\nMapHandler()：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。\n/**\n* 将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。\n*/\npublic static void MapHandlerStudy() throws SQLException {\nDbUtils.loadDriver(“com.mysql.cj.jdbc.Driver”);\nQueryRunner runner = new QueryRunner(JDBCUtils.dataSource);\nMap&lt;String,Object&gt; city = runner.query(“select * from city limit 1”, new MapHandler());\nfor(Map.Entry&lt;String,Object&gt; entry:city.entrySet()){\nSystem.out.println(entry.getKey()+“=”+entry.getValue());\n}\n}\nMapListHandler()：将结果集中的每一行数据都封装到一个Map里，然后再将所有的Map存放到List中。\n/**\n*将结果集中的每一行数据都封装到一个Map里，然后再将所有的Map存放到List中。\n*/\npublic static void MapListHandlerStudy() throws SQLException {\nDbUtils.loadDriver(“com.mysql.cj.jdbc.Driver”);\nQueryRunner runner = new QueryRunner(JDBCUtils.dataSource);\nList&lt;Map&lt;String,Object&gt;&gt; mapList = runner.query(“select * from city limit 2”, new MapListHandler());\nfor(Map&lt;String,Object&gt; col:mapList){\nfor(Map.Entry&lt;String,Object&gt; entry:col.entrySet()){\nSystem.out.print(entry.getKey()+“=”+entry.getValue());\nSystem.out.print(“,”);\n}\nSystem.out.println();\n}\n}\nKeyedHandler(String columnName)：将结果集每一行数据保存到一个“小”map中,key为列名，value该列的值，再将所有“小”map对象保存到一个“大”map中 ， “大”map中的key为指定行，value为“小”map对象。\n/**\n* 将结果集每一行数据保存到一个“小”map中,key为列名，value该列的值，再将所有“小”map对象保存到一个“大”map中 ， “大”map中的key为指定行，value为“小”map对象\n*/\npublic static void KeyedHandlerStudy() throws SQLException {\nDbUtils.loadDriver(“com.mysql.cj.jdbc.Driver”);\nQueryRunner runner = new QueryRunner(JDBCUtils.dataSource);\nMap&lt;Integer,Map&lt;String,Object&gt;&gt; mapList = runner.query(“select * from city limit 2”, new KeyedHandler&lt;&gt;());\nfor(Map.Entry&lt;Integer,Map&lt;String,Object&gt;&gt; mapEntry:mapList.entrySet()){\nSystem.out.println(mapEntry.getKey()+&quot;: &quot;);\nfor(Map.Entry&lt;String,Object&gt; entry:mapEntry.getValue().entrySet()){\nSystem.out.print(entry.getKey()+“=”+entry.getValue());\nSystem.out.print(“,”);\n}\nSystem.out.println();\n}\n}\nScalarHandler(int columnIndex)：通常用来保存只有一行一列的结果集。\n/**\n*通常用来保存只有一行一列的结果集。\n*/\npublic static void ScalarHandlerStudy() throws SQLException {\nDbUtils.loadDriver(“com.mysql.cj.jdbc.Driver”);\nQueryRunner runner = new QueryRunner(JDBCUtils.dataSource);\nString sql = “select * from city limit 1”;\nObject o =runner.query(“select * from city limit 1”, new ScalarHandler&lt;&gt;(“countryCode”));\nSystem.out.println(o);\n}\n代码地址：\nJava动手做一做/src/main/java/Orm/dbutils · 严家豆/Study - 码云 - 开源中国 (gitee.com)\n","tags":["JDBC"]},{"title":"1.MySQL基础命令","url":"/article/Database-MySQL-Base-1-Mysql%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5%E4%B9%8B%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2-SELECT%E5%92%8CSHOW/","content":"1.简单查询\n1.0 连接mysql服务器\n本地登录MySQL：mysql -h localhost -u root -proot\n远程登录MySQL: mysql -h 192.168.5.116 -P 3306 -u root -p123456\n1.1 创建数据库\nCREATE DATABASE 数据库名;-- 例如：create database mysql_crash_course;\n\n1.2 选择名为database_name的数据库\nUSE database_name;-- 例如：use mysql_crash_course;\n\n1.3 显示MySQL中所有数据库\nSHOW DATABASES;\n\n1.4 返回当前选择的数据库内可用表的列表。\n在执行这个操作之前，我们需要按顺序执行下面两条语句进行数据表的创建和数据插入：\n\n\n其中后面的路径就是脚本的绝对路径，脚本的获取地址为：\n数据库脚本\nSHOW TABLES;\n\n1.5 返回名为table_name表的基本信息\nSHOW COLUMNS FROM table_name;\n\n或者更简洁的\nDESC table_name;\n\n或者\nSHOW FULL COLUMNS FROM table_name //这里展示更详细的信息\n\n1.6 显示服务器的状态信息\nSHOW STATUS; //这条语句会返回很多行（返回服务器所有状态）SHOW status like &quot;key...&quot;;//建议使用这里的key就是我们想要看到的状态\n\nconnections代表试图连接mysql的次数\n1.7 显示授予所有用户的安全权限。\nSHOW GRANTS;\n\n1.8 显示服务器的错误消息\nSHOW ERRORS; //因为现在执行每条语句都会报告，所以没有单独查询的必要\n1.9 显示服务器警告消息\nSHOW WARNINGS;//因为现在执行每条语句都会报告，所以没有单独查询的必要\n1.10 查询表table_name中的column_name列的集\nSELECT column_name FROM table_name;\n\n1.11 返回表table_name中的column1,column2,column3列的数据\nSELECT column1,column2,column3 FROM table_name;\n\n1.12 返回表中的全部列的集\n//不建议在编程中使用,首先这个语句的可读性不好，另外它可能耗费额外的宽带和内存SELECT * FROM table_name;\n\n1.13 返回表中column值不同的数据集\nSELECT DISTINCT column FROM table_name;\n\n1.14 返回前5行的column的数据\nSELECT column FROM table_name LIMIT 5;\n//limit多用于分页查询，在MySQL中最好使用下面语句进行分页查询：SELECT column FROM table_name LIMIT 1,5; // 1,5 代表从第二行开始查询5数据\n\n\n1.15 物理分页\n物理分页依赖的是某一物理实体，这个物理实体就是数据库，比如MySQL数据库提供了limit关键字，程序员只需要编写带有limit关键字的SQL语句，数据库返回的就是分页结果。\nSELECT column FROM table_name LIMIT 0,5; //返回第一到第五行数据SELECT column FROM table_name LIMIT 5,10; //返回第六到第十行数据\n1.16 逻辑分页\n逻辑分页依赖的是程序员编写的代码。数据库返回的不是分页结果，而是全部数据，然后再由程序员通过代码获取分页数据，常用的操作是一次性从数据库中查询出全部数据并存储到List集合中，因为List集合有序，再根据索引获取指定范围的数据。\n//查询到所有数据到内存中，然后再内存中使用应用程序的进行分页SELECT column FROM table_name\n1.17 返回从行5(第六行)开始的5行值。（第一行为行0）\nSELECT column FROM table_name LIMIT 5,5;\n\n1.16 等同于SELECT column FROM table，加上表名和数据库名可读性更强\nSELECT table.column FROM database.table;\n\n","tags":["MySQL基础"]},{"title":"2.MySQL排序检索和过滤检索","url":"/article/Database-MySQL-Base-2-mysql%E6%8E%92%E5%BA%8F%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4-ORDER-BY%E5%92%8CWHERE/","content":"1.检索排序与过滤\n1.1.返回以column为准排序后的值(默认是a-z，0-9升序)\nSELECT column FROM table_name ORDER BY column;\n\n1.2.查询下面三列结果且以prod_price(最高级) prod_name(次高级：处理prod_price相等的情况)按默认排序\nSELECT prod_id,prod_price,prod_name FROM productsORDER BY prod_price,prod_name;\n\n1.3.查询以prod_price按降序排序\nSELECT prod_id,prod_price,prod_name FROM productsORDER BY prod_price DESC;\n\n1.4.返回的结果以prod_price降序(优先) prod_name升序的方式输出\nSELECT prod_id,prod_price,prod_name FROM productsORDER BY prod_price DESC,prod_name;\n\n1.5.返回prod_price的最大值\nSELECT prod_price FROM productsORDER BY prod_price DESC LIMIT 1;\n或者更优的\nSELECT MAX(prod_price) FROM products;\n\n\nWHERE子句主要用于条件过滤，对于WHERE的操作符，我们可以看参考下面\n\nBETWEEN a AND b 是包含边界值的\n1.6.从表中检索两列，只返回prod_price值为2.50的行\nSELECT prod_name,prod_price FROM products WHERE prod_price=2.50;\n\n1.7.注意：where过滤一般情况下不区分大小写\nSELECT prod_name,prod_price FROM productsWHERE prod_name=&#x27;fuses&#x27;;\n\n1.8.返回prod_price小于10的所有查询值\nSELECT prod_name,prod_price FROM productsWHERE prod_price&lt;10;\n\n1.9.返回prod_price小于等于10的所有查询值\nSELECT prod_name,prod_price FROM productsWHERE prod_price&lt;=10;\n\n1.10.返回prod_price值为5到10的检索结果（包括5和10）\nSELECT prod_name,prod_price FROM productsWHERE prod_price BETWEEN 5 AND 10;\n\n1.11.返回prod_price字段为空的查询值。\nSELECT prod_name FROM productsWHERE prod_price IS NULL;\n\n注意：这里是 is null 而不是 =null\n1.12.返回符合WHERE后面的语句的值，AND是且的意思\nSELECT prod_id,prod_price,prod_name,vend_id FROM productsWHERE vend_id=1003 AND prod_price&lt;=10;\n\n1.13.检索vend_id=1002或1003或…的值且按prod_price排序（IN中的两个数不是指的区间）\nSELECT prod_name,prod_price ,vend_id FROM productsWHERE vend_id IN(1002,1003) ORDER BY prod_price;\n\n1.14.NOT是非的意思。就是匹配vend_id=1002和1003之外的。\nSELECT prod_name,prod_price,vend_id FROM productsWHERE vend_id NOT IN(1002,1003)ORDER BY prod_name;\n\n","tags":["MySQL基础"]},{"title":"3.MySQL通配符和正则表达式","url":"/article/Database-MySQL-Base-3-mysql%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%87%E6%BB%A4%EF%BC%88LIKE%E5%92%8CREGEXP%EF%BC%89/","content":"1.MySql中的模式匹配\n1.1 检索任意以jet开头的词，%告诉mysql接受jet之后的任意字符，数量不限\nSELECT prod_id,prod_name FROM productsWHERE prod_name LIKE &#x27;jet%&#x27;;\n在mysql中 % 可以匹配任何字符串\n\n\n1.2 匹配prod_name列上的任何包含anvil的词可以用%anvil%作为like条件\nSELECT prod_id,prod_name FROM productsWHERE prod_name LIKE &#x27;%anvil%&#x27;;\n\n1.3 找出table_name表中prod_name列上以s开头以e结尾的所有行。\nSELECT prod_name FROM productsWHERE prod_name LIKE &#x27;s%e&#x27;;\n\n1.4 _和%用途一样，不过它匹配任意一个字符\nselect prod_id,prod_name from productswhere prod_name like &#x27;_ ton%&#x27;;\n\n1.5 正则匹配表中prod_name列包含’1000‘的行。\nSELECT prod_name FROM productsWHERE prod_name REGEXP &#x27;1000&#x27; ORDER BY prod_name;\n\n\n1.6 .表示正则匹配任意一个字符，下面语句意味着可以匹配表中prod_name包含1000，2000，a000等的行\nSELECT prod_name FROM productsWHERE prod_name REGEXP &#x27;.000&#x27; ORDER BY prod_name;\n\n1.7 BINARY让正则表达式的匹配中区分大小写\nSELECT prod_name FROM productsWHERE prod_name REGEXP BINARY &#x27;JetPack .000&#x27; ;\n\n1.8 正则匹配包含1000或2000的词\nSELECT prod_name FROM productsWHERE prod_name REGEXP &#x27;1000|2000&#x27; ;\n\n1.9  [123 ]正则匹配1或2或3或12或123…\nSELECT prod_name FROM productsWHERE prod_name REGEXP &#x27; [123 ] ton&#x27; ORDER BY prod_name;\n\n1.10  [^123 ]匹配1和2和3之外的任何字符（包含多个）\nSELECT prod_name FROM productsWHERE prod_name REGEXP &#x27; [^123 ] ton&#x27; ORDER BY prod_name;\n\n1.11  [0-9]匹配0到9之间的任意一个数。 [a-z]匹配任意字母字符\nSELECT prod_name FROM productsWHERE prod_name REGEXP &#x27; [0-9] ton&#x27;ORDER BY prod_name;\n\n1.12 匹配包含 .(特殊字符) 的词\nSELECT prod_name FROM productsWHERE prod_name REGEXP &#x27;\\\\.&#x27;ORDER BY prod_name;\n\n\n\n\n\n1.13 sticks?表示匹配stick和sticks\nSELECT prod_name FROM productsWHERE prod_name REGEXP &#x27;\\\\( [0-9 ] sticks?\\\\)&#x27;ORDER BY prod_name;\n\n1.14  [ [:digit: ] ]{4}匹配连在一起的任意4位数字\nSELECT prod_name FROM productsWHERE prod_name REGEXP &#x27; [ [:digit: ] ]&#123;4&#125;&#x27;ORDER BY prod_name;\n\n1.15 匹配文本的开始有数字或.的词\nSELECT prod_name FROM productsWHERE prod_name REGEXP &#x27;^ [0-9\\\\\\\\. ]&#x27;ORDER BY prod_name;\n\n","tags":["MySQL基础"]},{"title":"4.字符串处理函数和数据处理函数","url":"/article/Database-MySQL-Base-4-mysql%E8%AF%AD%E5%8F%A5%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/","content":"1.字符串处理和数据计算\n1.1 Concat()拼接字符串串,每个字符串串中间用逗号分隔\nSELECT Concat(vend_name,&#x27; (&#x27;,vend_country, &#x27;)&#x27;) FROM vendorsORDER BY vend_name;\n\n\n1.2 RTrim()函数去掉值右边的所有空格，LTrim()去掉值左边的所有空格,Trim()函数去掉两边的空格\nSELECT Concat(RTrim(vend_name),&#x27; (&#x27;,RTrim(vend_country), &#x27;)&#x27;) FROM vendorsORDER BY vend_name;\n\n1.3 AS用来设置别名，设输出的列名为vend_title\nSELECT Concat(RTrim(vend_name),&#x27; (&#x27;,RTrim(vend_country), &#x27;)&#x27;) AS vend_title FROM vendorsORDER BY vend_name;\n\n1.4 expanded_price作为新列在后面输出。内容为前两列的乘积。\nSELECT prod_id, quantity, item_price, quantity*item_price AS expanded_price FROM orderitems WHERE order_num=20005;\n\n\n\n1.5 Upper()函数将文本小写转换成大写字符串\nSELECT vend_name,Upper(vend_name) AS vend_name_upcase FROM vendorsORDER BY vend_name;\n\n1.6 LENGTH(str)函数的返回值为字符串的长度。\nSELECT vend_name,length(vend_name) AS vend_name_lengthFROM vendors ORDER BY vend_name;\n\n1.7 CHAR_LENGTH(str)函数的返回值为字符串所包含的字符个数。\nSELECT vend_name,char_length(vend_name) AS vend_name_lengthFROM vendors ORDER BY vend_name;\n\n1.8 INSERT(s1,x,len,s2)函数将字符串s1中x位置开始长度为len的字符串用s2替换。\nSELECT vend_name,insert(vend_name,1,2,&#x27;B&#x27;) AS vend_name_lengthFROM vendors ORDER BY vend_name;\nmysql脚本中字符串起始位置为1\n\n1.9 LEFT(s,n)函数返回字符串s最左边的n个字符\nSELECT vend_name,left(vend_name,1) AS vend_name_lengthFROM vendors ORDER BY vend_name;\n\n1.10 RIGHT(s,n)函数返回字符串s最右边的n字符\nSELECT vend_name,right(vend_name,1) AS vend_name_lengthFROM vendors ORDER BY vend_name;\n\n1.11 LPAD(s1,len,s2)函数返回字符串s1，其左边由字符串s2填补到len字符长度，如果s1长度大于len，则返回值由s1缩短到len长度（从左到右且不是填充后缩短）\n// 缩短SELECT vend_name,lpad(vend_name,1,&#x27;B&#x27;) AS new_vend_nameFROM vendors ORDER BY vend_name;// 填充SELECT vend_name,lpad(vend_name,10,&#x27;B&#x27;) AS new_vend_nameFROM vendors ORDER BY vend_name;\n\n1.12 RPAD(s1,len,s2)同理LPAD(s1,len,s2)\n//SELECT vend_name,rpad(vend_name,10,&#x27;B&#x27;) AS new_vend_nameFROM vendors ORDER BY vend_name;//SELECT vend_name,rpad(vend_name,1,&#x27;B&#x27;) AS new_vend_nameFROM vendors ORDER BY vend_name;\n\n1.13 TRIM(s1 FROM s)函数可以删除字符串s中两端所有的子字符串s1（中间的不删除），s1为可选项，在未指定的情况下删除空格。\nSELECT vend_name,trim(&#x27;A&#x27; from vend_name) AS new_vend_nameFROM vendors ORDER BY vend_name;SELECT vend_name,trim(&#x27;a&#x27; from vend_name) AS new_vend_nameFROM vendors ORDER BY vend_name;\n\n1.14 REPEAT(s,n)函数返回一个由重复n次的字符串s组成的字符串。\nSELECT vend_name,repeat(vend_name,2) AS new_vend_nameFROM vendors ORDER BY vend_name;\n\n1.15 SPACE(n)函数返回一个由n个空格组成的字符串。\nSELECT vend_name,space(2) AS new_vend_nameFROM vendors ORDER BY vend_name;\n\n1.16 REPLACE(s,s1,s2)函数使用字符串s2替代字符串s中所有的字符串s1.\nSELECT vend_name,replace(vend_name,&#x27;A&#x27;,&#x27;B&#x27;) AS new_vend_nameFROM vendors ORDER BY vend_name;\n\n1.17 STRCMP(s1,s2)函数中的字符串若相同，则返回0，若s1小于s2,则返回-1，大于返回1\nSELECT vend_name,STRCMP(vend_name,&#x27;ACME&#x27;) AS new_vend_nameFROM vendors ORDER BY vend_name;\n\n1.18 SUBSTRING(s,n,len)/MID(s,n,len)函数表示从字符串s中往后截取一个长度为len的子字符串，起始位置为n，若n为负值，则字符串起始于字符串结尾的n字符（即倒数第n个字符）\n//SELECT vend_name,substring(vend_name,1,2) AS new_vend_nameFROM vendors ORDER BY vend_name;//SELECT vend_name,substring(vend_name,-1,3) AS new_vend_nameFROM vendors ORDER BY vend_name;\n\n\n\n1.19 LOCATE(str1,str) [不区分大小写 ],POSITION(str1 IN str)  [不区分大小写 ] , INSTR(str,str1)三个函数作用相同，返回字符串str1在str中的开始位置。\nSELECT vend_name,locate(&#x27;A&#x27; ,vend_name) AS new_vend_nameFROM vendors ORDER BY vend_name;//SELECT vend_name,position(&#x27;A&#x27; in vend_name) AS new_vend_nameFROM vendors ORDER BY vend_name;//SELECT vend_name,instr(vend_name,&#x27;A&#x27;) AS new_vend_nameFROM vendors ORDER BY vend_name;\n\n\n\n1.20 REVERSE(s)可以将字符串s反转，返回的 字符串和s顺序相反。\nSELECT vend_name,reverse(vend_name) AS new_vend_nameFROM vendors ORDER BY vend_name;\n\n\n1.21 返回日期在范围内的所有信息\nselect cust_id, order_num , order_datefrom orders where Date(order_date) between &#x27;2005-09-01&#x27; and &#x27;2005-09-30&#x27;;\n\n\n1.22 返回一个数的绝对值\nselect cust_id, order_num ,abs(order_num) from orders;\n\n","tags":["MySQL基础"]},{"title":"5.聚集函数和分组查询","url":"/article/Database-MySQL-Base-5-mysql%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0%E5%92%8C%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE-GROUP-BY-%E5%92%8C-HAVING/","content":"1.聚集函数\n\n1.1 查询prod_price列的平均值输出\n// 分别查询products表中的prod_price的和，数量，平均值select sum(prod_price),count(prod_price), avg(prod_price) as avg_pricefrom products;\n\n1.2 取prod_price列中的不同值计算平均值输出\nselect sum(distinct prod_price),count(distinct prod_price), avg(distinct prod_price)as avg_pricefrom products;\n\n1.3 组合使用聚集函数，输出四个相应的计算后的值。\nSELECT COUNT(*) AS num_items,MIN(prod_price) AS price_min,MAX(prod_price) AS price_max,AVG(prod_price) AS price_avg FROM products;\n\n1.4 GROUP BY子句指示mysql按vend_country数据分组。\n// 这条语句统计每个不同vend_country的数量SELECT vend_country,COUNT(\\*) AS num_prodsFROM vendors GROUP BY vend_country;\n\n1.5 HAVING 起着过滤分组的作用(在以分组的基础上进行过滤)\n// 这条语句找出每个不同vend_country的数量大于1的记录SELECT vend_country,COUNT(\\*) AS num_prodsFROM vendors GROUP BY vend_countryhaving num_prods&gt;1;\n\n\n1.6 如果我们想将分组后的结果进行排序我们可以在后面添加order by子句\nSELECT vend_country,COUNT(*) AS num_prods FROM vendorsGROUP BY vend_countryorder by num_prods;\n\n","tags":["MySQL基础"]},{"title":"2.Java的基本数据类型的声明与使用","url":"/article/JavaPrograming-JavaBase-2-Java%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","content":"1.基础部分\n1.1 Java的基本数据类型的声明与使用\nJava基本数据类型有四类，分别是：\n整数型：byte(1字节)  short(2字节) int(4字节) long(8字节)\n浮点型：float(4字节) double(8字节)\n字符型：char(2字节)\n布尔型：boolean(1位)\n一共8个,其中整数型有四个，浮点型有两个，字符型一个，布尔型一个。\n对于基本数据类型，我们可以不对其进行赋值操作，如果不对其进行赋值，java会自动帮其赋予初始值。\nbyte: 0short: 0int: 0long: 0float: 0.0double: 0.0char:   boolean: falseProcess finished with exit code 0\n1.2 类型转换\n一般来说，低精度可自动转换为高精度\n当然我们也可以强制转换将高精度数值赋给低精度变量，不过强制转换可能出现精度损失的状况\n下面属于低转高，不会出现精度损失\ngraph LR\nbyte--&gt;short\nshort--&gt;int\nint--&gt;long\nchar--&gt;int\nint--&gt;double\nfloat--&gt;double\n而高精度转低精度可能会有精度损失:\n例如\ngraph LR\nint--lose--&gt;float\nlong--lose--&gt;float\nlong--lose--&gt;double\n下面是char转为其他类型时的表现：\nchar value: ￿char to int: 65535char to short: -1char to long: 65535char to float: 65535.0char to double: 65535.0Process finished with exit code 0\n1.3 控制台输入，输出数据\n开始只需知道两个语句即可\n输入：\nScanner reader = new Scanner(System.in) ;\nreader.nextDouble（）;\n这里的nextDouble可以换成nextShort…等等根据数据类型定义。\nJava是个严格区分大小写的语言\n输出：System.out.println();或System.out.print();\n前者和后者的差别就是前者在输出后自动换行，后者不会。\n还有  System.out.printf(); 用法和C语言的一样。\n示例：\nimport java.util.Scanner;/** * 让程序获取控制台用户输入的数据 */public class ScannerStudy {    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        System.out.println(\"请输入数据，回车结束：\");        String firstIn = in.nextLine();        System.out.println(\"获取控制台用户输入的字符串: \"+firstIn);        int firstInt = in.nextInt();        System.out.println(\"获取控制台用户输入的int类型的数据： \"+firstInt);        int firstLong = in.nextInt();        System.out.println(\"获取控制台用户输入的Long类型的数据： \"+firstLong);        double firstDouble = in.nextDouble();        System.out.println(\"获取控制台用户输入的double类型的数据：\"+firstDouble);    }}\n请输入数据，回车结束：你好获取控制台用户输入的字符串: 你好12获取控制台用户输入的int类型的数据： 122332获取控制台用户输入的Long类型的数据： 23322323.342获取控制台用户输入的double类型的数据：2323.342Process finished with exit code 0\n1.4 数组\n在这里数组的使用有几个步骤：\n1.4.1 声明\n声明数组的语法如下：\n数组的元素类型  数组名[];或者数组的元素类型 [] 数组名;\n例如：\nfloat boy[];或者float[] boy;\n(注意Java不允许在声明数组中的方括号内指定数组元素的个数)\n1.4.2 为数组分配内存空间\n语法如下：\n数组名 = new 数组元素的类型[数组元素的个数];例如：        boy = new float[4];\n1.4.3 数组的使用\n使用示例：\npublic class ArrayStudy {    public static void main(String[] args) {        int[] nums;        nums = new int[5];        nums[0] = 1;        nums[1] = 2;        System.out.println(\"nums[0]: \"+nums[0]);        System.out.println(\"nums[1]: \"+nums[1]);    }}\n运行结果如下：\nnums[0]: 1nums[1]: 2Process finished with exit code 0\n2.实践积累部分\n2.1 数据的转换与赋值问题\n只需弄懂下面程序的错误点即可：\npublic class E{  public static void main(String args[]){      int x = 8;//【代码１】      byte b =128;//【代码２】//超出范围      x = 12L;//【代码３】//12L表示long型数，需要强制转换才可以赋给int型      long y = 8;//【代码４】//虽然可以，但不规范      float z = 6.89;//【代码５】//float类型赋值应该在数的后面加f  }}\n2.2 注意System.out.println()与System.out.print()的区别\n虽然二者都是输出函数，但前者是输出自动换行，后者则不换行\n2.3 要熟悉数组工作原理\n下面的例子较好的说明了数组的基本工作原理：\npublic class E { public static void main(String args[]) {        int [] a={10,20,30,40},b[] = {{1,2},{4,5,6,7}};        b[0] = a;        b[0][1] = b[1][3];        System.out.println(b[0][3]);        System.out.println(a[1]);  }}\n如果你能正确推算出这个程序的输出结果，那么你对数组的内部工作原理了解不错了。\n正确答案是：40　７\n代码地址：\nhttps://gitee.com/yan-jiadou/study/tree/master/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/src/main/java/exa02\n","tags":["Java基础"]},{"title":"6.子查询和联表查询","url":"/article/Database-MySQL-Base-6-Mysql%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%81%94%E8%A1%A8-INNER-JOIN-ON%E5%92%8COUTER-JOIN-ON/","content":"1.接下面学习我们以下面的样例表为应用对象\n1.1 vendors表\nvendors表存储销售产品的供应商。每个供应商在这个表中有一个记录，vend_id列用来匹配产品和供应商\n列说明是否主键vend_id唯一的供应商id主键 自增vend_name供应商名称vned_address供应商的地址vend_city供应商的城市vend_state供应商的州vend_zip供应商的邮政编码vend_country供应商的国家\n1.2 products表\nproducts表包含产品目录，每行一个产品。每个产品都有为一个id，通过供应商的唯一id关联到它的供应商。\n列说明是否主键prod_id唯一的产品id主键 自增vend_id供应商id逻辑外键prod_name产品名称prod_price产品价格prod_desc产品描述\n1.3 customers表\ncustomers表存储所有顾客的信息，每个顾客信息有唯一的id\n列说明是否主键cust_id顾客唯一id主键 自增cust_name顾客名称cust_address顾客地址cust_city顾客所在城市cust_state顾客所在州cust_zip顾客的邮政编码cust_country顾客的国家cust_contact顾客的联系名称cust_email顾客的联系email\n1.4 orders表\norders表存储顾客订单基本信息。每个订单唯一有唯一的编号，订单用cust_id关联到相应的顾客。\n列说明是否主键order_num订单编号主键 自增order_date订单日期cust_id客户id逻辑外键\n1.5 orderitems表\norderitems表存储每个订单中的实际物品，每个订单的每个物品占一行，对orders中的每一行，orderitems中存在一个行或多行与其对应。\n每个订单物品有订单号加订单物品唯一标识。订单物品通过order_num列与它相应的订单相关联。此外，每个订单项包含订单物品的产品id。\n列说明是否主键order_num订单编号主键，外键order_item订单物品号主键prod_id产品id逻辑外键quantity物品数量item_price物品价格\n1.6 productnotes表\nproductnotes表存储与特定产品有关的说明。并非所有产品都有相关的说明，而有的产品可能有许多相关的注释。\n这个表指定MyISAM引擎。\n列说明是否主键note_id产品唯一注释id主键prod_id产品id外键note_date增加注释的日期note_text注释文本\n2.子查询\n简单来说，子查询就是嵌套查询，用嵌套查询我们可以一步完成简单查询好几步才能完成的查询。\n2.1 子查询示例\n比如：我们需要检索出订购TNT2的所有客户信息，如果不用子查询，一般这样检索：\n\n\n1.检索orderitems中包含物品TNT2的所有订单编号\n\n\n2.检索orders具有前一步骤列出的订单编号的所有用户的ID\n\n\n3.根据2返回的ID查询customers客户信息\n\n\n我们下面先用简单查询来实现：\nSELECT order_num FROM orderitems WHERE prod_id=&#x27;TNT2&#x27;;SELECT cust_id FROM orders WHERE order_num IN(1的结果);SELECT cust_name,cust_contact FROM customers WHERE cust_id IN(2的结果);\n\n现在通过子查询机制，我们可以用下面嵌套查询来一步实现：\nSELECT cust_name,cust_contact FROM customersWHERE cust_id IN(SELECT cust_id FROM orders WHERE order_num IN(SELECT order_num FROM orderitems WHERE prod_id=&#x27;TNT2&#x27;));\n\n我们可以很明显的感觉第二种方式更简便，但我们不能无限制的使用嵌套语句，因为太多的嵌套会影响查询性能。\n3.联表查询\n在关系型数据库中，不同的数据往往存在多个表中，那么怎样用单条SELECT语句检索出存在于多个表中相互关联的数据呢？\n联表查询可以帮助我们实现，简单来说，联表是一种机制，允许在一条SELECT语句中关联表进行查询（多表查询），因此称之为联结，使用联结的特殊语法可以联结多个表返回一组输出。\n而输出的数据组成的表称为联结表。\n注意：联结表是虚拟的表，并不真实存在（它只是一个中间表）\n3.1 联结机制使用示例\n// 这条语句将查询出vendors和products种vend_id相等的记录select vend_name,prod_name,prod_pricefrom vendors,productswhere vendors.vend_id=products.vend_idorder by vend_name,prod_name;\n\n很明显，这条语句要查询的是vendors和products中的vend_id相等的相关信息混合式输出。上面所使用的连接我们可以称之为WHERE联结。因为它是用where子句实现混合查询的效果的。\n上面所用的联结称为等值联结，也称为内部联结，它基于两个表之间的相同字段作为条件来进行查询。\n3.2 内部联结（INNER JOIN ON/WHERE）\nSELECT vend_name,prod_name ,prod_priceFROM vendors INNER JOIN products ON vendors.vend_id = products.vend_id;\n\n3.3.如果要联结多个表该怎么做？\n有下面的例子:\nSELECT prod_name,vend_name,prod_price,quantity FROM orderitems,products,vendorsWHERE products.vend_id=vendors.vend_id AND orderitems.prod_id=products.prod_id AND order_num=20005;\n\n和上面类似，只不过限制关系复杂度罢了。\n注意：尽量联结必要的表，联结的表越多性能下降的越厉害。\n4.高级联表查询\n4.1 使用表别名（AS）\n我们除了给列名和计算字段起别名以外，还可以给表名其别名，这样做的好处有：\n缩短SQL语句\n允许在单条SELECT语句中多次使用相同的表。\n例如：\nSELECT cust_name,cust_contact FROM customers AS c,orders AS o ,orderitems AS oiWHERE c.cust_id=o.cust_id AND oi.order_num=o.order_num AND prod_id=&#x27;TNT2&#x27;;\n\n4.2 使用不同类型的联结\n除了等值联结（内联结）以外我们还有其他联结方式：\n4.2.1 自联结：将同一种表用多个不同的别名进行联结\nSELECT p1.prod_id,p1.prod_name FROM products AS p1,products AS p2WHERE p1.vend_id=p2.vend_id AND p2.prod_id=&#x27;DTNTR&#x27;;\n\n此查询中需要的两个表实际上是相同的表，但这个查询完全合理，这种方式就叫自联结。\n4.2.2 自然联结\n内部联结返回的数据可能存在重复，自然联结排除多次出现，使每个列只返回一次。\n怎样完成这个工作呢？ 我们可以选择那些唯一的列。 这一般是通过对表使用通配符（SELECT *），对所有其他表的列使用明确的子集来完成。\n例子：\nSELECT c.*,o.order_num,o.order_date,oi.prod_id,oi.quantity,oi.item_price FROM customers AS c,orders AS o,orderitems AS oiWHERE c.cust_id=o.cust_id AND oi.order_num=o.order_num AND prod_id=&#x27;FB&#x27;;\n\n4.2.3 外部联结\n许多联结将一个表中的行与另一个表中的行相关联，但有时候需要包含没有关联行的那些行。\n例如，我们可能需要使用联结来完成以下工作：\na.对每个客户下了多少订单进行计数，包括那些至今尚未下单的客户\nb.列出所有产品以及订购数量，包括没有人订购的产品\nc.计算平均销售规模，包括那些至今尚未下单的客户\n在上面例子中，联结表包含了那些在相关表中没有关联行的行，这种类型的联结称为外部联结。\nSELECT vend_name,prod_name ,prod_price FROMvendors LEFT OUTER JOIN productsON vendors.vend_id = products.vend_id;\n\n关键字OUTER JOIN 指定联结的类型。在使用词语法时必须使用RIGHT或LEFT关键字指定包括其所有行的表(RIGHT指出的是OUTER JOIN右边的表)\n","tags":["MySQL基础"]},{"title":"3.位运算符,特有表达式,运算符","url":"/article/JavaPrograming-JavaBase-3-%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%8C%E7%89%B9%E6%9C%89%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E8%BF%90%E7%AE%97%E7%AC%A6/","content":"1.基础内容\n运算符与表达式和C的基本一样\n这里要补充的是以前没弄懂的\n1.1 位运算符\n1.1.1 按位&amp;运算（按位与运算）\n按位与运算符&amp;是双目运算符，对两个整型数据进行二进制按位&amp;进行运算，运算的结果也是一个整型数据,\n其运算法则是：\n如果两个数据对应位都是1，则结果的该位是1，否则是0\n例子：\nm:   00000111n:   10101011n&amp;m: 00000011 \n编写程序验证：\npublic class BitAndStudy &#123;    public static void main(String[] args) &#123;        //这里使用的api可以将二进制转为10进制        int num = Integer.parseInt(&quot;00000111&quot;,2);        int num1 =Integer.parseInt(&quot;10101011&quot;,2);        int result = num&amp;num1;        System.out.println(Integer.toBinaryString(result));    &#125;&#125;\n运行结果\n00000111&amp;10101011= 11\n它也可以做判断符来用，但与&amp;&amp;有差别：\n\n&amp;　不管前面的条件是否正确，后面都执行\n&amp;&amp;　前面条件正确时，才执行后面，不正确时，就不执行，就效率而言，这个更好\n\n1.2 按位|运算（按位或运算）\n按位或运算符|是二目运算符，运算法则和&amp;类似\n只要两个数据对应位有一个是1，则结果的该位是1，否则是0\n例子：\npublic static void orStudy()&#123;    //这里使用的api可以将二进制转为10进制    int num = Integer.parseInt(&quot;00000111&quot;,2);    int num1 =Integer.parseInt(&quot;10101011&quot;,2);    int result = num|num1;    System.out.println(&quot;00000111 | 10101011= &quot;+Integer.toBinaryString(result));&#125;\n运行结果：\n00000111 | 10101011= 10101111\n1.3  按位~运算（按位非运算）\n按位非运算符~是单目运算符，对一个整型数据a按位进行运算\n例子：\npublic static void nonStudy()&#123;    //这里使用的api可以将二进制转为10进制    int num = Integer.parseInt(&quot;00000111&quot;,2);    int result = ~num;    System.out.println(&quot;~00000111 = &quot;+Integer.toBinaryString(result));&#125;\n运行结果：\n~00000111 = 11111111111111111111111111111000\n1.4 按位异或运算^（按位异或运算）\n按位异或运算符^是二目运算符，运算法则：\n如果两个数据对应位相同，则结果的该位是0，否则是1\n例子：\n/** * 异或运算: 相同为0，不同为1 */public static void nonOrStudy()&#123;    //这里使用的api可以将二进制转为10进制    int num = Integer.parseInt(&quot;00000111&quot;,2);    int num1 =Integer.parseInt(&quot;10101011&quot;,2);    int result = num^num1;    System.out.println(&quot;00000111 ^ 10101011= &quot;+Integer.toBinaryString(result));&#125;\n运行结果：\n00000111 ^ 10101011= 10101100\n1.5 按位右移&gt;&gt;,&gt;&gt;&gt;\n&gt;&gt;按位右移（相当于将数右移） &gt;&gt;&gt;按位右移，但它会用0填充高位（变小）\n/** * 按位右移： 数会变小 */public static void rightMoveStudy()&#123;    int num = Integer.parseInt(&quot;00000111&quot;,2);    int result = num&gt;&gt;1;    System.out.println(&quot;00000111&gt;&gt;1 = &quot;+Integer.toBinaryString(result));    int result2 = num&gt;&gt;&gt;1;    System.out.println(&quot;00000111&gt;&gt;&gt;1 = &quot;+Integer.toBinaryString(result2));&#125;\n运行结果：\n00000111&gt;&gt;1 = 1100000111&gt;&gt;&gt;1 = 11\n1.6  按位左移&lt;&lt;\n&lt;&lt;按位左移（相当于将数左移，变小）注意：不存在&lt;&lt;&lt;\n/** * 按位左移： 数字变大 */public static void leftMoveStudy()&#123;    int num = Integer.parseInt(&quot;00000111&quot;,2);    int result = num&lt;&lt;1;    System.out.println(&quot;00000111&lt;&lt;1 = &quot;+Integer.toBinaryString(result));&#125;\n运行结果：\n00000111&lt;&lt;1 = 1110\n2.新增运算符：instanceof(关键字) 运算符\n该运算符是二目运算符，左面的操作元是一个对象，右面的是一个类。此运算符先做了解，\n由于目前可能没有类的概念，所以说现在不太好理解。\n当左面的对象是右面的类或子类创建的对象时，该运算符的结果是ture，否则是false\npublic static void main(String[] args) &#123;    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();    System.out.println(list instanceof List);&#125;\n运行结果：\ntrue\n3.for基本语句\n这里和C完全相同。\n不同的是Java提供了遍历数组循环语句：for（声明循环变量：数组的名字）{…}\n例子：\npublic class ForStudy &#123;    public static void main(String[] args) &#123;        int[] num = &#123;1,2,3,4,5&#125;;        for(int n:num)&#123;            System.out.println(n);        &#125;    &#125;&#125;\n运行结果：\n12345Process finished with exit code 0\n2.实践经验积累\n本人认为本章的重点其实是为了给我们学习和设计算法打下一个基础，\n我们要学会将学到的算法转移到这里来，或者利用java的特性设计出新的算法，\n其实，程序设计，算法是最关键的地方，也是最难突破的地方。\n2.1 例子：编写一个应用程序求100以内的全部素数\n要编写出这样一个程序，我们要知道什么是素数：\n素数一般指质数，质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。\nimport java.util.Scanner;/** * 计算1-n范围内的素数 */public class QuestStudy &#123;    public static void main(String args[]) &#123;        int start , end ;        Scanner reader  = new Scanner(System.in);        System.out.println(&quot;请输入数字上限： &quot;);        end = reader.nextInt();        int n = 0;        int i = 0;        //根据end计算1到end之间所有素数        for (start = 1; start &lt; end; start += 2) &#123;            int k = (int) Math.sqrt(start);            for (i = 2; i &lt;= k; i++) &#123;                if (start % i == 0)                    break;            &#125;            if (i &gt;= k + 1) &#123;                System.out.println(start);                n++;            &#125;        &#125;    &#125;&#125;\n运行结果：\n请输入数字上限： 101357Process finished with exit code 0\n代码地址：\nhttps://gitee.com/yan-jiadou/study/tree/master/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/src/main/java/exa03\n","tags":["Java基础"]},{"title":"4.类的定义,变量类型,方法类型","url":"/article/JavaPrograming-JavaBase-4-%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%96%B9%E6%B3%95%E7%B1%BB%E5%9E%8B/","content":"1.类的概念\n类java是基本要素，非常重要，怎么理解类的概念呢？\n如果将Java程序当作一个工厂的话，那么类就是工厂里的电子设备的设计图纸，\n每个电子设备有其对应的属性和操作方法，而对象就是具体的电子设备，\n操作设备的工人知道电子设备的属性和操作方法后才能利用电子设备进行工作。\n换句话说，类是创建对象的蓝图，而对象就是类的具体展现。\n1.1 如何创建一个类\n创建一个类需要的是用class关键字声明它，然后编写类体进行类的具体定义。\nclass 类名{           类体的内容}                 \nclass是声明类的关键字，当我们声明一个类后，我们需要用一对花括号去定义一个类，\n在花括号里编写java代码去定义一个类。\n例如：\nclass Person{    }\n1.2 如何定义一个类\n在Java中，一个类的类体包括如下内容：变量，方法\n1.2.1变量\n变量，就是存储数据的标识符，我们可以用基本的数据类型（或复杂的引用类型）去声明一个变量，\n使其作为类定义的一部分。\n其中变量可分为：\n\n成员变量,实例变量：对象级别的变量 ,它随着对象的创建而创建，消亡而消亡\n类变量：类级别的变量，用static修饰, 它有只有一个，被多个相同类创建的对象共享\n局部变量：方法级别的变量，局部变量的作用域只是方法,随着方法的执行创建，方法的执行结束消亡\n\nclass Person{    int age;//实例变量    static String type = \"中国人\";//类变量}\nclass Person{    int age;//实例变量    static String type = \"中国人\";//类变量        public void method(){        int num;//局部变量                }}\n1.2.2 方法\n方法可分为：构造方法，实例方法，类方法（用static修饰的方法）\n\n\n构造方法，用于构造对象的方法，在Java中默认提供无参构造方法，我们也可以自己编写构造方法。\n\n\n实例方法就是普通的方法，只有创建了类的实例对象，通过对象进行调用。\n\n\n类方法是直接可以通过类名进行调用的方法。\n\n\nclass Person{    int age;//实例变量    static String type = \"中国人\";//类变量    //构造方法，注意它的写法    //构造方法是一个类的必要属性之一    public Person(){                }    //实例方法    public void method(){        int num;//局部变量                }    //类方法    public static void method2(){                }}\n2.对象\n通过类的学习，我们知道了类是构建对象的蓝图，下面我们学习如何使用类来构建对象并进行使用。\n语法如下：\n类名  对象名;对象名  = new 类名();//上面的是对象的创建，下面是对象的使用对象名.变量名对象名.方法()\n问：除了new的方式，还有那些方式可以得到一个实例对象？\n\nclone方式（克隆）（原型模式，了解即可）\nnewInstance方式(反射机制，了解即可)\n反序列化方式（序列化机制，了解即可）\n对于final类可以直接赋值得到，例如String直接就可以String s=“dfadf”\n通过对象工厂获取（工厂模式，了解即可）\n\n这样我们就生成了一个对象实例。\n3.类定义实例\n下面我们写了一个名为Computer的类，然后在类ObjectStudy中用它生成了实例并使用实例对象达到我们的目的。\n/** * 此类展示对象操作。 */public class ObjectStudy {    public static void main(String args[]){        Computer com = new Computer();        int m = 100;        int n = 200;        int result = com.add(m,n);        result = com.add(120+m,n*10+8);        System.out.println(result);    }}class Computer{    int add(int x,int y) {        return x+y;    }}\n运行结果：\n2228Process finished with exit code 0\n4.理解类和对象的关系\n4.1.一个java程序和类之间的关系\ngraph LR\nJavaApplication--&gt;mainClass\nmainClass--&gt;method\nmainClass--&gt;filed\nJavaApplication--&gt;Class1\nClass1--&gt;method1\nClass1--&gt;filed1\nJavaApplication--&gt;Class2\nClass2--&gt;method2\nClass2--&gt;filed2\n我自己的理解来看：\n如果把java程序看做一个工厂的话，类就是工厂里的电子设备的设计图纸，电子设备有其对应的属性和操作方法，\n而对象就是电子设备的实体，控制设备的工人知道电子设备的属性和操作方法后才能利用电子设备可以生产出产品。\n5.细节知识分析\n5.1.类与类的关系\n我个人认为类分为主类和子附属类(相当于一个公司的boss和员工，而这个关系是逐级递分的，\n就是说子附属类的下级可以有子子附属类），主类是最终要运行的那个类，它一般是决策类。\n主类和其子类的组成的工程的类层次结构。\n5.2.变量和变量区别\n\n实例变量：简单来说就是方法外,类里声明的变量，它作用于对象级别\n局部变量：简单来说就是方法内声明的变量，它作用于方法级别\n类变量：用static修饰的方法外,类里声明的变量，它作用于类级别\n\n在方法体里的局部变量优先级高于成员变量（如果出现局部变量和实例变量同名的情况）\n5.3.方法的区别\n方法分为构造方法，实例方法，类方法：\n\n\n构造方法：是类中的一种特殊的方法，当程序用类创建对象是需要使用它的构造方法。\n构造方法没有类型，它的名字和其类名完全相同。如果没有写，编译器会自动给一个空的构造方法。\n\n\n实例方法：实例方法具有入参，出参，方法名等结构，它代表一个实例的能力，通常用来定义业务处理逻辑。\n\n\n类方法：类方法就是用static修饰的实例方法，它代表一个类的能力，通常用来定义算法类的方法。\n\n\n5.4.类方法和类变量的特点\n类方法和类变量拥有各自独自的内存空间，且只有一个。\n代码地址：\nhttps://gitee.com/yan-jiadou/study/tree/master/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/src/main/java/exa04\n关于方法的具体分析在下一篇博客会详细说明。\n","tags":["Java基础"]},{"title":"7.组合查询","url":"/article/Database-MySQL-Base-7-MySql%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2%EF%BC%88UNION%EF%BC%89%E5%92%8C%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2%EF%BC%88Match-%E5%92%8CAgainst-%EF%BC%89/","content":"1.组合查询\n1.1 何为组合查询？\n组合查询的目的是利用UNION操作符将多条SELECT语句的查询结果组合成一个结果集，供我们后续使用。\n有两种基本情况下需要使用组合查询：\n\n\n1.在单个查询中从不同的表返回类似结构的数据\n\n\n2.对单个表执行多个查询，按单个查询返回数据\n\n\n1.2 创建组合查询\n我们可以用UNION操作符来组合多条SQL查询，利用UNION可以给出多条SELECT语句，将它们的结果集组合成单个结果集。\n1.2.1 组合查询实例\n假如我们需要价格小于等于5的所有物品的一个列表，而且还想包括供应商1001和1002生产的所有物品。\n我们先来看单条语句的实现：\nSELECT vend_id, prod_id,prod_price FROM productsWHERE prod_price&lt;=5;\n\n上面语句查询的是价格小于等于5的所有物品的列表。\nSELECT vend_id,prod_id, prod_price FROM productsWHERE vend_id IN(1001,1002);\n上面语句查询的是供应商1001，1002生产的所有物品。\n\n下面是用UNION组合两条语句，一次执行：\nSELECT vend_id, prod_id,prod_price FROM productsWHERE prod_price&lt;=5UNIONSELECT vend_id,prod_id, prod_price FROM productsWHERE vend_id IN(1001,1002);\n我们得出的结果集就是上面两条单语句结果的并集。\n\n当然，上面的功能我们也可以用WHERE来实现，也更为简洁，但对于更复杂的过滤条件，或者从多个表中检索数据的情形，使用UNION可能会更简单。\n1.3 UNION规则\n\n\n1.UNION查询必须由两条或以上的SELECT语句组成，语句之间用关键字UNION分隔\n\n\n2.UNION中的每个查询必须包含相同的列，表达式或聚集函数（各个列不需要以相同的次序列出）\n\n\n3.列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含转换的类型。\n\n\n1.4 包含或取消重复的行\n在执行UNION语句时**，UNION从查询结果集自动去除了重复地行，这是默认的行为**，如果有需要我们可以改变它，如果想返回所有匹配行**，可以使用UNION ALL而不是UNION。**\n1.5 对查询结果排序\nSELECT语句的输出用ORDER BY子句排序，在用UNION组合查询时，只能用一条ORDER BY子句，且必须出现在最后一条SELECT语句之后，对于结果集，不存在用一种方式排序一部分，再用另一种方式排序另一部分，所以不允许使用多条ORDER BY子句。\n例子：\nSELECT vend_id, prod_id,prod_priceFROM productsWHERE prod_price&lt;=5UNIONSELECT vend_id,prod_id, prod_priceFROM productsWHERE vend_id IN(1001,1002)ORDER BY vend_id, prod_price;\n上面语句查询出的结果将以vend_id,prod_price 的顺序排序输出。\n\nSELECT vend_id, prod_id,prod_priceFROM products WHERE prod_price&lt;=5UNIONSELECT prod_id ,vend_id, prod_priceFROM products WHERE vend_id IN(1001,1002) ORDER BY vend_id, prod_price;\n\n2.全文本搜索（实际工作使用场景较少）\n2.1 使用全文本搜索\n为了进行全文本搜索，必须索引被搜索的列，而且要随着数据的改变不断地更新索引。\n在索引之后，SELECT可与Match()和Against()一起使用以执行搜索。\n2.1.1 启用全文本搜索支持\n一般在创建表时启用全文本搜索：\nCREATE TABLE productnotes(note_id int NOT NULL AUTO_INCERMENT,prod_id char(10) NOT NULL,note_date datetime NOT NULL,note_text text NULL,PRIMARY KEY(note_id),FULLTEXT(note_text)//启用全文本搜索)ENGINE=MyISAM;\n上面的语句中有一个列名为note_text,为了进行全文搜索，MySQL根据子句FULLTEXT(note_text)的指示对它进行索引，在定义之后，MySQL自动维护该索引，在增加，更新或删除行时，索引随之自动更新。\n注意：不要在导入数据时使用FULLTEXT。\n2.1.2 进行全文本搜索（实际开发中极少用到）\n在索引创建之后，使用两个函数Match()和Aginst()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。\n例子：\nSELECT note_textFROM productnotesWHERE Match(note_text) Against(&#x27;rabbit&#x27;) \\\\G;//Match()指示MySQL针对指定的列进行搜索，Against()指定词作为搜索文本\n\n注意：\n1.传递给Match()的值必须与FULLTEXT()定义中的相同，如果指定多个列，则必须列出它们。\n2.搜索不区分大小写，除非使用BINARY方式。\n全文本搜索的一个重要部分就是对结果排序，具有较高等级的行（符合最先符合匹配规则行）先返回。\n2.1.3 使用查询扩展\n什么是查询扩展？\n查询扩展用于设法放宽所返回的全文本搜索结果的范围。\n在使用查询扩展时，MySQL对数据和索引进行两遍扫描来完成搜索：\n首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有行\n其次，MySQL检查这些匹配行并选择所有有用的词。\n然后，MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用所有有用的词。\n例子：\nSELECT note_textFROM productnotesWHERE Match(note_text) Against(&#x27;anvils&#x27; WITH QUERY EXPANSION);\n2.1.4 全文本搜索的使用说明\n\n\n1.在索引全文本数据时，短词被忽略且从索引中排除，短词定义为那些具有3个或3个以下字符的词。\n\n\n2.MySQL带有一个内建的非用词列表，这些词在索引全文本数据时总被忽略，如果需要，可以覆盖这个列表。\n\n\n3.许多词出现的频率很高，搜索它们没有用处，所以MySQL规定了一条50%的规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。\n\n\n4.如果表中的行数少于三行，则全文本搜索不返回结果。\n\n\n5.忽略词中的单引号。\n\n\n6.不具有词分隔符的语言不能恰当地返回全文搜索结构。\n\n\n7.仅在MyISAM数据库引擎中支持全文本搜索。但在MySQL 8中InnoDB也支持全文索引了\n","tags":["MySQL基础"]},{"title":"8.增删改数据","url":"/article/Database-MySQL-Base-8-MySQL%E4%B9%8B%E6%8F%92%E5%85%A5%EF%BC%8C%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE-INSERT-INTO-%E5%92%8CUPDATE-SET%E5%92%8CDELETE/","content":"1.插入数据\nMySQL中插入数据使用的是INSERT INTO语句\n1.1.插入完整的一行,此插入有一定的局限性（不常用）\n例子：\nINSERT INTO CustomersVALUES(10006,&#x27;muzhi&#x27;,&#x27;PeP E. LaPew&#x27;,&#x27;100 Main Street&#x27;,&#x27;null&#x27;,&#x27;null&#x27;,&#x27;null&#x27;,&#x27;null&#x27;,&#x27;null&#x27;);\n\n这种写法较简单，但是，它的扩展性和灵活性不是很好，如果执行这条语句，我们必须给每列都赋值才能执行成功,否则就会执行不成功。\n\n1.2.指定列名插入一行数据\n这种方式提供列名，VALUES必须以其指定的次序匹配指定的列名，不一定按各个列出现在实际表中的次序，其优点是：即使表的结构改变，此INSERT语句仍然能正常工作。\n例子：\nINSERT INTO customers(cust_name,cust_contact,cust_email,cust_address,cust_cit)VALUES(&#x27;mazi&#x27;,NULL,&#x27;PeP E. LaPew&#x27;,&#x27;100 Main Street&#x27;,NULL);\n\n1.3.一次性插入多行数据\n我们可以在一条VALUES后加上多个()来完成, 可以用于批量插入数据\nINSERT INTO customers(cust_name,cust_contact,cust_email,cust_address,cust_city)VALUES(&#x27;jd91&#x27;,NULL,&#x27;PeP E. LaPew&#x27;,&#x27;100 Main Street&#x27;,NULL),(&#x27;jd02&#x27;,NULL,&#x27;PeP E. LaPew&#x27;,&#x27;100 Main Street&#x27;,NULL);\n\n1.4. 插入某些查询的结果到指定表中\n假如我们想从另一表中合并客户列表到你的customers表，不需要每次读取一行，然后再将它用INSERT插入，可以如下进行：\nINSERT INTO customers(cust_name,cust_contact,cust_email,cust_address,cust_city)SELECT reverse(cust_name),cust_contact,cust_email,cust_address,cust_city FROM customers\n\n这个比较适合批量合并的操作。\n2.更新和删除数据\n2.1.更新数据\n我们可以使用UPDATE语句，可采用两种方式使用：\n2.1.1 更新表中特定行\n更新一列：\nUPDATE customers SET cust_email=&#x27;elmer@fudd.com&#x27; WHERE cust_id = 10005;\n\n更新多列：\nUPDATE customersSET cust_name=&#x27;Tom&#x27; ,cust_email=&#x27;elmer@fufd.com&#x27;WHERE cust_id = 10005;\n\n如果我们想要删除某一列我们可以设置其为NULL.\n2.2 .删除数据\n我们使用DELETE语句来进行删除。\n// 删除一些行(注意存在外键关联的表必须联合删除才能完整的删除)DELETE FROM customersWHERE cust_id=10006;\n//删除所有行DELETE FROM customers;\n\ndelete from productnotes where note_id = 101;\n\n注意：DELETE语句从表中删除行，甚至所有行，但它不删除表。\n","tags":["MySQL基础"]},{"title":"9.视图和存储过程","url":"/article/Database-MySQL-Base-9-MySql%E8%A7%86%E5%9B%BE%E5%92%8C%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%88CREATE-VIEW-%E5%92%8CCREATE-PROCEDURE%EF%BC%89/","content":"1.视图\n1.1 什么是视图？\n视图是虚拟的表，和普通的数据表不同，视图只包含动态检索的查询结果。\n1.2 我们应该知道视图\n在视图创建以后，可以用与表基本相同的方式处理它们，我们应该是知道的是：\n视图仅仅是用来查看存储在别处的数据的一种工具，视图本身不包含数据，因此它们返回的数据是从其他表中检索出来的，其他表的数据发生改变时，视图也会产生相应的改变\n1.3 视图的规则与限制\n\n\n1）唯一命名：每个视图的命名应当全局唯一。\n\n\n2）对于可以创建的视图数目没有限制：视图可以无限创建，没有数量限制。\n\n\n3）创建视图的前提是具有足够的访问权限：创建视图的前提是对视图所涉及的表有读取权限。\n\n\n4）视图可以嵌套：可以在视图中使用视图。\n\n\n5）ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY ,那么该视图中的ORDER BY将被覆盖。\n\n\n6）视图不能使用索引，也不能有关联的触发器或默认值，因为视图时虚拟的表。\n\n\n7）视图可以和表一起使用。\n\n\n1.4 使用视图\n\n\n1）视图用CREATE VIEW语句创建\n\n\n2）使用SHOW CREATE VIEW viewname;来查看创建视图的语句。\n\n\n3）用DROP删除视图，其语法为DROP VIEW viewname.\n\n\n4）更新视图时，可以先用DROP再用CREATE,也可以直接使用CREATE OR REPLACE VIEW,如果要更新的视图不存在，则会创建一个视图，如果要更新的视图存在，则替换原有视图。\n\n\n使用场景：\n1.4.1 隐藏复杂的SQL，这通常会涉及到联结\n例子：\nCREATE VIEW productcustomers AS SELECT cust_name,cust_contact,prod_idFROM customers,orders,orderitems WHERE customers.cust_id = orders.cust_id AND orderitems.order_num=orders.order_num;\n这条语句的意思是创建一个名为productcustomers的视图，后面的查询语句构成了这个视图。\n\nselect * from productcustomers;\n\n之后我们就可以用这个视图方便的查询信息了：\nselect cust_name,cust_contact from productcustomers where prod_id = &#x27;TNT2&#x27;;\n\n可以看出视图在很大程度上简化了SQL语句，利用视图，我们可以一次编写，多次使用。\n1.4.2 用视图重新格式化检索出的数据\n例如：\nCREATE VIEW vendorlocations ASSELECT Concat(RTrim(vend_name),&#x27;(&#x27;,RTrim(vend_country),&#x27;)&#x27;) FROM vendors\n然后我们可以使用这个视图：\nSELECT * FROM vendorlocations;\n\n1.4.3 用视图过滤不想要的数据\n例如：\nCREATE VIEW customeremaillist ASSELECT cust_id,cust_name,cust_emailFROM customersWHERE cust_email IS NOT NULL;\n然后使用查询语句来查询：\nSELECT * FROM customeremaillist;\n\n1.4.4 使用视图和计算字段\nCREATE VIEW orderitemsexpanded ASSELECT order_num,prod_id,quantity,item_price,quantity*item_price AS expanded_priceFROM orderitems;\n然后使用它：\nSELECT * FROM orderitemsexpanded WHERE order_num=2005;\n\n1.4.5 更新视图\n前面的视图都是用SELECT语句来使用的，难道我们仅仅只限于查询视图吗？\n当然不是：\n视图是可更新的（我们可以用INSERT,UPDATE,DELETE）\n然而我们要注意,更新一个视图将更新其基表，实际上我们对视图的操作实质就是对基表的操作。\n但是，更新也是有条件的，如果视图定义中有以下操作，则不能更新视图：\n分组（使用GROUP BY和HAVING）,联结,子查询,并,聚集函数,DISTINCT,导出.\n总结：视图就是一张虚拟的表，它将多张表中的数据检索组成一张新的表来简化我们的SQL语句的编写,实际上，视图现在在项目中很少用了。\n2.存储过程（存储过程编程在workbench编写方便些)\n2.1 什么是存储过程？\n简单来说，存储过程就是为以后的使用而保存的一条或多条MySql语句的集合。\n存储过程中可以编写带有逻辑的语句，可以说它是sql脚本程序。\n2.2 为什么要用它\n\n\n1）通过把处理语句封装在容易使用的单元中，简化复杂的操作。\n\n\n2）如果所有开发人员和应用程序都使用同一存储过程，则出错的可能性就很小。\n\n\n3）简化对变动的管理。\n\n\n4）提高性能\n\n\n5）存在一些只能用在单个请求的MySQL元素和特性，存储过程可以使用它们来编写功能更强大的代码。\n\n\n简单来说就是：简单，安全，高性能，但对编程人员的素质要求很高。\n即使我们不想要编写自己的存储过程，也仍然可以在适当的时候执行已存在的存储过程。\n2.3 执行存储过程\n例子：\nCALL productpricing(@pricelow,@pricehigh,@priceaverage);\n其中执行名为productpricing的存储过程，它计算并返回产品的最低，最高和平均价格。\n2.4 创建存储过程\n例子：\nCREATE PROCEDURE productpricing()BEGINSELECT Avg(prod_price) AS priceaverageFROM products;END;\n上面创建的存储过程名为productpricing，如果存储过程要接受参数，我们可以在（）中列举出来，\n此存储过程没有参数，但我们仍然需要（），BEGIN和END语句用来限定存储过程体，过程体本身是一个简单的SELECT语句。\n那么如何使用上面创建的存储过程呢：\nCALL productpricing();\n上面语句是返回存储过程查询的结果，我们可以看出存储过程实际上是一个函数。\n2.5 删除存储过程\n例子：\nDROP PROCEDURE productpricing;\n2.6 带参数的存储过程\n创建：\nCREATE PROCEDURE productpricing(OUT pl DECIMAL(8,2),OUT ph DECIMAL(8,2).OUT pa DECIMAL(8,2))BEGINSELECT Min(prod_price)INTO plFROM products;SELECT Max(prod_price)INTO phFROM products;SELECT Avg(prod_price)INTO paFROM productsEND;\n此存储过程接受三个参数：pl存储产品最低价格，ph存储产品最高价格，pa存储产品平均价格，每个参数必须具有指定的类型，这里使用的是十进制，关键字OUT指出相应的参数用来从存储过程传出一个值返回给调用者，关键字IN是传递给存储过程，（INOUT是传入和传出），INTO将查询到的值保存到参数中。\n调用：\nCALL productpricing(@pricelow,@pricehigh,@priceaverage);\n调用时，这条语句并不显示任何数据，它返回以后可以显示的变量。\n为了显示我们可以：\nSELECT @priceaverage;SELECT @pricehigh,@pricelow,@priceaverage;\n2.7 建立智能存储过程\n目前为止，上面的存储过程基本上都是封装MySQL简单的SELECT语句，只有在存储过程内包含业务规则和智能处理时，它们的威力才真正显示出来(sql编程)\n例子：\nCREATE PROCEDURE odertotal( //创建一个名为odertotal的存储过程IN onumber INT, //输入参数onumber，int型IN taxable BOOLEAN,//输入参数taxable，布尔类型OUT ototal DECIMAL(8,2)//输出参数总长8位，小数为2位的 数)COMMENT &#x27;Obtain order total,optionally adding tax&#x27;//他不是必须的，但给出将在SHOW PROCEDURE STATUS的结果中显示BEGIN//过程体开始标记DECLARE total DECIMAL(8,2);//DECLARE语句定义局部变量totalDECLARE taxrate INT DEFAULT 6;//定义局部变量taxrate，默认值为6/*在orderitems表中查找到符合查询的值赋给total*/SELECT Sum(item_price*quaintity)FROM orderitemsWHERE order_num = onumberINTO total;/*IF语句检查taxable是否为真，如果为真，则执行下面的SELECT语句，最后用下面的SELECT语句将total复制到输出变量ototal中*/IF taxable THENSELECT total+(total/100*taxrate) INTO tatal;END IF;SELECT total INTO ototal;END;//过程体结束标记\n显然上面的代码可以成为一个函数了，我们可以用这个函数来进行相关的查询：\nCALL ordertotal(20005,1,@total);SELECT @total;\n2.8 检查存储过程\n为显示用来创建一个存储过程的CREATE语句，使用SHOW CREATE PROCEDURE:\nSHOW CREATE PROCEDURE ordertotal;\n也可以用：\nSHOW PROCEDURE STATUS LIKE &#x27;ordertotal&#x27;;\n学习总结自：《MySQL必知必会》\n","tags":["MySQL基础"]},{"title":"10.游标和事务处理","url":"/article/Database-MySQL-Base-10-MySQL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B8%B8%E6%A0%87%E5%92%8C%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%EF%BC%88DECLARE-name-CURSOR-FOR-dosomething%EF%BC%89/","content":"1.游标\n1.1.使用游标的原因\n有时候我们需要在检索出来的行中前进或后退一行或多行，我们可以使用游标来实现。\n1.2.游标(cursor)的定义\n它是存储在MySQL服务器上的数据库查询，他不是SELECT语句，它是一个结果集，且在MySQL中游标只能用于存储过程和函数中。\n1.3.使用游标\n使用游标进行开发需要下面几个必要的步骤：\n\n\n1）声明定义游标，在这个过程实际上没有检索数据，它只是定义要使用的SELECT语句\n\n\n2）一旦声明后，必须打开游标以供使用，这个过程中用前面的定义的SELECT语句把数据检索出来。\n\n\n3）对于填有数据的游标，根据需要取出各行。\n\n\n4）结束游标的使用后，必须关闭游标。\n\n\n创建游标\n游标用DECLARE语句创建，DECLARE命名游标，并定义相应的SELECT语句，根据需要带WHERE和其他子句，\n例如下面：\nCREATE PROCEDURE processorders()BEGINDECLARE ordernumbers CURSORFORSELECT order_num FROM order;END;\n其中我们的\nDECLARE ordernumbers CURSORFORSELECT order_num FROM order;\n就是创建了一个游标。\n打开和关闭游标\n打开：OPEN ordernumbers;\n上面语句执行查询，存储检索出的数据以供浏览。\n关闭：CLOSE ordernumbers;\nCLOSE释放游标使用的所有内容和资源。\n例子\nCREATE PROCEDURE processorders()BEGINDECLARE ordernumbers CURSORFORSELECT order_num FROM order;OPEN ordernumbers;CLOSE ordernumbers;END;\n注意：如果我们没有明确关闭游标，MySQL将会在END语句时自动关闭它。\n使用游标数据：\n打开游标后，我们可以使用FETCH语句分别访问它的每一行。\n例如：\nCREATE PROCEDURE processorders()BEGINDECLARE o INT;//创建局部变量oDECLARE ordernumbers CURSOR//创建游标FORSELECT order_num FROM order;OPEN ordernumbers;//打开游标FETCH ordernumbers INTO o;//检索当前行的order_num列到一个名为o的变量中（从第一行开始）CLOSE ordernumbers;//关闭游标END;\n上面的只实现了检索一行，如果我们想要检索多行我们可以循环检索：\nCREATE PROCEDURE processorder()BEGINDECLARE done BOOLEAN DEFAULT 0;//创建布尔变量done初始为0DECLARE o INT;//创建int型变量oDECLARE ordernumbers CURSOR//创建游标FORSELECT order_num FROM orders;/*这条语句定义了在条件出现时被执行的代码，当SQLSTATE &#x27;02000&#x27;出现时，SET done=1;*/DECLARE CONTINUE HANDLER FOR SQLSTATE &#x27;02000&#x27; SET done=1;OPEN ordernumbers;//打开游标//循环体执行当done为1时结束REPEATFETCH ordernumbers INTO o;UNTIL done END REPEAT;CLOSE ordernumbers;//关闭游标END;\n2.事务管理\n使用事务处理通过确保成批的SQL操作要么完全执行，要么完全不执行，来维护数据库数据的完整性(安全性)。\n2.1.相关术语\n\n\n事务（transaction）指的是一组SQL语句\n\n\n回退(rollback) 指的是撤销指定SQL语句的过程。\n\n\n提交(commit)指的是将已执行，未存储的SQL语句结果写入数据库表中\n\n\n保留点(savepoint)指事务处理中设置的临时地点，通过保留点我们可以回退到执行sql语句执行前后。\n\n\n注意：一般回退INSERT , UPDATE ,DELETE语句，对于select语句没必要回退，alter table , dorp 语句无法回退\n2.2.控制事务处理\n使用ROLLBACK\nDELETE FROM Orders;ROLLBACK;\n上面语句先删除了Orders表，然后回退，相当于什么都没做。\n使用COMMIT\nSTART TRANSACTION;DELETE FROM orderitems WHERE order_num=200010;DELETE FROM orders WHERE order_num=200010;COMMIT;\n它保证了两个删除语句要么都执行，要么一个都不执行。\n使用保留点\n简单的ROLLBACK和COMMIT语句就可以写入或撤销整个事务处理，但如果我们要实现部分提交或回退，我们就需要SAVEPOINT。\nSAVEPOINT delete1;//创建保留点.....ROLLBACK TO delete1;//回退到保留点\n学习总结自《MySQL必知必会》\n","tags":["MySQL基础"]},{"title":"11.索引入门学习","url":"/article/Database-MySQL-Base-11-MySQL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%85%A5%E9%97%A8/","content":"1.索引基础\n1.1 什么是索引？\n索引是一个单独的，存储在磁盘上的数据库结构，它包含着对数据库里所有记录的引用指针，\n使用索引可以让我们不必在查找数据时按顺序一个一个往下找，而是一次到位，方便快捷。\nMySQL中索引的存储类型有两种：BTREE和HASH(这里涉及数据结构，先了解即可)\n1.2 使用索引的优点\n\n通过创建唯一索引保证每行数据的唯一性\n可以大大加快数据的查询速度\n使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间。\n加速表和表之间的连接\n\n1.3 索引的缺点\n\n需维护,每次增删索引列都要维护索引信息\n占用额外的磁盘空间\n\n##1.4 索引的分类\n\n普通索引：允许在索引的列中插入重复值和空值。\n唯一索引：索引列每行数据必须唯一，允许一个空值，但主键索引是一种特殊的唯一索引，不允许空值\n单列索引：顾名思义，以一个列所作为索引列，一个表中可以有多个单列索引\n组合索引：以多个列的组合作为索引，组合索引的查询遵循最左前缀原则（只有在查询条件中使用了这些列的左边列时，索引列才会被使用）\n全文索引：在定义索引的列上支持值的全文范围内的查找，允许在这些索引列中插入重复值和空值。\n空间索引：对空间数据类型的字段建立的索引。（初学了解即可）\n\n1.5 索引设计原则\n（这些原则让我们建立良好的索引避免性能浪费）\n\n\n尽量使用最少的索引达到最好的效果。太多的索引不仅占用磁盘空间，而且会影响插入，删除，更新等操作（因为表中数据更改的同时存储索引的磁盘的数据也会发生变化）\n\n\n避免对经常更新的表进行太多索引，且尽量用单列索引，对经常用于查询的字段应该创建索引。\n\n\n索引适合于数据量大的表,在设计表的时候可以预先评估，或者随着数据量的增加，我们应该考虑给表加索引\n\n\n在不同值少的列上不要使用索引（索引失效）\n\n\n当唯一性是某种数据的特征时，可以指定唯一索引\n\n\n在频繁进行排序或分组的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。\n\n\n1.6 索引相关的SQL语句\n1.6.1 创建索引\n\n在创建表时指定索引\n例子：\n首先创建book表\n\n--建立普通单列索引INDEX(year_publication)  \nCREATE TABLE book( bookid INT NOT NULL,bookname VARCHAR(225) NOT NULL,authors VARCHAR(255) NOT NULL,year_publication YEAR NOT NULL,INDEX(year_publication)  );\n执行结果如下：\nmysql&gt; CREATE TABLE book    -&gt; (    -&gt; bookid INT NOT NULL,    -&gt; bookname VARCHAR(225) NOT NULL,    -&gt; authors VARCHAR(255) NOT NULL,    -&gt; year_publication YEAR NOT NULL,    -&gt; INDEX(year_publication)    -&gt; );Query OK, 0 rows affected (0.05 sec)mysql&gt; show indexes from book;+-------+------------+------------------+--------------+------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+| Table | Non_unique | Key_name         | Seq_in_index | Column_name      | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |+-------+------------+------------------+--------------+------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+| book  |          1 | year_publication |            1 | year_publication | A         |           0 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |+-------+------------+------------------+--------------+------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+1 row in set (0.00 sec)\n同理：\nUNIQUE INDEX(year_publication) --建立唯一索引INDEX MultiId(bookid,bookname) --建立组合索引 ，查询遵循最左原则FULLTEXT INDEX fullText(bookname) --建立全文索引\n1.6.2 向已存在表中加入索引\nALTER TABLE book ADD INDEX bookIdx(bookid)或CREATE INDEX bookIdx ON book(bookid)\n执行结果如下：\nmysql&gt; ALTER TABLE book ADD INDEX bookIdx(bookid);Query OK, 0 rows affected (0.17 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; show indexes from book;+-------+------------+------------------+--------------+------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+| Table | Non_unique | Key_name         | Seq_in_index | Column_name      | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |+-------+------------+------------------+--------------+------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+| book  |          1 | year_publication |            1 | year_publication | A         |           0 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       || book  |          1 | bookIdx          |            1 | bookid           | A         |           0 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |+-------+------------+------------------+--------------+------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+2 rows in set (0.00 sec)\n1.6.3 删除索引\nALTER TABLE book DROP INDEX bookIdx;或DROP INDEX bookIdx ON book;\n执行结果如下：\nmysql&gt; ALTER TABLE book DROP INDEX bookIdx;Query OK, 0 rows affected (0.01 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; show indexes from book;+-------+------------+------------------+--------------+------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+| Table | Non_unique | Key_name         | Seq_in_index | Column_name      | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |+-------+------------+------------------+--------------+------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+| book  |          1 | year_publication |            1 | year_publication | A         |           0 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |+-------+------------+------------------+--------------+------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+1 row in set (0.00 sec)\n3.索引案例实战\n3.1 首先我们先创建一个表，不指定索引\nCREATE TABLE book (  bookid int(11) NOT NULL,  bookname varchar(225) NOT NULL,  authors varchar(225) NOT NULL,  info varchar(225) DEFAULT NULL,  comment varchar(225) DEFAULT NULL,  year_publication year(4) NOT NULL);\n表内字段如下：\n\n\n\n字段名\n描述\n\n\n\n\nbookid\n书的id，具有唯一性\n\n\nbookname\n书名，不具唯一性\n\n\nauthor\n作者名，不具唯一性\n\n\ninfo\n书的基本简介\n\n\ncomment\n书的评论信息\n\n\nyear_publication\n出版年份\n\n\n\n然后向里面插入二十条数据:\nINSERT INTO book VALUES(1,&#x27;数据库原理与应用教程&#x27;,&#x27;张三&#x27;,&#x27;本书可作为数据库入门书籍，里面详细介绍了数据库原理和操作&#x27;,&#x27;此书简单易懂，实为佳作&#x27;,2020);INSERT INTO book VALUES(2,&#x27;计算机网络&#x27;,&#x27;张四&#x27;,&#x27;本书详细介绍了计算机网络的相关知识&#x27;,&#x27;此书广度很好&#x27;,2020);INSERT INTO book VALUES(3,&#x27;java核心技术卷一&#x27;,&#x27;张五&#x27;,&#x27;本书可作为java基础知识的学习书籍&#x27;,&#x27;此书深入浅出，适合初学者&#x27;,2020);INSERT INTO book VALUES(4,&#x27;算法导论&#x27;,&#x27;张五&#x27;,&#x27;本书详细介绍了算法的相关知识&#x27;,&#x27;此书广度很好&#x27;,2020);INSERT INTO book VALUES(5,&#x27;计算机操作系统&#x27;,&#x27;张四&#x27;,&#x27;本书详细介绍了操作系统的相关知识&#x27;,&#x27;此书广度很好&#x27;,2020);INSERT INTO book VALUES(6,&#x27;数据结构&#x27;,&#x27;张六&#x27;,&#x27;本书详细介绍了数据结构的相关知识&#x27;,&#x27;此书广度很好&#x27;,2020);INSERT INTO book VALUES(7,&#x27;计算机组成&#x27;,&#x27;张七&#x27;,&#x27;本书详细介绍了计算机组成的相关知识&#x27;,&#x27;此书广度很好&#x27;,2020);INSERT INTO book VALUES(8,&#x27;C语言程序设计&#x27;,&#x27;张四&#x27;,&#x27;本书详细介绍了C语言程序设计的相关知识&#x27;,&#x27;此书广度很好&#x27;,2020);INSERT INTO book VALUES(9,&#x27;web程序开发基础&#x27;,&#x27;张八&#x27;,&#x27;本书详细介绍了web开发的相关知识&#x27;,&#x27;此书广度很好&#x27;,2020);INSERT INTO book VALUES(10,&#x27;web程序开发进阶&#x27;,&#x27;张四&#x27;,&#x27;本书详细介绍了web开发进阶的相关知识&#x27;,&#x27;此书广度很好&#x27;,2020);INSERT INTO book VALUES(11,&#x27;java核心技术卷二&#x27;,&#x27;张九&#x27;,&#x27;本书详细介绍了java高级特性的相关知识&#x27;,&#x27;此书广度很好&#x27;,2020);INSERT INTO book VALUES(12,&#x27;spring cloud&#x27;,&#x27;张四&#x27;,&#x27;本书详细介绍了spring cloud的相关知识&#x27;,&#x27;此书广度很好&#x27;,2020);INSERT INTO book VALUES(12,&#x27;java并发编程详解&#x27;,&#x27;张九&#x27;,&#x27;本书详细介绍了java并发编程的相关知识&#x27;,&#x27;此书广度很好&#x27;,2020);INSERT INTO book VALUES(14,&#x27;java多线程编程实战指南&#x27;,&#x27;张四&#x27;,&#x27;本书详细介绍了java多线程的相关知识&#x27;,&#x27;此书广度很好&#x27;,2020);INSERT INTO book VALUES(15,&#x27;深入浅出spring boot&#x27;,&#x27;张十&#x27;,&#x27;本书详细介绍了spring boot的相关知识&#x27;,&#x27;此书广度很好&#x27;,2020);INSERT INTO book VALUES(16,&#x27;java并发编程实战&#x27;,&#x27;张二&#x27;,&#x27;本书详细介绍了java并发编程的相关知识&#x27;,&#x27;此书广度很好&#x27;,2020);INSERT INTO book VALUES(17,&#x27;spring入门经典&#x27;,&#x27;张四&#x27;,&#x27;本书详细介绍了spring学习的相关知识&#x27;,&#x27;此书广度很好&#x27;,2020);INSERT INTO book VALUES(18,&#x27;设计模式&#x27;,&#x27;张三&#x27;,&#x27;本书详细介绍了设计模式的相关知识&#x27;,&#x27;此书广度很好&#x27;,2020);INSERT INTO book VALUES(19,&#x27;编译原理&#x27;,&#x27;张四&#x27;,&#x27;本书详细介绍了编译原理的相关知识&#x27;,&#x27;此书广度很好&#x27;,2020);INSERT INTO book VALUES(20,&#x27;C++程序设计&#x27;,&#x27;张六&#x27;,&#x27;本书详细介绍了C++程序设计的相关知识&#x27;,&#x27;此书广度很好&#x27;,2020);select * from book;\n执行完成后查询的结果如下：\nmysql&gt; select * from book;+--------+------------------------+---------+----------------------------------------------------------+--------------------------+------------------+| bookid | bookname               | authors | info                                                     | comment                  | year_publication |+--------+------------------------+---------+----------------------------------------------------------+--------------------------+------------------+|      1 | 数据库原理与应用教程   | 张三    | 本书可作为数据库入门书籍，里面详细介绍了数据库原理和操作 | 此书简单易懂，实为佳作   |             2020 ||      2 | 计算机网络             | 张四    | 本书详细介绍了计算机网络的相关知识                       | 此书广度很好             |             2020 ||      3 | java核心技术卷一       | 张五    | 本书可作为java基础知识的学习书籍                         | 此书深入浅出，适合初学者 |             2020 ||      4 | 算法导论               | 张五    | 本书详细介绍了算法的相关知识                             | 此书广度很好             |             2020 ||      5 | 计算机操作系统         | 张四    | 本书详细介绍了操作系统的相关知识                         | 此书广度很好             |             2020 ||      6 | 数据结构               | 张六    | 本书详细介绍了数据结构的相关知识                         | 此书广度很好             |             2020 ||      7 | 计算机组成             | 张七    | 本书详细介绍了计算机组成的相关知识                       | 此书广度很好             |             2020 ||      8 | C语言程序设计          | 张四    | 本书详细介绍了C语言程序设计的相关知识                    | 此书广度很好             |             2020 ||      9 | web程序开发基础        | 张八    | 本书详细介绍了web开发的相关知识                          | 此书广度很好             |             2020 ||     10 | web程序开发进阶        | 张四    | 本书详细介绍了web开发进阶的相关知识                      | 此书广度很好             |             2020 ||     11 | java核心技术卷二       | 张九    | 本书详细介绍了java高级特性的相关知识                     | 此书广度很好             |             2020 ||     12 | spring cloud           | 张四    | 本书详细介绍了spring cloud的相关知识                     | 此书广度很好             |             2020 ||     12 | java并发编程详解       | 张九    | 本书详细介绍了java并发编程的相关知识                     | 此书广度很好             |             2020 ||     14 | java多线程编程实战指南 | 张四    | 本书详细介绍了java多线程的相关知识                       | 此书广度很好             |             2020 ||     15 | 深入浅出spring boot    | 张十    | 本书详细介绍了spring boot的相关知识                      | 此书广度很好             |             2020 ||     16 | java并发编程实战       | 张二    | 本书详细介绍了java并发编程的相关知识                     | 此书广度很好             |             2020 ||     17 | spring入门经典         | 张四    | 本书详细介绍了spring学习的相关知识                       | 此书广度很好             |             2020 ||     18 | 设计模式               | 张三    | 本书详细介绍了设计模式的相关知识                         | 此书广度很好             |             2020 ||     19 | 编译原理               | 张四    | 本书详细介绍了编译原理的相关知识                         | 此书广度很好             |             2020 ||     20 | C++程序设计            | 张六    | 本书详细介绍了C++程序设计的相关知识                      | 此书广度很好             |             2020 |+--------+------------------------+---------+----------------------------------------------------------+--------------------------+------------------+\n下面我们对它进行操作：\n3.2 添加单列索引\n通过表的结构我们很容易知道bookid具有唯一性，我们可是将其设置为索引：\nalter table book add index bookIdx(bookid);\nmysql&gt; show indexes from book;Empty set (0.00 sec)mysql&gt; alter table book add index bookIdx(bookid);Query OK, 0 rows affected (0.09 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; show indexes from book;+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+| book  |          1 | bookIdx  |            1 | bookid      | A         |          19 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+1 row in set (0.00 sec)\n然后我们以bookid作为查询条件时会一步到位(时间复杂度为1)：\nselect * from book where bookid = 10 \\G;explain select * from book where bookid = 10 \\G;\nmysql&gt; explain select * from book where bookid = 10 \\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: book   partitions: NULL         type: refpossible_keys: bookIdx          key: bookIdx      key_len: 4          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.01 sec)ERROR:No query specified\n可以看到上面的rows为1，说明一部到位。\n如果没有bookid索引的话，时间复杂度为10，上面的rows会为10\n3.3 添加多列索引\n从表的结构我们知道，除了bookid之外，书名和作者一起也构成了唯一性：\n于是：\nalter table book add index bookIdx2(bookname,authors);\nmysql&gt; alter table book add index bookIdx2(bookname,authors);Query OK, 0 rows affected (0.05 sec)Records: 0  Duplicates: 0  Warnings: 0\n然后进行查询操作：\nexplain select * from book where bookname=&#x27;web程序开发进阶&#x27; and authors = &#x27;张四&#x27; \\G;\nmysql&gt; explain select * from book where bookname=&#x27;web程序开发进阶&#x27; and authors = &#x27;张四&#x27; \\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: book   partitions: NULL         type: refpossible_keys: bookIdx2          key: bookIdx2      key_len: 1804          ref: const,const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)ERROR:No query specified\n下面演示最左原则：\n下面的查询不会用到索引：\nexplain select * from book where authors = &#x27;张四&#x27; \\G;\nmysql&gt; explain select * from book where authors = &#x27;张四&#x27; \\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: book   partitions: NULL         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 20     filtered: 10.00        Extra: Using where1 row in set, 1 warning (0.00 sec)ERROR:No query specified\n但下面的查询会用到：\nexplain select * from book where bookname=&#x27;web程序开发进阶&#x27; \\G;\nmysql&gt; explain select * from book where bookname=&#x27;web程序开发进阶&#x27; \\G;*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: book   partitions: NULL         type: refpossible_keys: bookIdx2          key: bookIdx2      key_len: 902          ref: const         rows: 1     filtered: 100.00        Extra: NULL1 row in set, 1 warning (0.00 sec)ERROR:No query specified","tags":["MySQL基础"]},{"title":"12.数据类型","url":"/article/Database-MySQL-Base-12-MySQL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"1.数据类型\n我们对数据类型的了解可以让我们在设计表的时候避免不必要的空间浪费。\n在MySQL中的数据类型大概可分为四类:\n\n数值数据类型\n日期时间数据类型\n文本字符串数据类型\n二进制字符串数据类型\n\n下面一一介绍它们的特性：\n1.1 数值数据类型\n1.1.1 整数型数据类型\n\n\n\n类型名称\n占用字节数\n\n\n\n\nTINYINT\n1字节\n\n\nSMALLINT\n2字节\n\n\nMEDIUMINT\n3字节\n\n\nINT\n4字节\n\n\nBIGINT\n8字节\n\n\n\n1.1.2 浮点数数据类型\n\n\n\n类型名称\n占用字节数\n\n\n\n\nFLOAT\n4字节\n\n\nDOUBLE\n8字节\n\n\nDECIMAL(M,D)\nM+2字节\n\n\n\n其中，前面两个好理解，最后一个DECIMAL类型不同于前两个，它实际上是以串存放的，DECIMAL\n的有效取值范围由M和D的值决定，前面的M表示存储空间，后面的D表示精度(不指定时默认为（10，0）)\n示例：\nmysql&gt; desc temp;+-------+---------------+------+-----+---------+-------+| Field | Type          | Null | Key | Default | Extra |+-------+---------------+------+-----+---------+-------+| x     | decimal(10,2) | YES  |     | NULL    |       |+-------+---------------+------+-----+---------+-------+1 row in set (0.00 sec)mysql&gt; insert into temp values(5.234);Query OK, 1 row affected, 1 warning (0.00 sec)mysql&gt; select * from temp;+------+| x    |+------+| 5.12 || 5.23 |+------+2 rows in set (0.00 sec)\n1.2 日期与时间类型\n\n\n\n类型名称\n日期范围\n\n\n\n\nYEAR\n1901~2155 （1字节）\n\n\nTIME\n-838：59：59~828：59：59（3字节）\n\n\nDATE\n1000-01-01~9999-12-3（3字节）\n\n\nDATETIME\n1000-01-01 00：00：00~9999-12-31 23：59：59 （8字节）\n\n\nTIMESTAMP\n1970-01-01 00：00：01~2038-01-19 03：14：07 （4字节）\n\n\n\n1.3 文本字符串数据类型\n\n\n\n类型名称\n占字节数\n\n\n\n\nCHAR(M)\nM个字节 1&lt;=M&lt;=255\n\n\nVARCHAR(M)\nL+1字节(L为实际字符串长度)，L&lt;=M 1&lt;=M&lt;=225\n\n\nTINYTEXT\nL+1字节 ，L&lt;2^8\n\n\nTEXT\nL+2字节 ,L&lt;2^16\n\n\nMEDIUMTEXT\nL+3字节，L&lt;2^24\n\n\nLONGTEXT\nL+4字节，L&lt;2^32\n\n\nENUM\n1或2个字节，取决于枚举值的数量\n\n\nSET\n1，2，3，4，8字节，取决于集合成员数量\n\n\n\n下面详细学习：\n1.3.1 CHAR与VARCHAR类型\nCHAR(M)为为固定长度字符串，当插入的字符串长度不够时，会以空格填充，被检索时，会自动删除空格。\nVARCHAR(M)为长度可变的字符串，M表示最大长度，当插入的字符串长度为L时，会存储L个字符串和一个字符串结束字符，故为L+1个\n1.3.2 TEXT类型\nTEXT列保存非二进制的长字符串，如文章内容。 当保存或查询TEXT列的值时，不会删除尾部空格。\n1.3.3 ENUM类型\nENUM是一个字符串对象，其值为表创建时在列规定中枚举的一列值：\n字段名 ENUM(&#x27;value1&#x27;,&#x27;value2&#x27;,&#x27;value3&#x27;,...,&#x27;valueN&#x27;)//最多65535个\nvalueN值枚举列表中的第n个值，ENUM类型的字段在取值时，只能在指定的枚举列表中取，\n而且一次只能取一次，如果创建的成员中有空格时，其尾部的空格将自动被删除，ENUM值在数据库内部用整数表示，\n每个枚举值均有一个索引值，从1开始，例如：\n mysql&gt; CREATE TABLE `temp2` (  `enm_feild` enum(&#x27;first&#x27;,&#x27;second&#x27;,&#x27;three&#x27;,&#x27;four&#x27;) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;  mysql&gt; insert into temp2 values(&#x27;first&#x27;),(&#x27;second&#x27;);mysql&gt; select enm_feild,enm_feild+0 from temp2;+-----------+-------------+| enm_feild | enm_feild+0 |+-----------+-------------+| first     |           1 || second    |           2 |+-----------+-------------+2 rows in set (0.00 sec)  \n1.3.4 SET类型\nSET是一个字符串对象，可以有零或多个值，SET列最多可以有64个成员，其值为表创建时规定的一列值：\nSET (&#x27;value1&#x27;,&#x27;value2&#x27;,&#x27;value2&#x27;,...,&#x27;valueN&#x27;)\n与ENUM相同，SET值在内部用整数表示，列表中每一个值都有一个索引编号。\n与ENUM不同，SET类型的列可从定义的列值中选择多个字符的联合，如果插入SET字段中列值有重复，\n那么MySQL会自动删除重复的值\n使用实例：\nmysql&gt; create table temp4(    -&gt; s set(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;)    -&gt; );Query OK, 0 rows affected (0.06 sec)mysql&gt; insert into temp4 values(&#x27;a&#x27;),(    -&gt; &#x27;a,b,c&#x27;),(&#x27;c,a,d&#x27;);Query OK, 3 rows affected (0.00 sec)Records: 3  Duplicates: 0  Warnings: 0mysql&gt; select * from temp4;+-------+| s     |+-------+| a     || a,b,c || a,c,d |+-------+3 rows in set (0.00 sec)\n注意：对于set来说，如果插入的值为重复的，则只取一个，如果插入了不按顺序排列值，则自动按顺序插入。\n1.4 二进制字符串类型\n\n\n\n类型名称\n说明\n\n\n\n\nBIT(M)\n位字段类型 约(M+7)/8字节\n\n\nBINARY(M)\n固定长度二进制字符串 M字节\n\n\nVARBINARY(M)\n可变长度二进制字符串 M+1字节\n\n\nTINYBLOB(M)\n非常小的BLOB L+1字节，L&lt;2^8\n\n\nBLOB(M)\n小BLOB L+2字节 L&lt;2^16\n\n\nMEDIUMBLOB(M)\n中等大小的BLOB L+3字节，L&lt;2^24\n\n\nLONGBLOB(M)\n大BLOB L+4字节 ，L&lt;2^32\n\n\n\nBLOB 数据类型以随机存取块（称为智能大对象空间）的形式存储任何种类的二进制数据。\n二进制数据通常由已保存的电子表格、程序装入模块和数字化声音模式等等组成。\n数据库服务器不会对 BLOB 列的内容进行解释。\n","tags":["MySQL基础"]},{"title":"13.MySQL用户管理","url":"/article/Database-MySQL-Base-13-MySQL%E4%B9%8B%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E5%85%A5%E9%97%A8/","content":"1.概述\n1.1 多用户数据库\nMySQL是一个多用户数据库，按用户种类分类的话可以分为：\n\n\nROOT用户：超级管理员，拥有所有权限\n\n\n普通用户：被root用户创建的用户，它的权限被root授予\n\n\n1.2 什么是用户管理？\n简单来说，就是root用户管理普通用户的访问权限和信息以及管理root自身特性\n1.3 什么是权限表？\n说到如何管理用户的权限，我们必须要了解权限表：\nMySQL服务器通过权限表来控制用户对它的访问，它存放于MySQL自带的名为mysql的数据库中，权限表有多个，分别有：\n\n\n\n表名\n表描述\n存储的主要数据\n\n\n\n\nuser\n用户表\n用户存储用户信息\n\n\ndb\n数据库管理表\n管理数据库的操作权限\n\n\nhost\n/\n该表已删除\n\n\ntable_priv\n表权限表\n表权限数据\n\n\ncolumns_priv\n对列设置操作权限\n列权限数据\n\n\nprocs_priv\n对存储过程和存储函数设置操作权限\n存储过程权限数据\n\n\n\n1.3.1 user表\nuser表位于mysql库中：\nmysql&gt; use mysql;Database changedmysql&gt; desc user;+--------------------------+-----------------------------------+------+-----+-----------------------+-------+| Field                    | Type                              | Null | Key | Default               | Extra |+--------------------------+-----------------------------------+------+-----+-----------------------+-------+| Host                     | char(255)                         | NO   | PRI |                       |       || User                     | char(32)                          | NO   | PRI |                       |       || Select_priv              | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Insert_priv              | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Update_priv              | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Delete_priv              | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Create_priv              | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Drop_priv                | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Reload_priv              | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Shutdown_priv            | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Process_priv             | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || File_priv                | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Grant_priv               | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || References_priv          | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Index_priv               | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Alter_priv               | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Show_db_priv             | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Super_priv               | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Create_tmp_table_priv    | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Lock_tables_priv         | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Execute_priv             | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Repl_slave_priv          | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Repl_client_priv         | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Create_view_priv         | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Show_view_priv           | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Create_routine_priv      | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Alter_routine_priv       | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Create_user_priv         | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Event_priv               | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Trigger_priv             | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Create_tablespace_priv   | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || ssl_type                 | enum(&#x27;&#x27;,&#x27;ANY&#x27;,&#x27;X509&#x27;,&#x27;SPECIFIED&#x27;) | NO   |     |                       |       || ssl_cipher               | blob                              | NO   |     | NULL                  |       || x509_issuer              | blob                              | NO   |     | NULL                  |       || x509_subject             | blob                              | NO   |     | NULL                  |       || max_questions            | int unsigned                      | NO   |     | 0                     |       || max_updates              | int unsigned                      | NO   |     | 0                     |       || max_connections          | int unsigned                      | NO   |     | 0                     |       || max_user_connections     | int unsigned                      | NO   |     | 0                     |       || plugin                   | char(64)                          | NO   |     | caching_sha2_password |       || authentication_string    | text                              | YES  |     | NULL                  |       || password_expired         | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || password_last_changed    | timestamp                         | YES  |     | NULL                  |       || password_lifetime        | smallint unsigned                 | YES  |     | NULL                  |       || account_locked           | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Create_role_priv         | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Drop_role_priv           | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | NO   |     | N                     |       || Password_reuse_history   | smallint unsigned                 | YES  |     | NULL                  |       || Password_reuse_time      | smallint unsigned                 | YES  |     | NULL                  |       || Password_require_current | enum(&#x27;N&#x27;,&#x27;Y&#x27;)                     | YES  |     | NULL                  |       || User_attributes          | json                              | YES  |     | NULL                  |       |+--------------------------+-----------------------------------+------+-----+-----------------------+-------+51 rows in set (0.00 sec)\n它的字段可分为四类：\n\n用户列：host字段（主机名），user字段（用户名），authentication_string（密码）字段。\n\n只有这三个字段都匹配时，才允许客户端和服务端连接建立\nmysql&gt; select host,user,authentication_string from user;+-----------+------------------+------------------------------------------------------------------------+| host      | user             | authentication_string                                                  |+-----------+------------------+------------------------------------------------------------------------+| localhost | mysql.infoschema | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED || localhost | mysql.session    | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED || localhost | mysql.sys        | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED |)XfyK:4YboCI02nn94SoNqcZhUXlStK.yvJ73Dj5zM/S1qEfA4 |+-----------+------------------+------------------------------------------------------------------------+\n\n\n权限列：它的字段决定了用户的权限，普通权限用于操作数据库，高级权限用于数据库管理。\n\n\n安全列：其中有6个字段 两个 SSL相关的用于加密，两个X509相关的用于标识用户，两个授权插件用于验证用户身份\n\n\n资源控制列：4个字段:\n\n\nmax_questions(用户每小时允许执行的查询操作次数)，\n\n\nmax_updates(用户每小时允许的执行更新的次数)，\n\n\nmax_connections(用户每小时允许的执行的连接操作次数)，\n\n\nmax_user_connections(用户允许同时建立的连接次数)\n\n\n\n\nmysql&gt; select max_questions,max_updates,max_connections,max_user_connections from user where user = &#x27;root&#x27;;+---------------+-------------+-----------------+----------------------+| max_questions | max_updates | max_connections | max_user_connections |+---------------+-------------+-----------------+----------------------+|             0 |           0 |               0 |                    0 |+---------------+-------------+-----------------+----------------------+1 row in set (0.00 sec)\n1.3.2 db表和host表\ndb表中存储了用户对某个数据库的操作权限，决定用户能从那个主机存取那个数据库。\nmysql&gt; desc db;+-----------------------+---------------+------+-----+---------+-------+| Field                 | Type          | Null | Key | Default | Extra |+-----------------------+---------------+------+-----+---------+-------+| Host                  | char(255)     | NO   | PRI |         |       || Db                    | char(64)      | NO   | PRI |         |       || User                  | char(32)      | NO   | PRI |         |       || Select_priv           | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N       |       || Insert_priv           | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N       |       || Update_priv           | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N       |       || Delete_priv           | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N       |       || Create_priv           | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N       |       || Drop_priv             | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N       |       || Grant_priv            | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N       |       || References_priv       | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N       |       || Index_priv            | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N       |       || Alter_priv            | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N       |       || Create_tmp_table_priv | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N       |       || Lock_tables_priv      | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N       |       || Create_view_priv      | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N       |       || Show_view_priv        | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N       |       || Create_routine_priv   | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N       |       || Alter_routine_priv    | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N       |       || Execute_priv          | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N       |       || Event_priv            | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N       |       || Trigger_priv          | enum(&#x27;N&#x27;,&#x27;Y&#x27;) | NO   |     | N       |       |+-----------------------+---------------+------+-----+---------+-------+\nhost表中存储了某个主机对某个数据库的操作权限，配合db权限表，对给定主机上数据库级操作权限做更细致的控制**（mysql8中host表已经没有了）**\n在MySQL5.6.7中删除了mysql.host表\n注意：user表中的权限是针对所有数据库的，如果希望用户只对某个数据库有操作权限，那么需要将user表中对应的权限设置为N，然后再db表中设置对应权限\n1.3.3 columns_priv表\n对列设置操作权限\nmysql&gt; desc columns_priv;+-------------+----------------------------------------------+------+-----+-------------------+-----------------------------------------------+| Field       | Type                                         | Null | Key | Default           | Extra                                         |+-------------+----------------------------------------------+------+-----+-------------------+-----------------------------------------------+| Host        | char(255)                                    | NO   | PRI |                   |                                               || Db          | char(64)                                     | NO   | PRI |                   |                                               || User        | char(32)                                     | NO   | PRI |                   |                                               || Table_name  | char(64)                                     | NO   | PRI |                   |                                               || Column_name | char(64)                                     | NO   | PRI |                   |                                               || Timestamp   | timestamp                                    | NO   |     | CURRENT_TIMESTAMP | DEFAULT_GENERATED on update CURRENT_TIMESTAMP || Column_priv | set(&#x27;Select&#x27;,&#x27;Insert&#x27;,&#x27;Update&#x27;,&#x27;References&#x27;) | NO   |     |                   |                                               |+-------------+----------------------------------------------+------+-----+-------------------+-----------------------------------------------+\n1.3.4 procs_priv表\n对存储过程和存储函数设置操作权限\nmysql&gt; desc procs_priv;+--------------+----------------------------------------+------+-----+-------------------+-----------------------------------------------+| Field        | Type                                   | Null | Key | Default           | Extra                                         |+--------------+----------------------------------------+------+-----+-------------------+-----------------------------------------------+| Host         | char(255)                              | NO   | PRI |                   |                                               || Db           | char(64)                               | NO   | PRI |                   |                                               || User         | char(32)                               | NO   | PRI |                   |                                               || Routine_name | char(64)                               | NO   | PRI |                   |                                               || Routine_type | enum(&#x27;FUNCTION&#x27;,&#x27;PROCEDURE&#x27;,&#x27;LIBRARY&#x27;) | NO   | PRI | NULL              |                                               || Grantor      | varchar(288)                           | NO   | MUL |                   |                                               || Proc_priv    | set(&#x27;Execute&#x27;,&#x27;Alter Routine&#x27;,&#x27;Grant&#x27;) | NO   |     |                   |                                               || Timestamp    | timestamp                              | NO   |     | CURRENT_TIMESTAMP | DEFAULT_GENERATED on update CURRENT_TIMESTAMP |+--------------+----------------------------------------+------+-----+-------------------+-----------------------------------------------+\n1.3.5 tables_priv表\nmysql&gt; desc tables_priv;+-------------+-----------------------------------------------------------------------------------------------------------------------------------+------+-----+-------------------+-----------------------------------------------+| Field       | Type                                                                                                                              | Null | Key | Default           | Extra                                         |+-------------+-----------------------------------------------------------------------------------------------------------------------------------+------+-----+-------------------+-----------------------------------------------+| Host        | char(255)                                                                                                                         | NO   | PRI |                   |                                               || Db          | char(64)                                                                                                                          | NO   | PRI |                   |                                               || User        | char(32)                                                                                                                          | NO   | PRI |                   |                                               || Table_name  | char(64)                                                                                                                          | NO   | PRI |                   |                                               || Grantor     | varchar(288)                                                                                                                      | NO   | MUL |                   |                                               || Timestamp   | timestamp                                                                                                                         | NO   |     | CURRENT_TIMESTAMP | DEFAULT_GENERATED on update CURRENT_TIMESTAMP || Table_priv  | set(&#x27;Select&#x27;,&#x27;Insert&#x27;,&#x27;Update&#x27;,&#x27;Delete&#x27;,&#x27;Create&#x27;,&#x27;Drop&#x27;,&#x27;Grant&#x27;,&#x27;References&#x27;,&#x27;Index&#x27;,&#x27;Alter&#x27;,&#x27;Create View&#x27;,&#x27;Show view&#x27;,&#x27;Trigger&#x27;) | NO   |     |                   |                                               || Column_priv | set(&#x27;Select&#x27;,&#x27;Insert&#x27;,&#x27;Update&#x27;,&#x27;References&#x27;)                                                                                      | NO   |     |                   |                                               |+-------------+-----------------------------------------------------------------------------------------------------------------------------------+------+-----+-------------------+-----------------------------------------------+8 rows in set (0.00 sec)\n2.用户管理操作命令\n2.1 创建普通用户\n创建一个名为 app_user 的用户，只允许从本地登录\nCREATE USER &#x27;app_user&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;SecurePwd123!&#x27;;\nmysql&gt; CREATE USER &#x27;app_user&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;SecurePwd123!&#x27;;Query OK, 0 rows affected (0.01 sec)mysql&gt; select user from user;+------------------+| user             |+------------------+| app_user         || mysql.infoschema || mysql.session    || mysql.sys        || root             |+------------------+\n2.2 重命名一个用户账号\nRENAME USER &#x27;app_user&#x27;@&#x27;localhost&#x27; TO &#x27;yanjiadou&#x27;@&#x27;localhost&#x27;;\nmysql&gt; RENAME USER &#x27;app_user&#x27;@&#x27;localhost&#x27; TO &#x27;yanjiadou&#x27;@&#x27;localhost&#x27;;Query OK, 0 rows affected (0.00 sec)mysql&gt; select user from user;+------------------+| user             |+------------------+| mysql.infoschema || mysql.session    || mysql.sys        || root             || yanjiadou        |+------------------+5 rows in set (0.00 sec)\n2.3 删除用户账号\nDROP USER &#x27;yanjiadou&#x27;@&#x27;localhost&#x27;;\nmysql&gt; DROP USER &#x27;yanjiadou&#x27;@&#x27;localhost&#x27;;Query OK, 0 rows affected (0.00 sec)mysql&gt; select user from user;+------------------+| user             |+------------------+| mysql.infoschema || mysql.session    || mysql.sys        || root             |+------------------+4 rows in set (0.00 sec)\n2.4 查看用户的访问权限\nSHOW GRANTS FOR  &#x27;app_user&#x27;@&#x27;localhost&#x27;;\nmysql&gt; SHOW GRANTS FOR  &#x27;app_user&#x27;@&#x27;localhost&#x27;;+----------------------------------------------+| Grants for app_user@localhost                |+----------------------------------------------+| GRANT USAGE ON *.* TO `app_user`@`localhost` |+----------------------------------------------+1 row in set (0.00 sec)\n输出结果显示用户ben有一个权限 USAGE ON . ，这个表示没有任何权限。\n2.5 给用户设置相应的权限\nGRANT SELECT ON dev_smart_library.* TO &#x27;app_user&#x27;@&#x27;localhost&#x27;;\n这表示app_user用户可以在数据库dev_smart_library中进行查询操作\nmysql&gt; GRANT SELECT ON dev_smart_library.* TO &#x27;app_user&#x27;@&#x27;localhost&#x27;;Query OK, 0 rows affected (0.00 sec)mysql&gt; SHOW GRANTS FOR  &#x27;app_user&#x27;@&#x27;localhost&#x27;;+-----------------------------------------------------------------+| Grants for app_user@localhost                                   |+-----------------------------------------------------------------+| GRANT USAGE ON *.* TO `app_user`@`localhost`                    || GRANT SELECT ON `dev_smart_library`.* TO `app_user`@`localhost` |+-----------------------------------------------------------------+2 rows in set (0.00 sec)\n2.6 撤销权限\nREVOKE SELECT|UPDATE|INSERT|DELETE ON database.* FROM &#x27;app_user&#x27;@&#x27;localhost&#x27;;\nmysql&gt; REVOKE SELECT ON dev_smart_library.* FROM &#x27;app_user&#x27;@&#x27;localhost&#x27;;Query OK, 0 rows affected (0.01 sec)mysql&gt; SHOW GRANTS FOR  &#x27;app_user&#x27;@&#x27;localhost&#x27;;+----------------------------------------------+| Grants for app_user@localhost                |+----------------------------------------------+| GRANT USAGE ON *.* TO `app_user`@`localhost` |+----------------------------------------------+1 row in set (0.00 sec)\n2.7 更改口令\nALTER USER &#x27;app_user&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH caching_sha2_password BY &#x27;Your_password_123!&#x27;;\nmysql&gt; ALTER USER &#x27;app_user&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH caching_sha2_password BY &#x27;Your_password_123!&#x27;;Query OK, 0 rows affected (0.00 sec)\n更详细的信息请查询相关文档。\n","tags":["MySQL基础"]},{"title":"14.数据备份和恢复","url":"/article/Database-MySQL-Base-14-MySQL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/","content":"1.数据备份\n1.1.使用Mysqldump命令备份\n如果你之前和我一样使用的是MySQL自带的命令行的话，因为这个数据备份需要在cmd上进行，所以我们需要将mysql/bin的目录设置到环境变量中：\n\n然后打开cmd：\n\n如果仍然出现找不到命令，你可以试试关闭cmd重新打开试试。\n接下来按照下面的内容进行就可以了：\n如果出现拒绝访问的情况，我们可以试试以管理员是身份来打开cmd进行操作。\n1.1 备份单个数据库\nmysqldump -hhost -uroot -ppassword --single-transaction --quick dbname &gt; /opt/backup.sql\n参数：\n–single-transaction 备份的时候不锁表\n–quick 备份的时候一行一行读取\n\n上面的命令要做的是将mysql中名为study的数据库备份，并且放在后面的文件目录中，这个命令会在mysql备份文件夹中生成一个名为study.sql的文件：\n\n1.2 备份指定数据库中的数据表\n\n1.3 同时备份多个数据库\n\n上面的语句同时备份study数据库和jdbc数据库\n1.4 备份所有数据库\n\n2.数据恢复\n一般来说很简单：\n\n\n1.首先登录mysql\n\n\n2.然后执行 source 目标文件路径 即可\n\n\n\n","tags":["MySQL基础"]},{"title":"15.MySQL数据库优化入门","url":"/article/Database-MySQL-Base-15-MySQL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%BC%98%E5%8C%96%E5%85%A5%E9%97%A8/","content":"一.了解MySQL的优化\nMySQL优化：\n\n\n一方面系统出现瓶颈了，需要提高MySQL数据库整体的性能，这个时期的优化一般在开发完成后并使用了一段时间进行的。\n\n\n另一方面需要合理的结构设计和参数调整，节省系统资源，这个时期的优化一般在开发期完成的，这时项目还没投入使用。\n\n\nMySQL的优化原则是：减少系统瓶颈，节省资源，提高系统反应速度。例如通过优化文件系统提高磁盘I\\O的读写速度 ， 通过优化操作系统的调度策略来提高MySQL在高负荷情况下的负载能力， 优化表结构，索引，查询语句来提高响应速度\n\n\n二.学习一些常用的优化技术\n1.优化操作预备命令学习\n1.1 查询服务器指定指标的数据\nSHOW STATUS LIKE &#x27;value&#x27;;\n其中的value是要查询的参数值，常用的有：\nConnections    连接服务器的次数Uptime         MySQL服务器的上线时间Slow_queries   慢查询的次数Com_select     查询操作的次数Com_insert     插入操作的次数Com_update     更新操作的次数Com_delete     删除操作的次数\n例如：（不区分大小写）\n\n1.2 MySQL中还提供了EXPLAIN语句和DESC语句来分析查询语句指标\n例如：\n\n\n\nid: SELECT识别符，这是SELECT的查询序号。\n\n\nselect_type: 它表示EXPLAIN 后查询语句的类型，SIMPLE表示简单查询（就是不包括连接查询和子查询的查询），PRIMARY表示主查询，还有许多类型以后遇到再了解。\n\n\ntable: 表示查询的表。\n\n\ntype：表示表的连接类型，这里的ALL表示进行完整的表扫描来查找，ALL连接通常最为糟糕，所以我们要尽量通过索引来避免。\n\n\npossible_keys:指出MySQL能使用那个索引在该表中找到行，这里为NULL说明没有相关索引。\n\n\nkey: 表示查询实际使用到的索引，如果没有选择，则为NULL。\n\n\nkey_len: 表示MySQL选择的索引字段按字节计算的长度。\n\n\nref：表示使用哪个列或常数与索引一起来查询记录。\n\n\nrows： 表示MySQL在表中的查询必须检查的行数。\n\n\nExtra: 表示MySQL在处理查询时的详细信息。\n\n\n相对于EXPLAIN语句，DESCRIBE语句更为简洁（直接用desc代替即可）：\n\n2.索引优化技术\n我们可以对表添加合理的索引来提高性能。\n\n\n索引可以提高查询速度，但不是使用带有索引的字段查询时都会起作用，使用索引有几种特殊的情况，在这些情况下有可能使用带有索引的字段查询时并没有起作用：\n\n\n使用LIKE关键字的查询语句：\n在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为 % ，这时索引不会起作用。只有 % 不在第一个位置，索引才会起作用。\n\n\n使用多列索引的查询语句：\n只有遵循最左原则索引才生效。\n\n\n使用OR关键字的查询语句\n查询语句中的查询条件中只有OR关键字，且OR前后两个条件的列都是索引列时，查询索引才生效，否则索引不生效。\n\n\n3.优化子查询\n我们都知道子查询虽然方便，但是它的执行效率不高，执行子查询时，MySQL需要为内层查询语句的查询结果建立一个临时表，然后外层查询语句从临时表中查询记录，查询完毕后，再撤销这些临时表，所以子查询的速度会比一般的慢。\n在MySQL中，我们可以使用连接（JOIN）查询来代替子查询，因为连接查询不会建立临时表。\n4.优化数据库结构\n一个好的数据库设计方案对于数据库的性能影响非常大。合理的数据库结构设计能使执行效率最大化。数据库结构的设计需要考虑数据冗余，查询和更新的速度，字段的数据类型是否合理等。\n下面是一些优化数据库结构的方法：\n\n\n将字段很多的表分解成多个表\n对于字段较多的表，如果有有些字段的使用频率很低，可以将这些字段分离出来形成新表。\n因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。\n\n\n增加中间表\n对于需要经常联合查询的表，可以建立中间表以提高查询效率。\n通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询，这样提高了查询速度。\n\n\n增加冗余字段\n我们学习了在设计数据库表时应该尽量遵循范式理论的规约，尽可能减少冗余字段，让数据库设计看起来精致，优雅，但是，合理地加入冗余字段可以提高查询速度。\n\n\n优化插入记录的速度\n插入记录时，影响插入速度的主要是索引，唯一性校验，一次插入记录条数等。根据这些情况，我们可以分别进行优化：\n\n\n禁用索引：对于非空表，插入记录时，MySQL会根据表的索引对插入的记录建立索引，如果插入大量数据，建立索引会降低插入记录的速度，为了解决这种情况，我们可以在插入记录之前禁用索引，数据插入完毕后再开启索引。\n禁用和开启索引的语句如下：\nALTER TABLE table_name DISABLE KEYS;//禁用索引 ALTER TABLE table_name ENABLE KEYS;//开启索引\n\n\n唯一性检查：插入数据时，MySQL会对插入的记录进行唯一性校验，这种校验也会降低插入记录的速度，同理，我们也可以通过禁用唯一性校验来加快速度：\n\n\nSET UNIQUE_CHECKS=0;//禁用唯一性校验 SET UNIQUE_CHECKS=1;//开启唯一性校验 \n\n\n使用批量插入\n插入多条记录时，可以使用一条INSERT语句插入一条语句，可以使用INSERT语句插入多条记录\n显然，后者速度会更快：  INSERT INTO table_name VALUES (key1,key2,key3,key4), (key1,key2,key3,key4), (key1,key2,key3,key4), (key1,key2,key3,key4);\n\n\n使用LOAD DATA INFILE批量导入\n当需要批量导入时，如果能用这条语句，尽量使用，因为这条语句的执行效率再导入批量数据时比INSERT高。\n对于InnoDB引擎的表，常见的优化方法如下：\n\n\n禁用外键检查： SET foreign_key_checks=0;//禁用 SET foreign_key_checks=1;//开启\n\n\n禁止自动提交：SET autocommit=0;//禁止SET autocommit=1;//开启\n\n\n\n\n5.分析表，检查表和优化表\nMySQL提供了分析表，检查表和优化表的语句。\n5.1 分析表主要是分析关键字的分布：\n\n\nOp: 表示执行的操作，analyze表示进行分析操作。\nMsg_type:表示信息类型，通常是 status , info ,note, warning,error之一。\nMsg_text:显示信息。\n\n5.2 检查表\nMySQL可以使用CHECK TABLE语句来检查表，它可以检查表是否存在错误。\n5.3优化表\nMySQL中使用OPTIMIZE TABLE语句来优化表，但是这个语句只能优化表中VARCHAR,BLOB,TEXT类型的字段。\n上面的学习只是大概的了解MySQL优化技术，想要掌握还需要深入学习。\n","tags":["MySQL基础"]}]