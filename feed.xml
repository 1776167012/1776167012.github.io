<feed xmlns="http://www.w3.org/2005/Atom" xmlns:webfeeds="http://webfeeds.org/rss/1.0">
    <title>牧之</title>
    
    <icon>https://1776167012.github.io/img/logo.png</icon>
     
    <link href="https://1776167012.github.io/feed.xml" rel="self" />
    
    <link href="https://tyzhang.top/" rel="hub" />
    
    <link href="https://1776167012.github.io/" />
    <updated>2026-01-12T08:22:55.412Z</updated>
    <id>https://1776167012.github.io/</id>
    
    <author>
        <name>muzhi</name>
        
        <email>your-email</email>
        
    </author>
    
    <generator uri="https://hexo.io/">Hexo</generator>
    <webfeeds:cover image="https://cdn.jsdelivr.net/gh/hayschan/static@master/2020/12/gFn7zm.JPG" />
    <webfeeds:icon>https://cdn.jsdelivr.net/gh/hayschan/static@master/2020/12/VAlBPs.png</webfeeds:icon>
    <webfeeds:logo>https://cdn.jsdelivr.net/gh/hayschan/static@master/2020/12/XDzm9G.svg</webfeeds:logo>
    <webfeeds:accentColor>0abab5</webfeeds:accentColor>
    <webfeeds:related layout="card" target="browser" />
    
    <entry>
        <title>我的个人项目</title>
        <link href="https://1776167012.github.io/article/projectInfo/" />
        <id>https://1776167012.github.io/article/projectInfo/</id>
        <published>2026-01-12T04:03:32.000Z</published>
        <updated>2026-01-12T08:22:55.412Z
        </updated>
        
        <content type="html">
            <![CDATA[ <p>欢迎参观我的小项目</p><h1><span id="1-钻山打字通">1. 钻山打字通</span></h1><p>这是在github上fork的一个基础项目，在此基础上新增了音乐播放功能,修复了已知的一些bug且,重构了一些项目代码。</p><p>Java编写的一款简易的打字练习软件</p><p>软件截图：<br><img src="typing.png" alt="打字通"></p><p><a href="https://gitee.com/yan-jiadou/drilling-and-typing/tree/master/">代码仓库地址</a></p><h1><span id="2-智能图书馆系统">2. 智能图书馆系统</span></h1><p>系统截图：</p><p><img src="book_mamage2.png" alt="img.png"></p><p>SSM+MySQL+JQuery+tensorflow 编写的带有推荐算法的智能推荐图书馆管理系统</p><p><a href="https://gitee.com/yan-jiadou/smart-library-front-end/tree/feat-01-initProject-yanjd/">代码仓库地址</a></p><h1><span id="3-车厢装载模型自动生成算法">3. 车厢装载模型自动生成算法</span></h1><p>算法效果截图：<br><img src="putModel.png" alt="img.png"></p><p>Java编写的应用于车厢装载货物的模型生成算法, 目标是使机器自动装载货车空间达到最大利用率。</p><p><a href="https://gitee.com/yan-jiadou/put-model">代码仓库地址</a></p><h1><span id="4-waterframework">4. WaterFramework</span></h1><p>Java编写的简易版后台开发框架,实现了IOC,AOP等特性,提供了ORM映射服务.</p><p><a href="https://gitee.com/yan-jiadou/water-framework">代码仓库地址</a></p><h1><span id="5-语音助手">5. 语音助手</span></h1><p>Java编写的一个语音助手应用, 接入了ASR , TTS , NLP 达到一个实时对话的语音助手应用<br><a href="https://gitee.com/yan-jiadou/voice-assistant">代码仓库地址</a></p> ]]>
        </content>
           
        <summary type="html">&lt;p&gt;欢迎参观我的小项目&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;1-钻山打字通&quot;&gt;1. 钻山打字通&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;这是在github上fork的一个基础项目，在此基础上新增了音乐播放功能,修复了已知的一些bug且,重构了一些项目代码。&lt;/p&gt;
&lt;p&gt;Java编写的一</summary>
            
        <category term="个人项目" scheme="https://1776167012.github.io/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/" />
        
    </entry>
    
    <entry>
        <title>事务隔离级别</title>
        <link href="https://1776167012.github.io/article/databases-mysql-24-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/" />
        <id>https://1776167012.github.io/article/databases-mysql-24-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
        <published>2026-01-11T16:00:00.000Z</published>
        <updated>2026-01-12T03:39:10.940Z
        </updated>
        
        <content type="html">
            <![CDATA[ <p>AID的目的就是C(一致性)</p><p>ANSI SQL标准定义的四个隔离级别分别为：</p><ul><li><p>READ UNCOMMITTED 读未提交：就是不同事务之间所有状态下对数据是完全相互可见的，事务B可以见到事务A对某张表做的任何操作，在这种隔离性下的安全性非常低。</p></li><li><p>READ COMMITTED 读已提交：事务A只能看到事务B提交后的操作。这种隔离级别下的安全性相比前者好一点。</p></li><li><p>REPEATABLE READ 可重复读：目前MySQL InnoDB默认的事务隔离级别。</p></li><li><p>SERIALIZABLE 串行化：安全级别最大，但性能上会有损失，由于可重复读已经达到3°隔离，所以本地事务一般不用这个隔离级别，串行化的隔离级别主要用于innoDB的分布式事务中。</p></li></ul><h2><span id="1不同事务隔离级别对锁的支持">1.不同事务隔离级别对锁的支持</span></h2><h3><span id="11-读未提交脏读">1.1 读未提交（脏读）</span></h3><p>查询数据时不加锁，更新数据也不加锁，正因为这样，其他事务之间才能做到读未提交。</p><h3><span id="12-读已提交不可重复读">1.2 读已提交（不可重复读）</span></h3><p>在读已提交隔离级别下，数据的读写添加了行级锁，除了唯一性的约束检查以及外键约束的检查需要Gap Lock（间隙锁），其他情况下InnoDB存储引擎不会使用Gap Lock锁。</p><h3><span id="13-可重复读">1.3 可重复读</span></h3><p>查询数据时，使用Next-key Lock锁避免幻读(多读)情况。</p><h3><span id="14-串行化">1.4 串行化</span></h3><p>在串行化的隔离级别下，InnoDB会对每个查询语句后自动加上 LOCK IN SHARE MODE（共享锁）。</p><h2><span id="2不同事务隔离级别的优缺点">2.不同事务隔离级别的优缺点</span></h2><h3><span id="1读未提交脏读">1）读未提交（脏读）</span></h3><p>优点：暂时没有<br>缺点：由于事务中的修改对其他事务都是可见的，所以事务可以读取未提交的数据，如果那些未提交的数据最后回滚了，那么读到的数据就是脏数据，这会导致很多问题。</p><h3><span id="2读已提交">2）读已提交</span></h3><p>优点：相比于读未提交，它防止了脏读<br>缺点：虽然防止了脏读，但是，它无法避免一致性冲突问题，由于在读已提交隔离性下，一个事务开始时，只能看见已经提交的事务所做的修改<br>所以同一个事务执行两次相同的查询时会发生两次查询的结果不一致的情况。</p><h3><span id="3可重复读">3）可重复读</span></h3><p>优点：防止脏读，一致性冲突问题<br>缺点：虽然防止了一致性冲突，但是它无法防止下面的情况：同一个事务中第一次查询时，符合条件的数据有2条，过了一段时间，其他事务插入了一条相同查询条件的数据并提交了，<br>那么当再次查询时，会查到三条数据，这显然是不对的（幻读）。<br>注意：但MySQL的InnoDB存储引擎通过MVCC防止了幻读的产生，所以在MySQL中，可重复读已经完全具备ACID特性。</p><h3><span id="4串行化">4）串行化</span></h3><p>优点：最高的事务隔离级别，安全性最高<br>缺点：串行化下的事务会在读取的每一行数据上都加锁，这会导致开销相比前面而言增大了许多。</p><p>下面的图可帮助理解（但和MySQL的隔离界别有一点差别的）：</p><p>3.相关操作语句<br>1）在InnoDB存储引擎中，可以使用下面命令来设置当前会话或全局的事务隔离级别：<br>SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL<br>READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE<br>2) 查询数据库当前的事务隔离级别<br>SELECT @@tx_isolation \G;//查看当前会话隔离级别<br>SELECT @@global.tx_isolation \G;//查看全局事务隔离级别</p><p>4.上面提到的锁的知识<br>1）间隙锁<br>简单来说过，间隙锁其实就是对范围内的数据进行加锁来防止出现幻读的情况。</p><p>2）Next-key Lock锁<br>他其实是间隙锁和行级锁的合称，它对应两种情况：<br>当进行范围查询时，使用间隙锁进行锁定范围数据。<br>当进行索引等值查询时，使用行级锁锁定数据。</p> ]]>
        </content>
           
        <summary type="html">&lt;p&gt;AID的目的就是C(一致性)&lt;/p&gt;
&lt;p&gt;ANSI SQL标准定义的四个隔离级别分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;READ UNCOMMITTED 读未提交：就是不同事务之间所有状态下对数据是完全相互可见的，事务B可以见到事务A对某张表做的任何操作，在这种隔离性</summary>
            
        <category term="MySQL" scheme="https://1776167012.github.io/tags/MySQL/" />
        
    </entry>
    
    <entry>
        <title>Docker安装以及验证</title>
        <link href="https://1776167012.github.io/article/Linux%E8%BF%90%E7%BB%B4%E7%9B%B8%E5%85%B3-docker-1-Docker%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E9%AA%8C%E8%AF%81/" />
        <id>https://1776167012.github.io/article/Linux%E8%BF%90%E7%BB%B4%E7%9B%B8%E5%85%B3-docker-1-Docker%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E9%AA%8C%E8%AF%81/</id>
        <published>2023-06-09T03:20:02.000Z</published>
        <updated>2026-01-05T03:33:15.912Z
        </updated>
        
        <content type="html">
            <![CDATA[ <p>1.CentOS 8.0 安装docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure><p>2.安装完成后，启动docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl start docker</span></span><br></pre></td></tr></table></figure><p>3.启动完成后进行验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker run hello-world</span></span><br></pre></td></tr></table></figure><p>4.添加镜像加速器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://n6syp70m.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure><p>5.卸载docker</p><p>删除安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker-ce</span><br></pre></td></tr></table></figure><p>删除镜像，容器，配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure><h2><span id="docker-常用命令">docker 常用命令</span></h2><h3><span id="查看docker中已经存在的镜像">查看docker中已经存在的镜像</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><h3><span id="拉取镜像">拉取镜像</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// pull后面的参数规则是软件名称:版本号</span><br><span class="line">docker image pull ubuntu:18.04</span><br></pre></td></tr></table></figure><h3><span id="从镜像仓库中查找镜像">从镜像仓库中查找镜像</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search 镜像名称</span><br></pre></td></tr></table></figure><h3><span id="设置镜像标签">设置镜像标签</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag 860c279d2fec runoob/centos:dev</span><br></pre></td></tr></table></figure><h3><span id="删除镜像删除镜像前确保该镜像的所有容器以及删除">删除镜像（删除镜像前确保该镜像的所有容器以及删除）</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像名称</span><br></pre></td></tr></table></figure><h3><span id="从镜像来启动并进入容器">从镜像来启动并进入容器</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -it ubuntu:18.04 /bin/bash</span><br></pre></td></tr></table></figure><h3><span id="启动已经停止的容器">启动已经停止的容器</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start id</span><br></pre></td></tr></table></figure><h3><span id="重启容器">重启容器</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart 容器id</span><br></pre></td></tr></table></figure><h3><span id="启动容器后台运行">启动容器后台运行</span></h3><p>docker run -itd --name 容器名称 镜像名称 /bin/bash</p><h3><span id="退出容器">退出容器</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit 停止容器并退出</span><br><span class="line">Ctrl + PQ 保持容器运行状态并退出</span><br></pre></td></tr></table></figure><h3><span id="查看正在运行的容器">查看正在运行的容器</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><h3><span id="查看所有容器">查看所有容器</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -a</span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><h3><span id="停止并杀死容器">停止并杀死容器</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container stop ID //杀死容器</span><br><span class="line">docker container rm -f ID //删除容器</span><br></pre></td></tr></table></figure><h3><span id="进入容器">进入容器</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器id /bin/bash</span><br></pre></td></tr></table></figure><h4><span id="导入和导出容器">导入和导出容器</span></h4><p>导出容器到指定文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export 容器id &gt; ubuntu.tar</span><br></pre></td></tr></table></figure><p>导入容器快照</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat docker/name.tar | docker import - test/ubuntu:v1</span><br></pre></td></tr></table></figure><p>也可以通过指定URL或者某个目录导入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import http://example.com/examplimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure><h3><span id="导出指定容器的日志">导出指定容器的日志</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs --since=&#x27;2023-06-08T17:00:00&#x27; --until=&#x27;2023-06-08T17:20:00&#x27; containerName &gt;&gt; db/0421.log</span><br></pre></td></tr></table></figure> ]]>
        </content>
           
        <summary type="html">&lt;p&gt;1.CentOS 8.0 安装docker&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;t</summary>
            
        <category term="Docker" scheme="https://1776167012.github.io/tags/Docker/" />
        
    </entry>
    
    <entry>
        <title>docker日志清理</title>
        <link href="https://1776167012.github.io/article/Linux%E8%BF%90%E7%BB%B4%E7%9B%B8%E5%85%B3-docker-3-docker%E6%97%A5%E5%BF%97%E6%B8%85%E7%90%86/" />
        <id>https://1776167012.github.io/article/Linux%E8%BF%90%E7%BB%B4%E7%9B%B8%E5%85%B3-docker-3-docker%E6%97%A5%E5%BF%97%E6%B8%85%E7%90%86/</id>
        <published>2023-06-05T01:38:37.000Z</published>
        <updated>2026-01-05T03:33:15.912Z
        </updated>
        
        <content type="html">
            <![CDATA[ <p>我们可能遇到服务器上磁盘发生占满的清空</p><p>这时,我们可以执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h | sort -h</span><br></pre></td></tr></table></figure><p>我们会看到：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">88M     ./freeswtich/qwfreeswitch/sounds/old_test</span><br><span class="line">104M    ./freeswtich/qwfreeswitch/sounds</span><br><span class="line">138M    ./freeswtich/qwfreeswitch/docker/package/freeswitch/.git/objects</span><br><span class="line">138M    ./freeswtich/qwfreeswitch/docker/package/freeswitch/.git/objects/pack</span><br><span class="line">139M    ./freeswtich/qwfreeswitch/docker/package/freeswitch/.git</span><br><span class="line">152M    ./MRCPServer/asrbaidumrcp/.git/objects/d7</span><br><span class="line">153M    ./MRCPServer/asrbaidumrcp/.git</span><br><span class="line">153M    ./MRCPServer/asrbaidumrcp/.git/objects</span><br><span class="line">153M    ./MRCPServer/asrbaidumrcp/docker</span><br><span class="line">281M    ./freeswtich/qwfreeswitch/docker/package</span><br><span class="line">281M    ./freeswtich/qwfreeswitch/docker/package/freeswitch</span><br><span class="line">282M    ./freeswtich/qwfreeswitch/docker</span><br><span class="line">316M    ./MRCPServer/asrbaidumrcp</span><br><span class="line">394M    ./freeswtich/qwfreeswitch</span><br><span class="line">580M    ./glibc-2.28/build</span><br><span class="line">624M    ./freeswtich</span><br><span class="line">828M    ./glibc-2.28</span><br><span class="line">965M    ./MRCPServer</span><br><span class="line">3.0G    .</span><br><span class="line">[root@ecs-235046 ~]# ^C</span><br><span class="line">[root@ecs-235046 ~]# </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后可能会分析出是docker的日志占用的大部分空间,我们需要释放这些空间,但是又不能停止docker</p><p>这时候,我们则需要这个命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/null &gt; 指定的日志文件-json.log</span><br></pre></td></tr></table></figure><p>这个命令有效,但是,每次都要手动的做,不免有些麻烦。</p><p>于是，我们可以使用shell+cron来定时的清理那些占用空间的日志：</p><p>我们先来学习下这个脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">echo &quot;======== docker containers logs file size ========&quot;  </span><br><span class="line"></span><br><span class="line">logs=$(find /var/lib/docker/containers/ -name *-json.log)  </span><br><span class="line"></span><br><span class="line">for log in $logs  </span><br><span class="line">        do  </span><br><span class="line">             ls -lh $log   </span><br><span class="line">        done  </span><br></pre></td></tr></table></figure><p>这个脚本打印出所有容器每个日志占用的空间。</p><p>下面学习下面脚本：</p><p>我们可以使用下面的脚本来清理七天前的日志：<br>新建脚本docker_log_clean.sh<br>,内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">限定作用目录</span></span><br><span class="line">DOCKER_LOG_DIR=&quot;/var/lib/docker/containers&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">时间限定</span></span><br><span class="line">DAYS_TO_KEEP=7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">限定文件后缀</span></span><br><span class="line">LOG_PREFIX=&quot;-json.log.*&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找出最后修改时间超过7天的文件列表</span></span><br><span class="line">logs=$(find $DOCKER_LOG_DIR -name &quot;*$LOG_PREFIX&quot; -type f -mtime +$DAYS_TO_KEEP)</span><br><span class="line"></span><br><span class="line">for log in $logs  </span><br><span class="line">        do  </span><br><span class="line">          ls -lh $log   </span><br><span class="line">          cat /dev/null &gt; $log</span><br><span class="line">          echo &quot;deleted $log&quot;</span><br><span class="line">        done  </span><br></pre></td></tr></table></figure><p>然后：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>在里面添加下面一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 * * * /bin/bash /path/to/docker-log-cleanup.sh</span><br></pre></td></tr></table></figure><p>这里的的 /path/to/docker-log-cleanup.sh 指的是脚本的绝对路径。</p><p>也可以使用下面的脚本只保留5个日志文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span> </span><br><span class="line">echo &quot;======== start clean docker containers logs ========&quot;  </span><br><span class="line"></span><br><span class="line">logs=$(find /var/lib/docker/containers/ -name *-json.log*)  </span><br><span class="line"></span><br><span class="line">for log in $logs  </span><br><span class="line">        do  </span><br><span class="line"></span><br><span class="line">        num=$&#123;log##*.&#125;</span><br><span class="line">if echo &quot;$num&quot; | grep -qE &#x27;^[0-9]+$&#x27; &amp;&amp; [ &quot;$num&quot; -gt 5 ]; then</span><br><span class="line">                 cat /dev/null &gt; $log </span><br><span class="line">        echo &quot;clean logs : $log&quot;</span><br><span class="line"></span><br><span class="line">else echo echo &quot;not clean&quot;</span><br><span class="line">fi</span><br><span class="line">done  </span><br><span class="line">echo &quot;======== end clean docker containers logs ========&quot;</span><br></pre></td></tr></table></figure> ]]>
        </content>
           
        <summary type="html">&lt;p&gt;我们可能遇到服务器上磁盘发生占满的清空&lt;/p&gt;
&lt;p&gt;这时,我们可以执行：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;</summary>
            
        <category term="docker容器" scheme="https://1776167012.github.io/tags/docker%E5%AE%B9%E5%99%A8/" />
        
    </entry>
    
    <entry>
        <title>docker日志清理</title>
        <link href="https://1776167012.github.io/article/Linux%E8%BF%90%E7%BB%B4%E7%9B%B8%E5%85%B3-linux-1-Linux%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4-%E5%BF%AB%E6%8D%B7%E9%94%AE/" />
        <id>https://1776167012.github.io/article/Linux%E8%BF%90%E7%BB%B4%E7%9B%B8%E5%85%B3-linux-1-Linux%E5%85%A5%E9%97%A8%E5%91%BD%E4%BB%A4-%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
        <published>2023-06-05T01:38:37.000Z</published>
        <updated>2026-01-12T03:42:06.121Z
        </updated>
        
        <content type="html">
            <![CDATA[ <h2><span id="1常用命令">1.常用命令</span></h2><p>1.1 创建一个名为file的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file</span><br></pre></td></tr></table></figure><p>1.2 cd 命令 进入指定文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /root</span><br></pre></td></tr></table></figure><p>1.3 pwd 命令 输出当前文件夹路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><p>1.4 ls命令 输出当前文件夹中所有的文件列别奥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><p>1.5 ll 命令 输出当前文件夹中所有文件详细信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll</span><br></pre></td></tr></table></figure><h2><span id="2快捷键">2.快捷键</span></h2><h3><span id="tab-命令补全快捷键">Tab 命令补全快捷键</span></h3><p>这个快捷键可以让我们快速的输入指定文件名,命令等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CloudResetPwdUpdateAgent  CloudrResetPwdAgent  bin  boot  dev  etc  home  lib  lib64  </span><br><span class="line">[root@ecs-235046 /]# cd ho</span><br><span class="line">// 这时按下Tab键, 会自动补全</span><br><span class="line">[root@ecs-235046 /]# cd home/</span><br></pre></td></tr></table></figure><h3><span id="ctrlc-强制终止当前进程">Ctrl+c 强制终止当前进程</span></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ecs-235046 ~]# tail</span><br><span class="line">^C</span><br><span class="line">[root@ecs-235046 ~]# </span><br></pre></td></tr></table></figure><h3><span id="ctrld-退出连接终端">Ctrl+d 退出连接终端</span></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ecs-235046 ~]# logout</span><br><span class="line"></span><br><span class="line">连接断开</span><br></pre></td></tr></table></figure><h3><span id="ctrlz-将当前程序放到后台执行不结束进行退出回到控制台">Ctrl+z 将当前程序放到后台执行，不结束进行退出，回到控制台</span></h3><h3><span id="fg-恢复到前台应用程序继续执行">fg 恢复到前台应用程序继续执行</span></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">/usr/share/cmake3/Help/variable/PROJECT_DESCRIPTION.rst</span><br><span class="line">/usr/share/cmake3/Help/variable/CMAKE_LANG_LINKER_PREFERENCE_PROPAGATES.rst^Z</span><br><span class="line">[1]+  Stopped                 find /</span><br><span class="line">[root@ecs-235046 ~]# </span><br></pre></td></tr></table></figure><h3><span id="ctrla-将光标移到输入行头部">Ctrl+a 将光标移到输入行头部</span></h3><h3><span id="ctrle-将光标移到输入行尾部">Ctrl+e  将光标移到输入行尾部</span></h3><h3><span id="ctrlk-删除从光标位置到行末的字符">Ctrl+k 删除从光标位置到行末的字符</span></h3><h2><span id="常用通配符执行查找删除等命令的时候有用">常用通配符(执行查找,删除等命令的时候有用)</span></h2><p>匹配0个或多个字符： *</p><p>匹配任意一个字符： ？</p><p>匹配列表中任意一个单一字符： [list]</p><p>匹配列表之外的任意一个字符：[^list]</p><p>匹配一个字符范围或数字范围：[c1-c2]</p><p>匹配列表中范围的全部字符： {c1…c3}</p><p>匹配列表中其中一个字符串：{string1,string2,…}</p><p>mongodb常用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 后台启动mongod,带账户验证</span><br><span class="line">mongod --fork -dbpath &#x27;/var/lib/mongodb&#x27; -logpath=/var/lib/mongodb/mongodb.log --auth</span><br></pre></td></tr></table></figure> ]]>
        </content>
           
        <summary type="html">&lt;h2&gt;&lt;span id=&quot;1常用命令&quot;&gt;1.常用命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;1.1 创建一个名为file的文件&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl</summary>
            
        <category term="docker容器" scheme="https://1776167012.github.io/tags/docker%E5%AE%B9%E5%99%A8/" />
        
    </entry>
    
    <entry>
        <title>docker日志清理</title>
        <link href="https://1776167012.github.io/article/Linux%E8%BF%90%E7%BB%B4%E7%9B%B8%E5%85%B3-linux-2-Linux%E7%94%A8%E6%88%B7%E5%8F%8A%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/" />
        <id>https://1776167012.github.io/article/Linux%E8%BF%90%E7%BB%B4%E7%9B%B8%E5%85%B3-linux-2-Linux%E7%94%A8%E6%88%B7%E5%8F%8A%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/</id>
        <published>2023-06-05T01:38:37.000Z</published>
        <updated>2026-01-12T03:42:06.111Z
        </updated>
        
        <content type="html">
            <![CDATA[ <h1><span id="1linux用户权限管理">1.Linux用户权限管理</span></h1><p>在Linux系统中，多个用户可以登录一个主机进行使用，但是不同用户都有着自己的用户空间，<br>他们在没有对方的允许的情况下不能访问对方的文件。</p><h2><span id="11-用户权限常用命令">1.1 用户权限常用命令</span></h2><table><thead><tr><th>命令格式</th><th>描述</th></tr></thead><tbody><tr><td>whoami</td><td>查看当前用户名</td></tr><tr><td>who -d</td><td>打印死掉的进程</td></tr><tr><td>who -q</td><td>打印当前登录用户数及用户名</td></tr><tr><td>who -u</td><td>打印当前登录用户登录信息</td></tr><tr><td>sudo adduser muzhi</td><td>新建用户muzhi</td></tr><tr><td>su -l muzhi</td><td>切换到muzhi用户登录</td></tr><tr><td>groups muzhi</td><td>查询用户所在用户组</td></tr><tr><td>sudo usermod -G sudo muzhi</td><td>将其他用户加入sudo用户组</td></tr><tr><td>sudo deluser muzhi --remove-home</td><td>删除用户</td></tr></tbody></table><h1><span id="2linux文件权限">2.Linux文件权限</span></h1><p><img src="2.Linux%E7%94%A8%E6%88%B7%E5%8F%8A%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/1.png" alt="img.png"></p><p>文件权限就是文件的访问控制权限，包括文件的类型，文件的可操作用户。</p><h2><span id="21-常用命令">2.1 常用命令</span></h2><table><thead><tr><th>命令格式</th><th>描述</th></tr></thead><tbody><tr><td>ls -s(简写 ll)</td><td>列出本目录下文件的详细信息</td></tr><tr><td>chmod xxx (0–无  1–可执行  2–可写  4–可读)</td><td>修改文件权限</td></tr><tr><td>ls -a</td><td>列出本目录下所有文件(包括隐藏文件)</td></tr><tr><td>ls -dl 目录名</td><td>查看某一个目录的完整属性</td></tr><tr><td>ls -asSh</td><td>显示当前目录下所有文件大小</td></tr><tr><td>sudo chown 用户名称 目标文件名称</td><td>变更文件所有者</td></tr><tr><td>sudo chgrp 用户组名称 目标文件名称</td><td>变更文件所属组</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ecs-235046 study]# chown muzhi fiel </span><br><span class="line">[root@ecs-235046 study]# ll</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 muzhi root 0 Jun  9 15:01 fiel</span><br><span class="line">[root@ecs-235046 study]# </span><br></pre></td></tr></table></figure> ]]>
        </content>
           
        <summary type="html">&lt;h1&gt;&lt;span id=&quot;1linux用户权限管理&quot;&gt;1.Linux用户权限管理&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;在Linux系统中，多个用户可以登录一个主机进行使用，但是不同用户都有着自己的用户空间，&lt;br&gt;
他们在没有对方的允许的情况下不能访问对方的文件。&lt;/p&gt;
&lt;h2&gt;&lt;</summary>
            
        <category term="docker容器" scheme="https://1776167012.github.io/tags/docker%E5%AE%B9%E5%99%A8/" />
        
    </entry>
    
    <entry>
        <title>docker日志清理</title>
        <link href="https://1776167012.github.io/article/Linux%E8%BF%90%E7%BB%B4%E7%9B%B8%E5%85%B3-linux-3-Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" />
        <id>https://1776167012.github.io/article/Linux%E8%BF%90%E7%BB%B4%E7%9B%B8%E5%85%B3-linux-3-Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</id>
        <published>2023-06-05T01:38:37.000Z</published>
        <updated>2026-01-12T03:42:06.116Z
        </updated>
        
        <content type="html">
            <![CDATA[ <p>1.Linux系统中的文件组织目录结构</p><p>Linux系统的文件组织遵循FHS标准：</p><p>FHS定义了两层规范，<br>第一层是，/ 下面的各个目录应该要放什么数据，例如/etc 应该放置设置文件，/bin与/sbin则应该放置可执行文件等。<br>第二层是针对/usr及/var这两个目录的子目录来定义。例如/var/log放置系统日志文件，/usr/share放置共享数据文件等等。<br>fhs-3.0.pdf (<a href="http://linuxfoundation.org">linuxfoundation.org</a>)</p><p>2.Linux中的绝对路径和相对路径</p><p>cd 命令用来切换路径<br>当前目录  .</p><p>上一级目录 …</p><p>home目录 ~</p><p>相对路径 cd …/</p><p>绝对路径 cd /home/shiyanlou</p><p>3.Linux系统中对文件的移动，复制，重命名,查阅</p><p>新建空白文件 touch file</p><p>新建空白目录 mkdir testdir</p><p>创建多级目录 mkdir -p father/son</p><p>复制文件到相同目录下且改名  cp filename filename1</p><p>复制文件到指定文件夹下 cp filename dirname</p><p>复制目录 cp -r filedir newdiername</p><p>删除文件 rm test</p><p>强制删除文件 rm -f test</p><p>删除目录  rm -r dir</p><p>强制删除目录 rm -rf dir</p><p>移动文件到指定目录  mv file dir</p><p>文件重命名 mv file newfile</p><p>正序显示查看文件 cat file</p><p>倒序显示查看文件内容  tac  file</p><p>打印行号显示文件内容  nl file</p><p>查阅文件 less file  (翻页查阅)</p><p>只查看文件开始n行 head -n 100 file</p><p>动态只查看文件最后几行  tail -n 10 -f file</p><p>查看文件类型 file filename</p><p>4.Linux文件编辑</p><p>文件编辑命令 vim file<br>I 插入  esc 退出插入模式  :wq 保存并退出</p><p>这个需要学习的话，可以使用vimtutor命令进入学习界面<br>vimtutor</p> ]]>
        </content>
           
        <summary type="html">&lt;p&gt;1.Linux系统中的文件组织目录结构&lt;/p&gt;
&lt;p&gt;Linux系统的文件组织遵循FHS标准：&lt;/p&gt;
&lt;p&gt;FHS定义了两层规范，&lt;br&gt;
第一层是，/ 下面的各个目录应该要放什么数据，例如/etc 应该放置设置文件，/bin与/sbin则应该放置可执行文件等。&lt;br&gt;
</summary>
            
        <category term="docker容器" scheme="https://1776167012.github.io/tags/docker%E5%AE%B9%E5%99%A8/" />
        
    </entry>
    
    <entry>
        <title>1.Java进阶之文件操作入门</title>
        <link href="https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-1-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%85%A5%E9%97%A8/" />
        <id>https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-1-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%85%A5%E9%97%A8/</id>
        <published>2023-05-20T03:59:00.000Z</published>
        <updated>2026-01-05T03:33:15.906Z
        </updated>
        
        <content type="html">
            <![CDATA[ <h1><span id="1我们为何要操作文件">1.我们为何要操作文件？</span></h1><p>首先,我们思考一个问题，在没学习JDBC之前，我们怎么将程序产生的数据持久化(存储)到硬盘/磁盘中呢？<br>并且我们如何去读取硬盘中的文件呢？<br>答案就是Java的文件操作机制和输入输出流机制，Java提供了丰富的API让我们能对文件进行操作，其中最基础的类就是File类。</p><h1><span id="2file类能干啥">2.File类能干啥？</span></h1><p>File类主要用来获取文件本身的一些信息，例如文件所在的目录、文件的大小(也可称为长度)或文件读写权限等，<br><strong>但不涉及对文件的读写操作，但是一些对文件读写操作是基于文件的。</strong></p><h1><span id="3file类中的方法">3.File类中的方法</span></h1><h2><span id="31构造方法">3.1构造方法</span></h2><h3><span id="filestring-filename">File(String filename);</span></h3><p>根据文件名构造File对象,其中，filename是文件名字，<br>使用File(String filename)创建文件时，该文件被认为与当前应用程序在同一目录中。</p><h3><span id="filestring-directorypathstring-filename">File(String directoryPath,String filename);</span></h3><p>根据路径名称和文件名构造File对象，其中，filename是文件名字，directoryPath是文件的路径</p><h3><span id="filefile-dirstring-filename">File(File dir,String filename);</span></h3><p>dir为一个目录File对象，filename是文件名</p><p>当我们顺利获取一个File对象时，我们可以调用其中的方法获取文件的相关信息。</p><p>用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fileStudy</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;麻子.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/Personal/MyRepository/study&quot;</span>,<span class="string">&quot;麻子.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/Personal/MyRepository/study&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dir,<span class="string">&quot;麻子.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//获取文件的绝对路径</span></span><br><span class="line">    System.out.println(file.getAbsolutePath());</span><br><span class="line">    System.out.println(file1.getAbsolutePath());</span><br><span class="line">    System.out.println(dir.getAbsolutePath());</span><br><span class="line">    System.out.println(file2.getAbsolutePath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file 文件路径：E:\Personal\MyRepository\study\麻子.txt</span><br><span class="line">file1 文件路径： E:\Personal\MyRepository\study\麻子.txt</span><br><span class="line">dir 文件路径： E:\Personal\MyRepository\study</span><br><span class="line">file2 文件路径： E:\Personal\MyRepository\study\麻子.txt</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2><span id="32-其他方法">3.2 其他方法</span></h2><h3><span id="public-boolean-exists">public boolean exists();</span></h3><p>判断文件是否存在,存在返回true, 不存在返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">existsStudy</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;麻子.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;麻子.txt 文件是否存在： &quot;</span>+file.exists());</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;四郎.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;四郎.txt 是否存在： &quot;</span>+file1.exists());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">麻子.txt 文件是否存在： true</span><br><span class="line">四郎.txt 是否存在： false</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3><span id="public-string-getname">public String getName();</span></h3><p>获取文件的名称.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getNameStudy</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;麻子.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;麻子.txt文件名称： &quot;</span>+file.getName());</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;四郎.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;四郎.txt 文件名称： &quot;</span>+file1.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="public-boolean-canread">public boolean canRead();</span></h3><p>判断文件是否可读,可读返回true,不可读返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">canReadStudy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;麻子.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;麻子.txt文件是否可读： &quot;</span>+file.canRead());</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;四郎.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;四郎.txt是否可读： &quot;</span>+file1.canRead());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="public-boolean-canwrite">public boolean canWrite();</span></h3><p>判断文件是否可被写入,可写入返回true,不可写入返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">canWriteStudy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;麻子.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;麻子.txt是否可写： &quot;</span>+file.canWrite());</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;四郎.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;四郎.txt是否可写： &quot;</span>+file1.canWrite());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="public-long-length">public long length();</span></h3><p>获取文件长度（大小）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lengthStudy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;麻子.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;麻子.txt文件大小： &quot;</span>+file.length());</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;四郎.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;四郎.txt文件大小： &quot;</span>+file1.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="public-string-getabsolutepath">public String getAbsolutePath();</span></h3><p>获取文件的绝对路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">absolutePathStudy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;麻子.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;麻子.txt 文件绝对路径： &quot;</span>+file.getAbsolutePath());</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;四郎.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;四郎.txt 文件绝对路径： &quot;</span>+file1.getAbsolutePath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="public-string-getparent">public String getParent();</span></h3><p>获取文件的父目录字符串描述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parentStudy</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;麻子.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;麻子.txt 文件父目录： &quot;</span>+file.getParent());</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;四郎.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;四郎.txt 文件父目录： &quot;</span>+file1.getParent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="public-boolean-isfile">public boolean isFile();</span></h3><p>判断文件是否是一个普通文件而非目录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">isFileStudy</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;麻子.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;麻子.txt 是否是文件： &quot;</span>+file.isFile());</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;四郎.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;四郎.txt 是否是文件： &quot;</span>+file1.isFile());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="public-boolean-isdirectory">public boolean isDirectory();</span></h3><p>判断文件是否是一个目录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">isDirectory</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;麻子.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;麻子.txt是否是目录: &quot;</span>+file.isDirectory());</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;四郎.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;四郎.txt是否是目录： &quot;</span>+file1.isDirectory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="public-boolean-ishidden">public boolean isHidden();</span></h3><p>判断文件是否是隐藏文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">isHidden</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;麻子.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;麻子.txt是否是隐藏文件： &quot;</span>+file.isHidden());</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;四郎.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;四郎.txt 是否是隐藏文件： &quot;</span>+file1.isHidden());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="public-long-lastmodified">public long lastModified();</span></h3><p>获取文件最后修改的时间戳。(时间是从1970年午夜至文件最后修改时刻的毫秒数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lastModifiedStudy</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;麻子.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;麻子.txt最后修改时间： &quot;</span>+file.lastModified());</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;四郎.txt&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;四郎.txt 件最后修改时间： &quot;</span>+file1.lastModified());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">麻子.txt最后修改时间： 1667878191306</span><br><span class="line">四郎.txt 件最后修改时间： 0</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3><span id="public-boolean-mkdir">public boolean mkdir();</span></h3><p>File对象可以调用此方法创建一个目录，创建成功返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mkdirStudy</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;FileStudy&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!file1.exists())&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">sus</span> <span class="operator">=</span> file1.mkdir();</span><br><span class="line">        <span class="keyword">if</span>(sus)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;FileStudy 目录创建成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="public-string-list">public String[] list();</span></h3><p>如果File对象是一个目录，那么此对象可以调用该方法以字符串的形式返回目录下的文件和子目录描述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">listStudy</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Java基础学习&quot;</span>);</span><br><span class="line">    String[] dir = file.list();</span><br><span class="line">    <span class="keyword">assert</span> dir != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(String d:dir)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Java基础学习子目录： &quot;</span>+d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] dir1 = file.list(<span class="keyword">new</span> <span class="title class_">FilenameFilter</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(name.contains(<span class="string">&quot;tar&quot;</span>))</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> dir1 != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(String d2:dir1)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Java基础学习子目录中名称包含 tar 的目录：&quot;</span>+d2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Java基础学习子目录： Java基础学习.iml</span><br><span class="line">Java基础学习子目录： pom.xml</span><br><span class="line">Java基础学习子目录： resource</span><br><span class="line">Java基础学习子目录： src</span><br><span class="line">Java基础学习子目录： target</span><br><span class="line">Java基础学习子目录中名称包含 tar 的目录：target</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3><span id="public-file-listfiles">public File[] listFiles();</span></h3><p>如果File对象关联的文件是一个目录，那么此对象可以调用该方法以File对象的形式返回目录下的文件和子目录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">listFilesStudy</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Java基础学习&quot;</span>);</span><br><span class="line">    File[] files = file.listFiles();</span><br><span class="line">    <span class="keyword">assert</span> files != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(File file1:files)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Java基础学习子目录： &quot;</span>+file1.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    File[] dir1 = file.listFiles(<span class="keyword">new</span> <span class="title class_">FilenameFilter</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(name.contains(<span class="string">&quot;tar&quot;</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">assert</span> dir1 != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(File d2:dir1)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Java基础学习子目录中名称包含 tar 的目录：&quot;</span>+d2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Java基础学习子目录： Java基础学习.iml</span><br><span class="line">Java基础学习子目录： pom.xml</span><br><span class="line">Java基础学习子目录： resource</span><br><span class="line">Java基础学习子目录： src</span><br><span class="line">Java基础学习子目录： target</span><br><span class="line">Java基础学习子目录中名称包含 tar 的目录：target</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3><span id="public-string-listfilenamefilter-obj">public String[] list(FilenameFilter obj);</span></h3><p>该方法用字符串的形式返回目录下的指定类型的所有文件。</p><p>参数FilenameFilter是一个接口，该接口有一个方法：<br>public boolean accept(File dir,String name);<br>当这个方法返回true时，list方法就将name文件存放到返回的数组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">listStudy</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Java基础学习&quot;</span>);</span><br><span class="line">    String[] dir = file.list();</span><br><span class="line">    <span class="keyword">assert</span> dir != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(String d:dir)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Java基础学习子目录： &quot;</span>+d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] dir1 = file.list(<span class="keyword">new</span> <span class="title class_">FilenameFilter</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(name.contains(<span class="string">&quot;tar&quot;</span>))</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> dir1 != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(String d2:dir1)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Java基础学习子目录中名称包含 tar 的目录：&quot;</span>+d2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="public-file-listfilesfilenamefilter-obj">public File[] listFiles(FilenameFilter obj);</span></h3><p>此方法用File对象返回目录下指定类型的所有文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">listFilesStudy</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Java基础学习&quot;</span>);</span><br><span class="line">    File[] files = file.listFiles();</span><br><span class="line">    <span class="keyword">assert</span> files != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(File file1:files)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Java基础学习子目录： &quot;</span>+file1.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    File[] dir1 = file.listFiles(<span class="keyword">new</span> <span class="title class_">FilenameFilter</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(name.contains(<span class="string">&quot;tar&quot;</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">assert</span> dir1 != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(File d2:dir1)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Java基础学习子目录中名称包含 tar 的目录：&quot;</span>+d2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="public-boolean-createnewfile">public boolean createNewFile();</span></h3><p>此方法可以创建一个文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createNewFileStudy</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;四郎.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">sus</span> <span class="operator">=</span> file.createNewFile();</span><br><span class="line">        <span class="keyword">if</span>(sus) System.out.println(<span class="string">&quot;四郎.txt 文件创建完成！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="public-boolean-detele">public boolean detele();</span></h3><p>此方法为删除一个文件的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteStudy</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;四郎.txt&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">sus</span> <span class="operator">=</span> file.delete();</span><br><span class="line">    <span class="keyword">if</span>(sus) System.out.println(<span class="string">&quot;四郎.txt 文件删除完成！！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码地址：<br><a href="https://gitee.com/yan-jiadou/study/tree/master/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/src/main/java/Progress/exa01">Java基础学习/src/main/java/Progress/exa01 · 严家豆/Study - 码云 - 开源中国 (gitee.com)</a></p><p>如果想动手做点东西，可以参考Java动手做一做之文件编程专栏：<br><a href="https://blog.csdn.net/c1776167012/category_10987539.html">Java动手做一做之文件编程</a></p> ]]>
        </content>
           
        <summary type="html">&lt;h1&gt;&lt;span id=&quot;1我们为何要操作文件&quot;&gt;1.我们为何要操作文件？&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;首先,我们思考一个问题，在没学习JDBC之前，我们怎么将程序产生的数据持久化(存储)到硬盘/磁盘中呢？&lt;br&gt;
并且我们如何去读取硬盘中的文件呢？&lt;br&gt;
答案就是Java</summary>
            
        <category term="Java进阶" scheme="https://1776167012.github.io/tags/Java%E8%BF%9B%E9%98%B6/" />
        
    </entry>
    
    <entry>
        <title>2.1 Java读文件之InputStream学习</title>
        <link href="https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-2-1-Java%E8%AF%BB%E6%96%87%E4%BB%B6%E4%B9%8BInputStream%E5%AD%A6%E4%B9%A0/" />
        <id>https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-2-1-Java%E8%AF%BB%E6%96%87%E4%BB%B6%E4%B9%8BInputStream%E5%AD%A6%E4%B9%A0/</id>
        <published>2023-05-20T03:58:00.000Z</published>
        <updated>2026-01-05T03:33:15.909Z
        </updated>
        
        <content type="html">
            <![CDATA[ <h1><span id="1什么是inputstream输入流">1.什么是InputStream（输入流）？</span></h1><p>在JavaAPI中，可以从字节序列来源地读入一个字节序列的对象称为输入流。<br>字节序列的来源地可以是文件，也可以是网络，还可以是内存块等等。<br>输入流根据每次读取的字节数量的不同被分为字节输入流和字符输入流。<br>字节输入流每次都是读取一个字节的，而字符输入流每次读入都是根据基于两字节的字符为单位读取的。</p><h1><span id="2jdk中对inputstream的定义">2.JDK中对InputStream的定义</span></h1><p>在JDK中，InputStream是一个抽象类，其主要方法定义如下：</p><table><thead><tr><th>方法定义</th><th>返回值描述</th><th>方法描述</th></tr></thead><tbody><tr><td>abstract int read()</td><td>返回的是读入的字节asc码（-1~225）</td><td>当读取完毕时，返回-1</td></tr><tr><td>int read(byte b[])</td><td>将源中的字节信息填充到b中</td><td>当填充完毕时，返回实际填充数</td></tr><tr><td>int read(byte b[],int off,int len)</td><td>将b中指定位置填充源中的字节</td><td>当填充完毕时，返回实际填充数</td></tr></tbody></table><p>这个类的主要能力定义就是从文件或网络或某处读取数据到程序中。<br>这个<strong>某处</strong>我们称之为<strong>源</strong>，而根据这个源的不同,JDK实现出了不同的具体的实现类来让我们方便使用。</p><h2><span id="21-使用fileinputstream读取文件">2.1 使用FileInputStream读取文件</span></h2><p>下面使用它的一个实现类FileInputStream读取文件<br>FileInputStream顾名思义，它是源为文件的字节输入流。</p><h3><span id="211-read-使用实例">2.1.1 read() 使用实例</span></h3><p>麻子.txt 内容如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">姓名: 张麻子</span><br><span class="line">性别： 男</span><br><span class="line">年龄: 28</span><br><span class="line">自我评价： 好好啊好好好哈</span><br><span class="line">大学成绩：A A A</span><br><span class="line">毕业院校: 黄埔军校</span><br><span class="line">获得证书：教师资格证, 教官证</span><br><span class="line">人生格言: 公平，公平，还是tm的公平</span><br><span class="line">专业：打劫专业</span><br></pre></td></tr></table></figure><p>下面使用FileInputStream的read方法读取该文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FileInputStream实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fileInputStreamStudy</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;麻子.txt&quot;</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> ((n=inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>)n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">å§å: å¼ éº»å­</span><br><span class="line">æ§å«ï¼ ç·</span><br><span class="line">å¹´é¾: 28</span><br><span class="line">èªæè¯ä»·ï¼ å¥½å¥½åå¥½å¥½å¥½å</span><br><span class="line">å¤§å­¦æç»©ï¼A A A</span><br><span class="line">æ¯ä¸é¢æ ¡: é»ååæ ¡</span><br><span class="line">è·å¾è¯ä¹¦ï¼æå¸èµæ ¼è¯, æå®è¯</span><br><span class="line">äººçæ ¼è¨: å¬å¹³ï¼å¬å¹³ï¼è¿æ¯tmçå¬å¹³</span><br><span class="line">ä¸ä¸ï¼æå«ä¸ä¸</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>上面的测试，每次读取都是读取的一个字节，所以后面的中文是可能无法正确显示的，因为中文为两个字节一组.</p><h3><span id="212-readbyte-b使用实例">2.1.2 read(byte[] b)使用实例</span></h3><p>此方法可以一次性读取指定数量(b的大小)的字节数据填充到参数b中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readByteStudy</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;麻子.txt&quot;</span>);</span><br><span class="line">    <span class="type">byte</span>[] a = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>];</span><br><span class="line">    System.out.println(inputStream.read(a));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">byte</span> n:a)&#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>)n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">250</span><br><span class="line">￥ﾧﾓ￥ﾐﾍ: ￥ﾼﾠ￩ﾺﾻ￥ﾭﾐ</span><br><span class="line">￦ﾀﾧ￥ﾈﾫ￯ﾼﾚ ￧ﾔﾷ</span><br><span class="line">￥ﾹﾴ￩ﾾﾄ: 28</span><br><span class="line">￨ﾇﾪ￦ﾈﾑ￨ﾯﾄ￤ﾻﾷ￯ﾼﾚ ￥ﾥﾽ￥ﾥﾽ￥ﾕﾊ￥ﾥﾽ￥ﾥﾽ￥ﾥﾽ￥ﾓﾈ</span><br><span class="line">￥ﾤﾧ￥ﾭﾦ￦ﾈﾐ￧ﾻﾩ￯ﾼﾚA A A</span><br><span class="line">￦ﾯﾕ￤ﾸﾚ￩ﾙﾢ￦ﾠﾡ: ￩ﾻﾄ￥ﾟﾔ￥ﾆﾛ￦ﾠﾡ</span><br><span class="line">￨ﾎﾷ￥ﾾﾗ￨ﾯﾁ￤ﾹﾦ￯ﾼﾚ￦ﾕﾙ￥ﾸﾈ￨ﾵﾄ￦ﾠﾼ￨ﾯﾁ, ￦ﾕﾙ￥ﾮﾘ￨ﾯﾁ</span><br><span class="line">￤ﾺﾺ￧ﾔﾟ￦ﾠﾼ￨ﾨﾀ: ￥ﾅﾬ￥ﾹﾳ￯ﾼﾌ￥ﾅﾬ￥ﾹﾳ￯ﾼﾌ￨﾿ﾘ￦ﾘﾯtm￧ﾚﾄ￥ﾅﾬ￥ﾹﾳ</span><br><span class="line">￤ﾸﾓ￤ﾸﾚ￯ﾼﾚ￦ﾉﾓ￥ﾊﾫ￤ﾸﾓ￤ﾸﾚ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3><span id="213-readbyte-b-int-offint-len">2.1.3 read(byte[] b , int off,int len)</span></h3><p>此方法可以一次性读取指定数量(len)的字节数据填充到参数b中,且b的开始索引位置是off</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readByteLengthStudy</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;麻子.txt&quot;</span>);</span><br><span class="line">    <span class="type">byte</span>[] a = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>];</span><br><span class="line">    System.out.println(inputStream.read(a,<span class="number">100</span>,<span class="number">100</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">byte</span> n:a)&#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>)n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">                                                                                                    ￥ﾧﾓ￥ﾐﾍ: ￥ﾼﾠ￩ﾺﾻ￥ﾭﾐ</span><br><span class="line">￦ﾀﾧ￥ﾈﾫ￯ﾼﾚ ￧ﾔﾷ</span><br><span class="line">￥ﾹﾴ￩ﾾﾄ: 28</span><br><span class="line">￨ﾇﾪ￦ﾈﾑ￨ﾯﾄ￤ﾻﾷ￯ﾼﾚ ￥ﾥﾽ￥ﾥﾽ￥ﾕﾊ￥ﾥﾽ￥ﾥﾽ￥ﾥﾽ￥ﾓﾈ</span><br><span class="line">￥ﾤﾧ￥ﾭﾦ￦ﾈﾐ￧ﾻﾩ￯ﾼﾚ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2><span id="22-其他方法学习">2.2 其他方法学习</span></h2><h3><span id="221-skiplong-n-跳过源中指定字节数进行读取">2.2.1 skip(long n) 跳过源中指定字节数进行读取</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * skip可以跳过源中一定数量的字节</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">skipStudy</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;麻子.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;跳过前100个字节： &quot;</span>+inputStream.skip(<span class="number">100</span>));</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n=inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>)n);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">跳过前100个字节： 100</span><br><span class="line">A A A</span><br><span class="line">æ¯ä¸é¢æ ¡: é»ååæ ¡</span><br><span class="line">è·å¾è¯ä¹¦ï¼æå¸èµæ ¼è¯, æå®è¯</span><br><span class="line">äººçæ ¼è¨: å¬å¹³ï¼å¬å¹³ï¼è¿æ¯tmçå¬å¹³</span><br><span class="line">ä¸ä¸ï¼æå«ä¸ä¸</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3><span id="222-available-预估剩余未读取的字节数量">2.2.2 available() 预估剩余未读取的字节数量</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * available可以预估剩余未读取的字节估计数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">availableStudy</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;麻子.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> ch;</span><br><span class="line">        <span class="keyword">while</span> ((ch=inputStream.read())!=-<span class="number">1</span>&amp;&amp;n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        n--;</span><br><span class="line">        System.out.print((<span class="type">char</span>)ch);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;还剩的未读的字节数：&quot;</span>+ inputStream.available());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">å§å: å¼ éº»å­</span><br><span class="line">æ§å«ï¼ ç·</span><br><span class="line">å¹´é¾: 28</span><br><span class="line">èªæè¯ä»·ï¼ å¥½å¥½åå¥½å¥½å¥½å</span><br><span class="line">å¤§å­¦æç»©ï¼还剩的未读的字节数：149</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3><span id="223-markint-readlimit-标记重读点并设置重读点范围和缓冲区相关">2.2.3 mark(int readlimit) 标记重读点，并设置重读点范围（和缓冲区相关）</span></h3><p>其中readlimit是在标记位置失效之前可以读取的最大字节限制,设置了它后,<br>只能在读取标记点后readlimit的过程中调用reset方法进行重置,如果超过了这个范围,reset就会调用失败。</p><h3><span id="224-reset-将流的游标重置为重读点">2.2.4 reset() 将流的游标重置为重读点</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * mark在JAVA中的实现是和缓冲区相关的。只要缓冲区够大，mark后读取的数据没有超出缓冲区的大小，mark标记就不会失效。</span></span><br><span class="line"><span class="comment">     * 如果不够大，mark后又读取了大量的数据，导致缓冲区更新，原来标记的位置自然找不到了。</span></span><br><span class="line"><span class="comment">     * 因此，mark后读取多少字节才失效，并不完全由readlimit参数确定，也和BufferedInputStream类的缓冲区大小有关。</span></span><br><span class="line"><span class="comment">     * 如果BufferedInputStream类的缓冲区大小大于readlimit，在mark以后只有读取超过缓冲区大小的数据，mark标记才会失效。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">markStudy</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;麻子.txt&quot;</span>),<span class="number">100</span>);</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="comment">// 这里100可以重置, 101却重置失败</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">//这里的readLimit和实际情况相关，</span></span><br><span class="line">        <span class="comment">// 如果BufferedInputStream类的缓冲区大小大于readlimit，在mark以后只有读取超过缓冲区大小的数据，mark标记才会失效。</span></span><br><span class="line">        inputStream.mark(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">while</span> ((n=inputStream.read())!=-<span class="number">1</span>&amp;&amp;num&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            num--;</span><br><span class="line">            System.out.print((<span class="type">char</span>) n);</span><br><span class="line">        &#125;</span><br><span class="line">        inputStream.reset();</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用reset 重新读取&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> ((n=inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">å§å: å¼ éº»å­</span><br><span class="line">æ§å«ï¼ ç·</span><br><span class="line">å¹´é¾: 28</span><br><span class="line">èªæè¯ä»·ï¼ å¥½å¥½åå¥½å¥½å¥½å</span><br><span class="line">å¤§å­¦æç»©ï¼</span><br><span class="line">调用reset 重新读取</span><br><span class="line">å§å: å¼ éº»å­</span><br><span class="line">æ§å«ï¼ ç·</span><br><span class="line">å¹´é¾: 28</span><br><span class="line">èªæè¯ä»·ï¼ å¥½å¥½åå¥½å¥½å¥½å</span><br><span class="line">å¤§å­¦æç»©ï¼A A A</span><br><span class="line">æ¯ä¸é¢æ ¡: é»ååæ ¡</span><br><span class="line">è·å¾è¯ä¹¦ï¼æå¸èµæ ¼è¯, æå®è¯</span><br><span class="line">äººçæ ¼è¨: å¬å¹³ï¼å¬å¹³ï¼è¿æ¯tmçå¬å¹³</span><br><span class="line">ä¸ä¸ï¼æå«ä¸ä¸</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3><span id="225-marksupported-钩子方法供实现类使用如果实现类支持markreset将其实现返回true">2.2.5 markSupported() 钩子方法，供实现类使用，如果实现类支持mark,reset将其实现返回true</span></h3><p>InputStream默认为false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">markSupported</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://gitee.com/yan-jiadou/study/tree/master/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/src/main/java/Progress/exa20">Java基础学习/src/main/java/Progress/exa20 · 严家豆/Study - 码云 - 开源中国 (gitee.com)</a></p> ]]>
        </content>
           
        <summary type="html">&lt;h1&gt;&lt;span id=&quot;1什么是inputstream输入流&quot;&gt;1.什么是InputStream（输入流）？&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;在JavaAPI中，可以从字节序列来源地读入一个字节序列的对象称为输入流。&lt;br&gt;
字节序列的来源地可以是文件，也可以是网络，还可以是内</summary>
            
        <category term="Java进阶" scheme="https://1776167012.github.io/tags/Java%E8%BF%9B%E9%98%B6/" />
        
    </entry>
    
    <entry>
        <title>2.2 Java写文件之OutputStream学习</title>
        <link href="https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-2-2-Java%E5%86%99%E6%96%87%E4%BB%B6%E4%B9%8BOutputStream%E5%AD%A6%E4%B9%A0/" />
        <id>https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-2-2-Java%E5%86%99%E6%96%87%E4%BB%B6%E4%B9%8BOutputStream%E5%AD%A6%E4%B9%A0/</id>
        <published>2023-05-20T03:57:00.000Z</published>
        <updated>2026-01-05T03:33:15.910Z
        </updated>
        
        <content type="html">
            <![CDATA[ <h1><span id="1什么是outputstream输出流">1.什么是OutputStream？（输出流）</span></h1><p>在JavaAPI中，将可以向目的地写入一个字节序列的对象称为输出流对象。<br>字节序列的来源地可以是文件，也可以是网络，还可以是内存块等等。<br>输出流根据每次写出的字节数量的不同分为字节输出流和字符输出流。<br>字节输出流每次都是写出一个字节的，而字符输出流每次写出都是根据基于两字节的字符为单位写出的。</p><h1><span id="2使用fileoutputstream写出文件">2.使用FileOutputStream写出文件</span></h1><p>在outputStream中的关键常用的方法是：write方法。</p><h2><span id="21-void-writeint-b-向目的地写入一个字节">2.1 void write(int b) 向目的地写入一个字节</span></h2><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每次写入单个字节</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeStudy</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;四郎.txt&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我是四郎&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = str.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="comment">//这里循环调用write进行写出操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b:bytes)&#123;</span><br><span class="line">            outputStream.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;成功写入,请检查是否生成了文件： 四郎.txt &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">成功写入,请检查是否生成了文件： 四郎.txt </span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2><span id="22-void-writebyte-b-向目的地写入多个字节">2.2 void write(byte b[]) 向目的地写入多个字节</span></h2><p>这个方法一次向目的地写入多个字节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一次写入多个字节</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeBytesStudy</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;四郎.txt&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我是四郎&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = str.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        outputStream.write(bytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;成功写入,请检查是否生成了文件： 四郎.txt &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">成功写入,请检查是否生成了文件： 四郎.txt </span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2><span id="23-void-writebyte-b-int-off-int-len-向目的地写入指定的多个字节">2.3 void write(byte b[], int off, int len) 向目的地写入指定的多个字节</span></h2><p>一次性写入字节数组b中指定范围的数据到目的地</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从指定字节数组中选一部分进行写入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeBytesLenStudy</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;四郎.txt&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我是四郎&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = str.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        outputStream.write(bytes,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;成功写入,请检查是否生成了文件： 四郎.txt &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">成功写入,请检查是否生成了文件： 四郎.txt </span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>生成的文件内容如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">��</span><br></pre></td></tr></table></figure><h2><span id="24-void-flush-如果使用的是缓冲流需要调用这个方法一次写出">2.4 void flush() 如果使用的是缓冲流，需要调用这个方法一次写出</span></h2><p>对于缓冲输出流，它的write方法并不会立即向磁盘中写入数据，而需要缓存满了或者调用flush方法立即写入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对于缓冲输出流，它的write方法并不会立即向磁盘中写入数据，</span></span><br><span class="line"><span class="comment">     * 而需要缓存满了或者调用flush方法立即写入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">flushStudy</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;四郎.txt&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我是四郎&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = str.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        outputStream.write(bytes);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        System.out.println(<span class="string">&quot;成功写入,请检查是否生成了文件： 四郎.txt &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">成功写入,请检查是否生成了文件： 四郎.txt </span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>生成的文件内容如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我是四郎</span><br></pre></td></tr></table></figure><p><a href="https://gitee.com/yan-jiadou/study/tree/master/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/src/main/java/Progress/exa20">代码地址：Java基础学习/src/main/java/Progress/exa20 · 严家豆/Study - 码云 - 开源中国 (gitee.com)</a></p> ]]>
        </content>
           
        <summary type="html">&lt;h1&gt;&lt;span id=&quot;1什么是outputstream输出流&quot;&gt;1.什么是OutputStream？（输出流）&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;在JavaAPI中，将可以向目的地写入一个字节序列的对象称为输出流对象。&lt;br&gt;
字节序列的来源地可以是文件，也可以是网络，还可以是</summary>
            
        <category term="Java进阶" scheme="https://1776167012.github.io/tags/Java%E8%BF%9B%E9%98%B6/" />
        
    </entry>
    
    <entry>
        <title>3.文件读写：使用IO流的步骤</title>
        <link href="https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-3-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%EF%BC%9A%E4%BD%BF%E7%94%A8IO%E6%B5%81%E7%9A%84%E6%AD%A5%E9%AA%A4/" />
        <id>https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-3-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%EF%BC%9A%E4%BD%BF%E7%94%A8IO%E6%B5%81%E7%9A%84%E6%AD%A5%E9%AA%A4/</id>
        <published>2023-05-20T03:57:00.000Z</published>
        <updated>2026-01-05T03:33:15.910Z
        </updated>
        
        <content type="html">
            <![CDATA[ <h1><span id="1使用输入流的步骤">1.使用输入流的步骤</span></h1><h2><span id="11使用输入流的4个基本步骤">1.1.使用输入流的4个基本步骤</span></h2><ul><li>步骤1：设定输入流的源。(创建File对象或路径)</li><li>步骤2：创建指向源的输入流。（创建指向 File对象|文件路径 的流对象(InputStream)）</li><li>步骤3：让输入流读取源中的数据。（调用InputStream的read方法）</li><li>步骤4：关闭输入流。（调用InputStream的close方法）</li></ul><h2><span id="12具体编码以fileinputstream为例">1.2.具体编码（以FileInputStream为例）</span></h2><h3><span id="第一二步的实现">第一,二步的实现</span></h3><h4><span id="fileinputstreamstring-name">FileInputStream(String name);</span></h4><p>使用给定的文件名name创建一个FileInputStream流。其中name指向的文件与源代码文件所在的目录是并列关系</p><h4><span id="fileinputstreamfile-file">FileInputStream(File file);</span></h4><p>使用File对象创建一个输入流。</p><p><strong>说明：上述两种方法中的参数name和file指定的文件称为输入流的源，输入流的作用是打开了一个到达文件的通道</strong></p><p>用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"> <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;hello.txt&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;File read error:&quot;</span>+e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(第二种构造方法类似于上述)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    File file=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    FileInputStream in=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;File read error:&quot;</span>+e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="第三步让输入流读取源中的数据通过使用read方法实现">第三步：让输入流读取源中的数据：通过使用read方法实现</span></h3><h4><span id="int-read">int read();</span></h4><p>该方法从源中读取单个字节的数据，返回0~225之间的一个整数，如果未读出字节就返回-1，每调用一次，读取游标向后移动一位。</p><h4><span id="int-readbyte-b">int read(byte b[]);</span></h4><p>该方法从源中试图读取b.length个字节到字节数组b中，返回实际的读取字节数目。如果到达文件的末尾则返回-1.</p><h4><span id="int-readbyte-b-int-offint-len">int read(byte b[] ,int off,int len);</span></h4><p>该方法从源中试图读取len个字节到字节数组b中，并返回实际读取的字节数目。参数off指定从字节数组的某个位置开始存放读取的数据。如果到达文件的末尾，则返回-1.</p><h3><span id="第四步关闭流">第四步：关闭流</span></h3><h4><span id="close">close();</span></h4><p>此方法为关闭流的方法。</p><p><strong>注意：FileInputStream按顺序地读取文件，只要不关闭流，每次调用read方法就顺序地读取源中其余的内容直到源的末尾或被关闭。</strong></p><h2><span id="13具体实例">1.3具体实例</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学习使用文件字节输入流的步骤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.创建文件源对象</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;麻子.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//2.创建文件字节输入流对象并指向文件源对象</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">fileStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">    <span class="comment">//3.让输入流读取源中的数据</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> ((n=fileStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>)n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.读取完毕，调用close方法关闭流，释放系统资源</span></span><br><span class="line">    fileStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：(回想下这里为什么会出现乱码？)</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">å§å: å¼ éº»å­</span><br><span class="line">æ§å«ï¼ ç·</span><br><span class="line">å¹´é¾: 28</span><br><span class="line">èªæè¯ä»·ï¼ å¥½å¥½åå¥½å¥½å¥½å</span><br><span class="line">å¤§å­¦æç»©ï¼A A A</span><br><span class="line">æ¯ä¸é¢æ ¡: é»ååæ ¡</span><br><span class="line">è·å¾è¯ä¹¦ï¼æå¸èµæ ¼è¯, æå®è¯</span><br><span class="line">äººçæ ¼è¨: å¬å¹³ï¼å¬å¹³ï¼è¿æ¯tmçå¬å¹³</span><br><span class="line">ä¸ä¸ï¼æå«ä¸ä¸</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h1><span id="2输出流使用步骤">2.输出流使用步骤</span></h1><h2><span id="21使用输出流的基本步骤">2.1.使用输出流的基本步骤</span></h2><ul><li>步骤1：给出输出流的目的地。（创建file对象）</li><li>步骤2：创建指向目的地的输出流。（创建输出流的对象指向file对象）</li><li>步骤3：让输出流把数据写入到目的地。（调用write方法）</li><li>步骤4：关闭输出流。（调用close方法）</li></ul><h2><span id="22具体编码以fileoutputstream为例">2.2.具体编码（以FileOutputStream为例）</span></h2><h3><span id="1给出输出流的目的地">1.给出输出流的目的地</span></h3><p>一般目的地为File对象或String对象指定路径的文件。</p><h3><span id="2创建指向目的地的输出流">2.创建指向目的地的输出流</span></h3><p>我们可以使用FileOutputStream类具有刷新功能的构造方法创建指向文件的输出流：</p><h4><span id="fileoutputstreamstring-name">FileOutputStream(String name);</span></h4><p>此方法使用给定的文件名name创建FileOutputStream流。其中name指向的文件与源代码文件所在的目录是并列关系</p><h4><span id="fileoutputstreamfile-file">FileOutputStream(File file);</span></h4><p>此方法使用File对象创建FileOutputStream流。</p><p><strong>说明：上述两种方法中的参数name和file指定的文件称为输出流的目的地，输出流的作用是打开了一个到达文件的通道</strong></p><h3><span id="3使用输出流写字节">3.使用输出流写字节</span></h3><p>需要使用的方法：</p><h4><span id="void-writeint-n">void write(int n);</span></h4><p>该方法向目的地写入单个字节。</p><h4><span id="void-writebyte-b">void write(byte b[]);</span></h4><p>该方法向目的地写入一个字节数组。</p><h4><span id="void-writebyte-bint-offint-len">void write(byte b[],int off,int len);</span></h4><p>该方法给定字节数组中起始于偏移量off处取len个字节写到目的地。</p><h3><span id="4关闭输出流">4.关闭输出流。</span></h3><h4><span id="void-close">void close();</span></h4><p><strong>注意：FileOutputStream流顺序地写入文件，只要不关闭流，每次调用write方法就顺序地向目的地写入内容，直到流被关闭</strong></p><h2><span id="23-具体实例">2.3 具体实例</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">useDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//创建目的地</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;四郎.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//创建指向目的地的输出流</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">    <span class="comment">//准备要写的数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;大家好，我是四郎，我喜欢麻子&quot;</span>;</span><br><span class="line">    <span class="comment">//调用write方法进行写入</span></span><br><span class="line">    outputStream.write(str.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    <span class="comment">//调用close方法关闭流</span></span><br><span class="line">    outputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的文件 四郎.txt的内容</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大家好，我是四郎，我喜欢麻子</span><br></pre></td></tr></table></figure><p>代码地址：<br><a href="https://gitee.com/yan-jiadou/study/tree/master/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/src/main/java/Progress/exa21">Java基础学习/src/main/java/Progress/exa21 · 严家豆/Study - 码云 - 开源中国 (gitee.com)</a></p> ]]>
        </content>
           
        <summary type="html">&lt;h1&gt;&lt;span id=&quot;1使用输入流的步骤&quot;&gt;1.使用输入流的步骤&lt;/span&gt;&lt;/h1&gt;
&lt;h2&gt;&lt;span id=&quot;11使用输入流的4个基本步骤&quot;&gt;1.1.使用输入流的4个基本步骤&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;步骤1：设定输入流的源。(创建File对象或路径</summary>
            
        <category term="Java进阶" scheme="https://1776167012.github.io/tags/Java%E8%BF%9B%E9%98%B6/" />
        
    </entry>
    
    <entry>
        <title>4.文件读写-字节流</title>
        <link href="https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-4-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%EF%BC%9A%E5%AD%97%E8%8A%82%E6%B5%81/" />
        <id>https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-4-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%EF%BC%9A%E5%AD%97%E8%8A%82%E6%B5%81/</id>
        <published>2023-05-20T03:56:00.000Z</published>
        <updated>2026-01-05T03:33:15.910Z
        </updated>
        
        <content type="html">
            <![CDATA[ <h1><span id="1什么是字节流">1.什么是字节流</span></h1><p>字节流最大的特点是，每次调用read或write读入或写出的数据是以字节为单位的，而有的字符需要两个字节去存储，<br>所以字节流读取数据会发生读到的数据不准确的情况。(就会看到乱码的效果)<br>在Java中的字节流的类命名一般是以Stream结尾的,比如FileInputStream.</p><h2><span id="11-字节数组流">1.1 字节数组流</span></h2><p>输入输出流的源 和 目的地除了可以是“文件”（硬盘）外，还可以是计算机内存，我们也可以使用数组流来将数据输入输出到内存。<br>字节数组流就是用来将内存中的数据输入到程序中,或者将程序的数据输出到内存中去的字节流。</p><h3><span id="111-bytearrayinputstream-字节数组输入流">1.1.1 ByteArrayInputStream 字节数组输入流</span></h3><p>ByteArrayInputStream是输入流InputStream的一种实现，它的源只能是字节数组byte[]，它支持mark。</p><h4><span id="构造方法">构造方法</span></h4><p><strong>ByteArrayInputStream(byte[]  buf);</strong><br>此构造方法的字节数组流的源是参数buf指定的数组的全部字节单元。<br><strong>ByteArrayInputStream(byte[]  buf ,int offset,int length);</strong><br>此方法构造的字节数组流的源是buf指定的数组从offset处按顺序取length个字节单元。</p><h4><span id="常用方法">常用方法</span></h4><p><strong>public int read();</strong><br>该方法可以顺序地从源中读取一个字节，返回读出的字节值。<br><strong>public int read(byte[] b,int off,int len);</strong><br>该方法可以顺序地从源中读出参数len指定的字节数，并将读出的字节存放在参数b指定的数组中，参数off指定数组b读出字节的起始位置，返回实际读出的字节个数，若未读出字节read方法返回-1.</p><h4><span id="使用示例">使用示例：</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readStudy</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//定义字节数组输入流的源</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="string">&quot;我是四郎&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    <span class="comment">//根据源创建字节数组输入流</span></span><br><span class="line">    <span class="type">ByteArrayInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">    <span class="comment">//读取源bytes中的数据</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> ((n=inputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>)n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ææ¯åé</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3><span id="112-bytearrayoutputstream-字节数组输出流">1.1.2 ByteArrayOutputStream 字节数组输出流</span></h3><p>ByteArrayOutputStream是输出流的一种实现，它的目的地只能是字节数组byte[]，它支持mark。</p><h4><span id="构造方法">构造方法</span></h4><p><strong>ByteArrayOutputStream();</strong><br>该方法构造的字节数组输出空间指向一个默认大小为32字节的缓冲区，若输出流向缓冲区写入的字节个数大于缓冲区时，缓冲区的容量会自动增加。<br><strong>ByteArrayOutputStream(int size);</strong><br>此方法构造的字节数组输出流指向的缓冲区的初始大小由参数size指定，若输出流向缓冲区写入的字节个数大于缓冲区时，缓冲区的容量会自动的增加。</p><h4><span id="常用方法">常用方法</span></h4><p><strong>public void write(int b);</strong><br>字节数组输出流可调用该方法顺序地向缓冲区写入一个字节。<br><strong>public void write(byte[] b, int off, int len);</strong><br>该方法可以将参数b中指定的len个字节顺序地写入缓冲区，参数off指定从b中写出的字节的起始位置。<br><strong>public byte[] toByteArray();</strong><br>该方法可以返回输出流写入到缓冲区的全部字节，通过它我们可以获取写出的数据。</p><h4><span id="使用示例">使用示例</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">toByteArrayStudy</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">byte</span>[] result;</span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="string">&quot;我是四郎&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    outputStream.write(bytes);</span><br><span class="line">    result = outputStream.toByteArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">byte</span> a:bytes)&#123;</span><br><span class="line">        System.out.print(a);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">byte</span> b:result)&#123;</span><br><span class="line">        System.out.print(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-26-120-111-26-104-81-27-101-101-23-125-114</span><br><span class="line">-26-120-111-26-104-81-27-101-101-23-125-114</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2><span id="12-字节数据流">1.2 字节数据流</span></h2><p>数据流能让我们读取或写出指定类型的数据，它是普通字节流的一种增强。<br>它可以有其他类型的输入流作为构造函数的参数进行构造。</p><h3><span id="121-datainputstream-数据输入流">1.2.1 DataInputStream 数据输入流</span></h3><p>由DataInputStream类创建的对象称为数据输入流。</p><p>它们允许程序按着机器无关的风格读取java原始数据，也就是说，当读取一个数值时，不必再关心这个数值应当是多少字节。<br>它算是对其他字节输入流的一种增强，但是也有一定的局限，比如用它读取readChar只能读取编码为UTF-16的文件，<br>读取其他文件将会乱码。</p><h4><span id="构造方法">构造方法</span></h4><p><strong>DataInputStream(InputStream in);</strong></p><p>此构造方法创建的数据输入流指向一个由参数in指定的底层输入流。</p><h4><span id="常用方法">常用方法</span></h4><p><strong>close();关闭流。<br>readBoolean();读取一个布尔值。<br>readByte();读取一个字节。<br>readChar();读取一个字符。<br>readDouble();读取一个双精度浮点值。<br>readFloat();读取一个单精度浮点值。<br>readInt();读取一个整型值。<br>readLong();读取一个长整型值。<br>readShort();读取一个短整型值。<br>readUnsignedByte();读取一个无符号字节。<br>readUnsignedShort();读取一个无符号短整型值。<br>readUTF();读取一个UTF字符串。</strong></p><h4><span id="使用实例">使用实例：</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 将文件输入流作为参数构造数据输入流</span></span><br><span class="line">    <span class="type">DataInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;麻子.txt&quot;</span>));</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">// 从文件读数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           builder.append(<span class="keyword">new</span> <span class="title class_">Character</span>(inputStream.readChar()));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">鏥邍㨠ꃩ못逍૦肧꯯벚⃧钷ഊ듩뺄㨠㈸ഊꫦ袑蓤뮷騠뷥ꖽ諥ꖽ뷥ꖽ蠍૥꒧ꛦ袐ꧯ벚䄠䄠䄍૦꾕髩馢ꄺ⃩뮄铥蚛ꄍ૨躷韨꾁ꛯ벚駥뢈蓦ꂼ脬⃦閙飨꾁ഊ뫧钟볨ꢀ㨠곥릳賥薬돯벌飦颯瑭蓥薬댍૤뢓髯벚鏥誫鏤뢚</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3><span id="122-dataoutputstream-数据输出流">1.2.2 DataOutputStream 数据输出流</span></h3><p>用法和输入流大同小异，它是字节输出流的一种增强。</p><h4><span id="1221-关键方法">1.2.2.1 关键方法</span></h4><p><strong>writeDouble(double v)<br>writeInt(int v)<br>writeUTF(String v)等。</strong></p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;四郎.txt&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我是四郎，我爱死麻子了！！&quot;</span>;</span><br><span class="line">    outputStream.writeUTF(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>生成了 四郎.txt文件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;我是四郎，我爱死麻子了！！</span><br></pre></td></tr></table></figure><h2><span id="13-字节对象流比较重要">1.3 字节对象流(比较重要)</span></h2><p>用ObjectInputStream和ObjectOutputStream类创建的对象称为对象输入（出）流。<br>对象输入（出）流可以将一个对象写入到一个文件中（或从文件读取一个对象到内存中）。<br>这个对象IO流比较常用，它可以将对象状态保存到磁盘中或通过网络发送出去，<br>接收方只需要用相同的机制在需要的时候重新加载， 相当于深拷贝了。</p><h3><span id="131-objectinputstream-对象输入流">1.3.1 ObjectInputStream 对象输入流</span></h3><p><strong>ObjectInputStream(InputStream in);</strong><br>此方法是对象输入流的构造方法。<br><strong>readObject();</strong><br>此方法读取一个对象到程序中。</p><h3><span id="132-objectoutputstream-对象输出流">1.3.2 ObjectOutputStream 对象输出流</span></h3><p><strong>ObjectOutputStream(OutputStream out);</strong><br>此方法是对象输出流的构造方法。</p><p><strong>writeObject(object obj);</strong><br>此方法可以将obj写入到目的地。</p><p>实例：<br>首先使用对象输出流将对象写入磁盘中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span></span><br><span class="line">    (<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;四郎&quot;</span>));</span><br><span class="line">    List&lt;String&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    a.add(<span class="string">&quot;我是四郎，我爱死麻子了&quot;</span>);</span><br><span class="line">    outputStream.writeObject(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br>生成了 四郎  文件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">�� sr java.util.ArrayListx����a� I sizexp   w   t !我是四郎，我爱死麻子了x</span><br></pre></td></tr></table></figure><p>然后使用对象输入流重新加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span></span><br><span class="line">    (<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;四郎&quot;</span>));</span><br><span class="line">    List&lt;String&gt; a  = (List&lt;String&gt;) inputStream.readObject();</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[我是四郎，我爱死麻子了]</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2><span id="13-randomaccessfile-随机io流">1.3 RandomAccessFile 随机IO流</span></h2><p>在java中，我们也可以只建立一个流，通过该流既能读文件，也能写文件。<br>那就是RandomAccessFile类创建的随机流。<br>RandomAccessFile类创建的流的指向既可以作为流的源，也可以作为流的目的地。<br>随机IO流读取字符是以字节为单位的。</p><h3><span id="131-使用方法">1.3.1 使用方法</span></h3><h4><span id="构造方法">构造方法</span></h4><p><strong>RandomAccessFile(String name,String mode);</strong><br><strong>RandomAccessFile(File file ,String mode);</strong><br>参数name用来确定一个文件名，给出创建的流的源（也是目的地）。<br>参数mode取r（只读）或rw（可读写），决定创建流对文件的访问权利。</p><p><strong>注意：随机流指向文件，不刷新文件。</strong></p><h4><span id="1312-常用方法">1.3.1.2 常用方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">close();关闭文件</span><br><span class="line">getFilePointer();获取当前读写的位置。</span><br><span class="line">length();获取文件的长度。</span><br><span class="line">read();从文件中读取一个字节的数据。</span><br><span class="line">readBoolean();从文件中读取一个布尔值，<span class="number">0</span>代表<span class="literal">false</span>，其他代表<span class="literal">true</span>。</span><br><span class="line">readByte();从文件中读取一个字节。</span><br><span class="line">readChar();从文件中读取一个字符。（两个字节）</span><br><span class="line">readDouble(); 从文件读取一个双精度浮点值（<span class="number">8</span>个字节）</span><br><span class="line">readFloat(); 从文件读取一个单精度浮点值（<span class="number">4</span>个字节）</span><br><span class="line">readFully(<span class="type">byte</span> b[]); 读b.length字节放入数组b，完全填满该数组</span><br><span class="line">readInt();从文件中读取一个<span class="type">int</span>值（<span class="number">4</span>个字节）</span><br><span class="line">readLine();从文件中读取一个文本行</span><br><span class="line">readLong();从文件中读取一个长整型值（<span class="number">8</span>个字节）</span><br><span class="line">readShort();从文件中读取一个短型值（<span class="number">2</span>个字节）</span><br><span class="line">readUnsignedByte();从文件读取一个无符号字节（<span class="number">1</span>个字节）</span><br><span class="line">readUnsignedShort();从文件读取一个无符号短型值（<span class="number">2</span>个字节）</span><br><span class="line">readUTF();从文件中读取一个UTF字符串</span><br><span class="line">seek(<span class="type">long</span> position);定位读写位置</span><br><span class="line">setLength(<span class="type">long</span> newlength);设置文件的长度。</span><br><span class="line">skipBytes(<span class="type">int</span> n);在文件中跳过给定数量的字节。</span><br><span class="line">write(<span class="type">byte</span> b[]);写b.length个字节到文件</span><br><span class="line">writeBoolean(<span class="type">boolean</span> v);把一个布尔值作为单字节值写入文件</span><br><span class="line">writeByte(<span class="type">int</span> v);向文件写入一个字节</span><br><span class="line">writeByte(String s);向文件写入一个字符串</span><br><span class="line">writeChar(<span class="type">char</span> c);向文件写入一个字符</span><br><span class="line">writeChars(String s);向文件写入一个作为字符数据的字符串</span><br><span class="line">writeDouble(<span class="type">double</span> v);向文件写入一个双精度浮点值</span><br><span class="line">writeFloat(<span class="type">float</span> v);向文件写入一个单精度浮点值</span><br><span class="line">writeInt(<span class="type">int</span> v);向文件写入一个<span class="type">int</span>值</span><br><span class="line">writeLong(<span class="type">long</span> v);向文件写入一个长整型值</span><br><span class="line">writeShort(<span class="type">int</span> v);向文件写入一个短整型值</span><br><span class="line">writeUTF(String s);向文件写入一个UTF字符串</span><br></pre></td></tr></table></figure><h4><span id="1313-使用实例">1.3.1.3 使用实例</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomAccessFileStudy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;麻子.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">               <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> randomAccessFile.readLine();</span><br><span class="line">               <span class="keyword">if</span>(s==<span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">               System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        randomAccessFile.write(<span class="string">&quot;\n你好，我是四郎&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">å§å: å¼ éº»å­</span><br><span class="line">æ§å«ï¼ ç·</span><br><span class="line">å¹´é¾: 28</span><br><span class="line">èªæè¯ä»·ï¼ å¥½å¥½åå¥½å¥½å¥½å</span><br><span class="line">å¤§å­¦æç»©ï¼A A A</span><br><span class="line">æ¯ä¸é¢æ ¡: é»ååæ ¡</span><br><span class="line">è·å¾è¯ä¹¦ï¼æå¸èµæ ¼è¯, æå®è¯</span><br><span class="line">äººçæ ¼è¨: å¬å¹³ï¼å¬å¹³ï¼è¿æ¯tmçå¬å¹³</span><br><span class="line">ä¸ä¸ï¼æå«ä¸ä¸</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line">并且成功向麻子.txt写入下面的内容： 你好，我是四郎</span><br></pre></td></tr></table></figure><p>代码地址：<br><a href="https://gitee.com/yan-jiadou/study/tree/master/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/src/main/java/Progress/exa22">Java基础学习/src/main/java/Progress/exa22 · 严家豆/Study - 码云 - 开源中国 (gitee.com)</a></p> ]]>
        </content>
           
        <summary type="html">&lt;h1&gt;&lt;span id=&quot;1什么是字节流&quot;&gt;1.什么是字节流&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;字节流最大的特点是，每次调用read或write读入或写出的数据是以字节为单位的，而有的字符需要两个字节去存储，&lt;br&gt;
所以字节流读取数据会发生读到的数据不准确的情况。(就会看到乱码的</summary>
            
        <category term="Java进阶" scheme="https://1776167012.github.io/tags/Java%E8%BF%9B%E9%98%B6/" />
        
    </entry>
    
    <entry>
        <title>5.文件读写-字符流</title>
        <link href="https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-5-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%EF%BC%9A%E5%AD%97%E7%AC%A6%E6%B5%81/" />
        <id>https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-5-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%EF%BC%9A%E5%AD%97%E7%AC%A6%E6%B5%81/</id>
        <published>2023-05-20T03:55:00.000Z</published>
        <updated>2026-01-05T03:33:15.910Z
        </updated>
        
        <content type="html">
            <![CDATA[ <blockquote><p>因为字节流不能很好地操作本身容量单位较大的数据（一个字符有时等于多个字节）,所以需要字符流。<br>如果存在那种由多个字节组成的字符，那么用字节输入流读取，则会乱码！！！<br>但是，如果用字符输入流读取，就不会出现乱码！！ 所以为了保险起见，对于文本文件,尽量少用字节流,多用字符流</p></blockquote><h1><span id="1文件字符io流">1.文件字符IO流</span></h1><p>文件字符IO流和文件字节IO流对应，它读入和写出的数据是以字符为单位的。</p><h2><span id="11-filereader-文件字符输入流">1.1 FileReader 文件字符输入流</span></h2><h3><span id="111-构造方法">1.1.1 构造方法</span></h3><p><strong>FileReader(String filename);</strong></p><p><strong>FileReader(File filename);</strong></p><h3><span id="112-其他方法">1.1.2 其他方法</span></h3><p><strong>int read(); 以字符为单位读取输入流源的数据</strong></p><h3><span id="113-使用示例">1.1.3 使用示例</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件字符输入流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;麻子.txt&quot;</span>));</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n=reader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">姓名: 张麻子</span><br><span class="line">性别： 男</span><br><span class="line">年龄: 28</span><br><span class="line">自我评价： 好好啊好好好哈</span><br><span class="line">大学成绩：A A A</span><br><span class="line">毕业院校: 黄埔军校</span><br><span class="line">获得证书：教师资格证, 教官证</span><br><span class="line">人生格言: 公平，公平，还是tm的公平</span><br><span class="line">专业：打劫专业</span><br><span class="line">你好，我是四郎</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2><span id="12-filewriter-文件字符输出流">1.2 FileWriter 文件字符输出流</span></h2><h3><span id="121-构造方法">1.2.1 构造方法</span></h3><p><strong>FileWriter(String filename);</strong><br><strong>FileWriter(File filename);</strong><br><strong>FileWriter(String filename,boolean append);</strong><br><strong>FileWriter(File filename,boolean append);</strong><br>如果append为true，则将字节写入文件末尾处，相当于追加信息，反之则写在开头。</p><h3><span id="122-其他方法">1.2.2 其他方法</span></h3><p><strong>write(String str); 将str的内容写出到目的地。</strong></p><h3><span id="123-使用实例">1.2.3 使用实例</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件字符输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriterStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;四郎.txt&quot;</span>));</span><br><span class="line">        writer.write(<span class="string">&quot;我爱麻子。。&quot;</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="2缓冲字符io流">2.缓冲字符IO流</span></h1><p>缓冲流增强了读写文件的能力。<br>它的好处在于我们可以用它来有效率的读写文件。<br>BufferedReader和BufferedWriter类创建的对象称为缓冲输入流，缓冲输出流，<strong>缓冲流支持mark</strong>，它是普通字符输入流的一种增强。</p><h2><span id="21-bufferedreader-缓冲字符输入流">2.1. BufferedReader 缓冲字符输入流</span></h2><h3><span id="211-构造方法">2.1.1 构造方法</span></h3><p>BufferedReader(Reader in);</p><h3><span id="212-其他方法">2.1.2 其他方法</span></h3><p>BufferReader流能够通过调用readLine();读取文本行。</p><h3><span id="213-使用实例">2.1.3 使用实例</span></h3><p>我们可以通过向BufferedReader传递一个Reader子类的对象来创建一个BufferReader对象，如：<br>缓冲输入流使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReaderStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;麻子.txt&quot;</span>);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fileReader);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">            <span class="keyword">if</span>(str==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">姓名: 张麻子</span><br><span class="line">性别： 男</span><br><span class="line">年龄: 28</span><br><span class="line">自我评价： 好好啊好好好哈</span><br><span class="line">大学成绩：A A A</span><br><span class="line">毕业院校: 黄埔军校</span><br><span class="line">获得证书：教师资格证, 教官证</span><br><span class="line">人生格言: 公平，公平，还是tm的公平</span><br><span class="line">专业：打劫专业</span><br><span class="line">你好，我是四郎</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="22-bufferedwriter-缓存字符输出流">2.2 BufferedWriter 缓存字符输出流</span></h2><h3><span id="211-构造方法">2.1.1 构造方法</span></h3><p>BufferedWriter(Writer in);</p><h3><span id="212-其他方法">2.1.2 其他方法</span></h3><p>BufferedWriter流能够通过调用write(String str);写入文本行</p><p><strong>注意: 记得调用flush写入磁盘</strong></p><h3><span id="213-使用实例">2.1.3 使用实例</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedWriterStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;四郎.txt&quot;</span>));</span><br><span class="line">        writer.write(<span class="string">&quot;我是四郎，我爱麻子&quot;</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意： 在缓存流中的write方法不一定是写出到磁盘中,它是先存入缓存中,当调用flush()(或者缓存满了),输出流才会真正把数据写出。</strong></p><p>代码地址：<br><a href="https://gitee.com/yan-jiadou/study/tree/master/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/src/main/java/Progress/exa23">Java基础学习/src/main/java/Progress/exa23 · 严家豆/Study - 码云 - 开源中国 (gitee.com)</a></p> ]]>
        </content>
           
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;因为字节流不能很好地操作本身容量单位较大的数据（一个字符有时等于多个字节）,所以需要字符流。&lt;br&gt;
如果存在那种由多个字节组成的字符，那么用字节输入流读取，则会乱码！！！&lt;br&gt;
但是，如果用字符输入流读取，就不会出现乱码！！ 所以为了保险起见，</summary>
            
        <category term="Java进阶" scheme="https://1776167012.github.io/tags/Java%E8%BF%9B%E9%98%B6/" />
        
    </entry>
    
    <entry>
        <title>6.序列化对象克隆以及文件锁</title>
        <link href="https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-6-%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%E5%8F%8A%E6%96%87%E4%BB%B6%E9%94%81%E5%AD%A6%E4%B9%A0/" />
        <id>https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-6-%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86%E5%8F%8A%E6%96%87%E4%BB%B6%E9%94%81%E5%AD%A6%E4%B9%A0/</id>
        <published>2023-05-20T03:54:00.000Z</published>
        <updated>2026-01-05T03:33:15.910Z
        </updated>
        
        <content type="html">
            <![CDATA[ <h1><span id="1序列化对象克隆">1.序列化对象克隆</span></h1><p>我们也许学习过如何clone一个对象，就是通过Object中的clone方法实现，<br>但是我们必须知道，Object中的clone方法实现的是浅clone。<br>如果我们想要clone一个完整的对象，我们需要学习如何去实现，<br><strong>序列化对象就是一种比较简单的完全clone方式。</strong></p><h2><span id="11-什么是序列化与对象克隆">1.1 什么是序列化与对象克隆？</span></h2><p>有时想得到对象的一个“复制品”，使得复制品的变化不会引起原对象实体变化，反之亦然。<br>我们称这样的复制品为原对象的一个克隆对象（简称克隆）。</p><h2><span id="12-如何实现">1.2 如何实现？</span></h2><p>使用对象流(例如ObjectOutputStream)很容易获取一个序列化对象的克隆，只需将该对象输出流指向目的地，然后将该目的地作为一个对象输入流的源，<br>那么该对象输入流从源中读回的对象一定是原对象的一个克隆。简言之： 就是对象输入流通过对象的序列化信息得到当前对象的一个克隆。</p><p><strong>当程序想以较快的速度得到一个对象克隆时，可以用对象流将对象的序列化信息写入内存,然后从内存中读取对象</strong></p><h2><span id="13-实例展示">1.3 实例展示</span></h2><p>下面是对象克隆的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializableStudy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TV</span> <span class="variable">changhong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TV</span>();</span><br><span class="line">        changhong.setName(<span class="string">&quot;长虹电视&quot;</span>);</span><br><span class="line">        changhong.setPrice(<span class="number">5678</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;television.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//定义文件字节输出流，源为television.txt</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">            <span class="comment">//定义对象字节输出流</span></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">objectOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut);</span><br><span class="line">            <span class="comment">//将对象序列化信息写入源中</span></span><br><span class="line">            objectOut.writeObject(changhong);</span><br><span class="line">            <span class="comment">//关闭对象输出流</span></span><br><span class="line">            objectOut.close();</span><br><span class="line">            <span class="comment">//定义文件输入流，源为television.txt</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">            <span class="comment">//定义对象字节输入流</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">objectIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn);</span><br><span class="line">            <span class="comment">//将源中的对象读出得到changhong的克隆</span></span><br><span class="line">            <span class="type">TV</span> <span class="variable">xinfei</span> <span class="operator">=</span> (TV)objectIn.readObject();</span><br><span class="line">            objectIn.close();<span class="comment">//关闭对象输入流</span></span><br><span class="line">            System.out.println(<span class="string">&quot;changhong的名字：&quot;</span>+changhong.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;changhong的价格：&quot;</span>+changhong.getPrice());</span><br><span class="line">            System.out.println(<span class="string">&quot;changhong clone 的名字：&quot;</span>+xinfei.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;changhong clone 的价格&quot;</span>+xinfei.getPrice());</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException event)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不能读出对象&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException event)&#123;</span><br><span class="line">           event.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被克隆的对象必须实现标记接口Serializable</span></span><br><span class="line"><span class="comment"> * 否则进行序列化的时候（就是调用writeObject）会报错误：</span></span><br><span class="line"><span class="comment"> * java.io.NotSerializableException: Progress.exa24.TV</span></span><br><span class="line"><span class="comment"> at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184)</span></span><br><span class="line"><span class="comment"> at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)</span></span><br><span class="line"><span class="comment"> at Progress.exa24.SerializableStudy.main(SerializableStudy.java:19)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TV</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        name =s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        price = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPrice</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">changhong的名字：长虹电视</span><br><span class="line">changhong的价格：5678</span><br><span class="line">changhong clone 的名字：长虹电视</span><br><span class="line">changhong clone 的价格5678</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h1><span id="2文件锁">2.文件锁</span></h1><p>在实际的应用中，经常会出现几个程序处理同一个文件的情况发生，比如同时更新或读取文件。<br><strong>这种情况下，在多线程的情况中可能会造成冲突(出现数据不一致的情况)，Java提供了文件锁功能，可以帮助解决这样的问题。</strong></p><h2><span id="21filelock和filechannel类">2.1.FileLock和FileChannel类</span></h2><p>这两个类分别在java.nio和java.nio.channels包中。<br>输入，输出流读写文件时可以使用文件锁，以下结合RandomAccessFile类来说明文件锁的使用方法。</p><p>RandomAccessFile创建的流在读写文件时可以使用文件锁。<br>只要不解除该锁，其他程序无法操作被锁定的文件。</p><h2><span id="22-使用文件锁的步骤">2.2 使用文件锁的步骤</span></h2><p><strong>先使用RandomAccessFile流建立指向文件的流对象，该对象的读写属性必须是rw</strong>,<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile input=<span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;Example.java&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>然后input流调用方法getChannel();获得一个连接到底层文件的FileChannel对象（信道）</strong>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> input.getChannel();</span><br></pre></td></tr></table></figure><p>信道调用tryLock();或lock();方法获得一个FileLock(文件锁）对象，这一过程称作对文件加锁。<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileLock</span> <span class="variable">lock</span> <span class="operator">=</span> channel.tryLock();</span><br></pre></td></tr></table></figure><p>这一 过程有两个结果，要么成功，要么失败，如果失败了，我们需要进行重试获取锁，如果成功了，我们就可以对文件进行操作了。<br><strong>对文件加锁之后，如果想读，写文件必须让FileLock对象调用release();释放文件锁。</strong><br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.release();</span><br></pre></td></tr></table></figure><h2><span id="23编程实例">2.3编程实例</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileLock;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockWriteFile</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//创建文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果文件不存在，创建之</span></span><br><span class="line">            <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">                <span class="keyword">if</span>(file.createNewFile())&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;创建成功！！&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;创建失败！！&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对该文件加锁</span></span><br><span class="line">            <span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">            FileChannel fileChannel=randomAccessFile.getChannel();</span><br><span class="line">            FileLock fileLock=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 这一步就是尝试获取锁</span></span><br><span class="line">                    fileLock = fileChannel.tryLock();</span><br><span class="line">                    sleep(<span class="number">10000</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;有其他线程正在操作该文件，当前线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;休眠1000毫秒&quot;</span>);</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++)&#123;</span><br><span class="line">                sleep(<span class="number">10</span>);</span><br><span class="line">                StringBuffer sb=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">                sb.append(<span class="string">&quot;这是第&quot;</span>+i+<span class="string">&quot;行对应的数据&quot;</span>);</span><br><span class="line">                sb.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                randomAccessFile.write(sb.toString().getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            fileLock.release();</span><br><span class="line">            <span class="comment">//关闭信道</span></span><br><span class="line">            fileChannel.close();</span><br><span class="line">            <span class="comment">//关闭流</span></span><br><span class="line">            randomAccessFile.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程:&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;,写文件耗时： &quot;</span>+(System.currentTimeMillis()-start)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockWriteTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LockWriteFile</span> <span class="variable">writeFileThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockWriteFile</span>();</span><br><span class="line">        writeFileThread.setName(<span class="string">&quot;writeThread&quot;</span>);</span><br><span class="line">        <span class="type">LockWriteFile</span> <span class="variable">writeFileThread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockWriteFile</span>();</span><br><span class="line">        writeFileThread2.setName(<span class="string">&quot;writeThread2&quot;</span>);</span><br><span class="line">        writeFileThread.start();</span><br><span class="line">        writeFileThread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">有其他线程正在操作该文件，当前线程readFileThread休眠1000毫秒</span><br><span class="line">有其他线程正在操作该文件，当前线程readFileThread休眠1000毫秒</span><br><span class="line">有其他线程正在操作该文件，当前线程readFileThread休眠1000毫秒</span><br><span class="line">有其他线程正在操作该文件，当前线程readFileThread休眠1000毫秒</span><br><span class="line">有其他线程正在操作该文件，当前线程readFileThread休眠1000毫秒</span><br><span class="line">有其他线程正在操作该文件，当前线程readFileThread休眠1000毫秒</span><br><span class="line">有其他线程正在操作该文件，当前线程readFileThread休眠1000毫秒</span><br><span class="line">有其他线程正在操作该文件，当前线程readFileThread休眠1000毫秒</span><br><span class="line">有其他线程正在操作该文件，当前线程readFileThread休眠1000毫秒</span><br><span class="line">有其他线程正在操作该文件，当前线程readFileThread休眠1000毫秒</span><br><span class="line"></span><br><span class="line">当前线程:readFileThread2,读文件共花了15035毫秒</span><br><span class="line"></span><br><span class="line">当前线程:readFileThread,读文件共花了25123毫秒</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码地址：<br><a href="https://gitee.com/yan-jiadou/study/tree/master/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/src/main/java/Progress/exa24">Java基础学习/src/main/java/Progress/exa24 · 严家豆/Study - 码云 - 开源中国 (gitee.com)</a></p> ]]>
        </content>
           
        <summary type="html">&lt;h1&gt;&lt;span id=&quot;1序列化对象克隆&quot;&gt;1.序列化对象克隆&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;我们也许学习过如何clone一个对象，就是通过Object中的clone方法实现，&lt;br&gt;
但是我们必须知道，Object中的clone方法实现的是浅clone。&lt;br&gt;
如果我们想</summary>
            
        <category term="Java进阶" scheme="https://1776167012.github.io/tags/Java%E8%BF%9B%E9%98%B6/" />
        
    </entry>
    
    <entry>
        <title>7.Java操作MySQL的步骤(JDBC)</title>
        <link href="https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-7-Java%E6%93%8D%E4%BD%9Cmysql%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4%EF%BC%88JDBC%EF%BC%89/" />
        <id>https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-7-Java%E6%93%8D%E4%BD%9Cmysql%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4%EF%BC%88JDBC%EF%BC%89/</id>
        <published>2023-05-20T03:53:00.000Z</published>
        <updated>2026-01-05T03:33:15.910Z
        </updated>
        
        <content type="html">
            <![CDATA[ <h1><span id="1基本步骤">1.基本步骤</span></h1><ul><li>首先在电脑上安装mysql，创建相应的数据库和表</li><li>然后在开发项目中导入相应的jar包</li><li>最后在代码中调用相应类进行调用。</li></ul><h1><span id="2实例演示">2.实例演示</span></h1><h2><span id="21事先在mysql中创建名为jdbc的数据库">2.1.事先在mysql中创建名为jdbc的数据库</span></h2><p>建立user的表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">create database jdbc;</span></span><br><span class="line">Query OK, 1 row affected (0.05 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">use jdbc</span></span><br><span class="line">Database changed</span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">create table <span class="built_in">users</span>(</span></span><br><span class="line">    -&gt; id int primary key auto_increment,</span><br><span class="line">    -&gt; name varchar(40),</span><br><span class="line">    -&gt; password varchar(40),</span><br><span class="line">    -&gt; email varchar(60),</span><br><span class="line">    -&gt; birthday date)character set utf8 collate utf8_general_ci;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.11 sec)</span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">insert into <span class="built_in">users</span>(name,password,email,birthday)</span></span><br><span class="line">    -&gt; values(&#x27;zs&#x27;,&#x27;123456&#x27;,&#x27;zs@sina.com&#x27;,&#x27;1980-12-03&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.09 sec)</span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash"><span class="keyword">select</span> * from <span class="built_in">users</span>;</span></span><br><span class="line">+----+------+----------+-------------+------------+</span><br><span class="line">| id | name | password | email       | birthday   |</span><br><span class="line">+----+------+----------+-------------+------------+</span><br><span class="line">|  1 | zs   | 123456   | zs@sina.com | 1980-12-03 |</span><br><span class="line">+----+------+----------+-------------+------------+</span><br></pre></td></tr></table></figure><p><strong>或者可以使用mysql自带的数据库world（无需自己新建）进行查询，本例选择后者。</strong></p><h2><span id="22然后程序中连接mysql">2.2.然后程序中连接mysql</span></h2><p>首先，java的mysql驱动jar包导入项目中。</p><p><strong>maven项目</strong>可以直接添加配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">8.0</span><span class="number">.12</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p><strong>普通项目</strong>可以通过这种方式添加：<br>首先在<br><a href="https://mvnrepository.com/artifact/mysql/mysql-connector-java/8.0.30">https://mvnrepository.com/artifact/mysql/mysql-connector-java/8.0.30</a><br>下载jar包，然后将jar包导入自己的项目依赖中即可。</p><p>然后写入下列代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Progress.exa25;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcStudy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Statement stmt=<span class="literal">null</span>;</span><br><span class="line">        ResultSet rs=<span class="literal">null</span>;</span><br><span class="line">        Connection conn=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//加载驱动程序</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">            String url=<span class="string">&quot;jdbc:mysql://localhost:3306/world?&amp;useSSL=false&amp;serverTimezone=UTC&quot;</span>;</span><br><span class="line">            String username=<span class="string">&quot;root&quot;</span>;</span><br><span class="line">            String password=<span class="string">&quot;root&quot;</span>;</span><br><span class="line">            <span class="comment">//建立连接</span></span><br><span class="line">            conn = DriverManager.getConnection(url,username,password);</span><br><span class="line">            <span class="comment">//操作数据</span></span><br><span class="line">            stmt= conn.createStatement();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from city&quot;</span>;</span><br><span class="line">            rs = stmt.executeQuery(sql);</span><br><span class="line">            System.out.println(<span class="string">&quot;id|name|countryCode|&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">countryCode</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;countryCode&quot;</span>);</span><br><span class="line">                System.out.println(id +<span class="string">&quot; | &quot;</span>+name+<span class="string">&quot; | &quot;</span>+countryCode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放资源</span></span><br><span class="line">            <span class="keyword">if</span>(rs!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    rs.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                rs=<span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(stmt!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                stmt=<span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">if</span>(conn!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                   conn.close();</span><br><span class="line">               &#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                conn=<span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">id|name|countryCode|</span><br><span class="line">1 | Kabul | AFG</span><br><span class="line">2 | Qandahar | AFG</span><br><span class="line">3 | Herat | AFG</span><br><span class="line">4 | Mazar-e-Sharif | AFG</span><br><span class="line">5 | Amsterdam | NLD</span><br><span class="line">6 | Rotterdam | NLD</span><br><span class="line">7 | Haag | NLD</span><br><span class="line">8 | Utrecht | NLD</span><br><span class="line">9 | Eindhoven | NLD......//后面的就不展示了</span><br></pre></td></tr></table></figure><p>运行之，成功访问。</p><p><a href="https://gitee.com/yan-jiadou/study/tree/master/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/src/main/java/Progress/exa25">代码地址：Java基础学习/src/main/java/Progress/exa25 · 严家豆/Study - 码云 - 开源中国 (gitee.com)</a></p> ]]>
        </content>
           
        <summary type="html">&lt;h1&gt;&lt;span id=&quot;1基本步骤&quot;&gt;1.基本步骤&lt;/span&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;首先在电脑上安装mysql，创建相应的数据库和表&lt;/li&gt;
&lt;li&gt;然后在开发项目中导入相应的jar包&lt;/li&gt;
&lt;li&gt;最后在代码中调用相应类进行调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h</summary>
            
        <category term="Java进阶" scheme="https://1776167012.github.io/tags/Java%E8%BF%9B%E9%98%B6/" />
        
    </entry>
    
    <entry>
        <title>8.Java泛型,通配泛型,消除泛型和泛型的限制</title>
        <link href="https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-8-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%B3%9B%E5%9E%8B%EF%BC%8C%E9%80%9A%E9%85%8D%E6%B3%9B%E5%9E%8B%EF%BC%8C%E6%B6%88%E9%99%A4%E6%B3%9B%E5%9E%8B%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%9A%84%E9%99%90%E5%88%B6/" />
        <id>https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-8-Java%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%B3%9B%E5%9E%8B%EF%BC%8C%E9%80%9A%E9%85%8D%E6%B3%9B%E5%9E%8B%EF%BC%8C%E6%B6%88%E9%99%A4%E6%B3%9B%E5%9E%8B%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%9A%84%E9%99%90%E5%88%B6/</id>
        <published>2023-05-20T03:52:00.000Z</published>
        <updated>2026-01-05T03:33:15.910Z
        </updated>
        
        <content type="html">
            <![CDATA[ <h1><span id="1什么是泛型">1.什么是泛型？</span></h1><p>在我看来，可以将泛型编程机制看作一个工具，通过这个工具我们可以在代码编译时检测出某些<strong>运行</strong>错误，<br>并写出更为通用（抽象）， 可复用的代码。<br>从JDK1.5开始，Java允许定义泛型类，泛型接口，泛型方法。这样我们就可以在Java中使用泛型机制写出更为通用的程序。</p><h2><span id="11-如何定义泛型类接口方法">1.1. 如何定义泛型类，接口，方法</span></h2><h3><span id="111泛型类">1.1.1.泛型类</span></h3><p>泛型相当于一些类型数据的抽象，泛型程序设计意味着编写的泛型代码可以对多种不同类型的对象复用。<strong>（体现代码的复用原则）</strong></p><p><strong>首先我们要注意泛型类型必须是引用类型（不能是int double …的基本类型)</strong></p><h4><span id="泛型类的示例">泛型类的示例</span></h4><p>下面编写了一个泛型类, 意味着可以向这个类中存入任意类型的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericStack</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//定义一个链表，链表中存储的元素设定为E</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;E&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型方法peek</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(getSize()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E o)</span> &#123;</span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型方法pop</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">o</span> <span class="operator">=</span> list.get(getSize()-<span class="number">1</span>);</span><br><span class="line">        list.remove(getSize()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的类，我们就可以称之为泛型类了，因为它的定义使用了泛型机制。<br>在定义类的时候在类名后面添加 类似于 <e> 的代码：</e></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericStack</span> &lt; E &gt;</span><br></pre></td></tr></table></figure><p>时，我们就为这个类定义了泛型E,在类中，我们可以将E当作一个类进行使用，这个类是在使用GenericStack时定义的。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    GenericStack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">GenericStack</span>&lt;&gt;();</span><br><span class="line">    stack.push(<span class="string">&quot;number1&quot;</span>);</span><br><span class="line">    stack.push(<span class="string">&quot;number2&quot;</span>);</span><br><span class="line">    System.out.println(stack.pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">number2</span><br><span class="line"></span><br><span class="line">Process finished with exit code 1</span><br></pre></td></tr></table></figure><p>当我们尝试弹入非String的数据时，在编译期就会报错:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E:\Personal\MyRepository\study\Java基础学习\src\main\java\Progress\exa26\GenericClass.java:11:20</span><br><span class="line">java: 不兼容的类型: int无法转换为java.lang.String</span><br></pre></td></tr></table></figure><p><strong>如果没有使用泛型，在程序运行到这一段时才会报错。</strong></p><p>比如我们把上面的泛型删掉用Object类型来编写一个相同作用的类，再看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericStack1</span>&#123;</span><br><span class="line">    <span class="comment">//定义一个链表，链表中存储的元素设定为E</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(getSize()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.get(getSize()-<span class="number">1</span>);</span><br><span class="line">        list.remove(getSize()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试之：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericStack1</span> <span class="variable">stack1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericStack1</span>();</span><br><span class="line">    stack1.push(<span class="number">11</span>);</span><br><span class="line">    System.out.println((String)stack1.pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译没有报错，下面运行的时候报错了：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br><span class="line">at Progress.exa26.GenericClass.main(GenericClass.java:15)</span><br><span class="line"></span><br><span class="line">Process finished with exit code 1</span><br></pre></td></tr></table></figure><p><strong>结论：使用泛型可以有效避免强转所造成的运行时错误(RuntimeException)。</strong></p><h3><span id="112-泛型接口">1.1.2 泛型接口</span></h3><p>泛型接口的定义和泛型类一样，在合适的位置加上E即可。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Maximum</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">getMax</span><span class="params">(T[] array)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MaximumImp</span> <span class="variable">maximumImp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MaximumImp</span>();</span><br><span class="line">        System.out.println(maximumImp.getMax(<span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">interface</span> <span class="title class_">Maximum</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">getMax</span><span class="params">(T[] array)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaximumImp</span> <span class="keyword">implements</span> <span class="title class_">Maximum</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMax</span><span class="params">(String[] array)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3><span id="113-泛型方法">1.1.3 泛型方法</span></h3><p>泛型方法除了在泛型类中定义，也可以在普通类中定义<br>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayAlg</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getMiddle</span><span class="params">(T... a)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[a.length/<span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：类型变量放在修饰符后，返回类型的前面。</strong></p><p>当我们调用一个泛型方法时，我们可以把具体类型包围在尖括号中，放在方法名前面，例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">middle</span> <span class="operator">=</span>GenericMethod.&lt;String&gt;getMiddle(<span class="string">&quot;join&quot;</span>,<span class="string">&quot;R&quot;</span>,<span class="string">&quot;fasd&quot;</span>);</span><br><span class="line">        System.out.println(middle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getMiddle</span><span class="params">(T... a)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实在实际的编程中我们可以省略掉&lt; String &gt;而不对结果产生影响，原因是编译器会根据已有信息来对泛型类型进行推导，<br>这也是一种编程技巧。</p><h1><span id="2使用泛型编程的好处">2.使用泛型编程的好处</span></h1><p>前面学习了一些泛型的基础，我们知道了如何使用泛型机制进行编程，那么问题来了，泛型编程适合编写什么样的程序？<br><strong>泛型比较适合编写一些通用的程序出来，用来提高编程效率，简化编程工作。</strong><br>使代码具有更好的可读性和安全性，复用性，通用性，提高工作效率。</p><h1><span id="3谁想成为合格的泛型程序员">3.谁想成为合格的泛型程序员？</span></h1><h2><span id="31-作为一个泛型程序员我们的任务就是要预计到我们的泛型类所有可能的用法">3.1 作为一个泛型程序员，我们的任务就是要预计到我们的泛型类所有可能的用法。</span></h2><p>这个任务会有多难呢？<br>我们可以看一个典型的问题：ArrayList类中有一个方法addAll用来添加另一个集合的全部元素。<br><strong>现在：Manager extends Emplyee</strong><br>一个程序员可能想要将一个ArrayList&lt; Manager &gt;中的所有元素添加到一个ArrayList&lt; Emplyee &gt;中去，这是可以的，但是反过来就不行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Manager&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">ArrayList&lt;Emplyee&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayLsit</span>();</span><br><span class="line">list1.addAll(list);<span class="comment">//这个是可以的，因为Manager继承了Emplyee</span></span><br><span class="line">list.add(list1);<span class="comment">//这个就不行了</span></span><br></pre></td></tr></table></figure><p>但是目前我们所学的知识，泛型编程也无法避免这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericWildcard</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Manager&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Manager</span>());</span><br><span class="line">        ArrayList&lt;Emplyee&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list1.add(<span class="keyword">new</span> <span class="title class_">Emplyee</span>());</span><br><span class="line">        <span class="comment">//list1.addAll(list);//这个是可以的，因为Manager继承了Emplyee</span></span><br><span class="line">        list.addAll(list1);<span class="comment">//这个就不行了</span></span><br><span class="line">        list.value[<span class="number">0</span>].sysoutI();<span class="comment">//这个就不行了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt;&#123;</span><br><span class="line">    E[] value;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span>&#123;</span><br><span class="line">        value = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        value[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;E&gt; <span class="title function_">addAll</span><span class="params">(ArrayList&lt;?&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            value[i] = (E)list.value[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Emplyee</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sysoutI</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Emplyee</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [LProgress.exa26.Manager;</span><br><span class="line">at Progress.exa26.GenericWildcard.main(GenericWildcard.java:11)</span><br><span class="line"></span><br><span class="line">Process finished with exit code 1</span><br></pre></td></tr></table></figure><p><strong>那么，如何在编译期间允许前一个调用，而不允许后一个调用方式呢？也就是如何让编译器在程序运行前发现这个错误？</strong><br>java语言的设计者发明了一个具有独创性的概念来解决这个问题： <strong>通配符类型（通配泛型）</strong><br><strong>通过通配泛型符，Java代码可以在编译期间发现本来可以避免的错误，并让程序员及时修复。<br>下面的4,5,6节将对这一机制进行详细学习。</strong></p><h2><span id="32-泛型程序设计的三个水平">3.2 泛型程序设计的三个水平</span></h2><p>基本水平就是仅仅使用泛型类，而不考虑它们如何工作以及为什么这样做。<br>中等水平就是可以在混合使用不同的泛型类时能系统的解决各种问题，而不是胡乱猜测。<br>高等水平就是能自己设计出能够应用于多种场景的泛型类。</p><p><strong>注意：Java库中使用变量E表示集合的元素类型，K和V表示键和值的类型。 T（必要时还可以用U,S）表示其他任意类型。</strong></p><h1><span id="4原始类型和向后兼容">4.原始类型和向后兼容</span></h1><h2><span id="41我们也可以使用泛型类而无需指定具体类型这时泛型默认为object">4.1.我们也可以使用泛型类而无需指定具体类型：（这时泛型默认为Object）</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GenericStack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericStack</span>();</span><br></pre></td></tr></table></figure><p>上面语句等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GenericStack&lt;Object&gt; stack = <span class="keyword">new</span> <span class="title class_">GenericStack</span>&lt;Object&gt;();</span><br></pre></td></tr></table></figure><p>像这样的不带参数的泛型类称为原始类型，使用原始类型可以向后兼容Java的早期版本的代码。<br>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>));</span><br><span class="line">    System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line">    System.out.println(list.get(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="42类型擦除">4.2.类型擦除</span></h2><p>在java虚拟机中，对于泛型程序其实会做一个类型消除的操作的，例如下面泛型接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Maximum</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    T <span class="title function_">getMax</span><span class="params">(T[] array)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在虚拟机中的class字节码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Maximum</span>&#123;</span><br><span class="line">    Comparable <span class="title function_">getMax</span><span class="params">(Comparable[] array)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面进行类型擦除的接口我们称之为这个泛型类的<strong>原始类型</strong>，这点很重要，因为我们获取的泛型类的Class对象其实就是原始类型的Class。<br>从这里我们大概可以知道泛型机制的实现原理，就是编译器通过解析泛型程序，根据泛型程序的定义将程序编译为具体类型的字节码JVM解释。</p><h1><span id="5通配泛型">5.通配泛型</span></h1><ul><li><p>？称为非受限通配泛型，它和？extends Object是一样的。</p></li><li><p>？extends T称为受限通配泛型，表示T或T的一个子类型。</p></li><li><p>？super T称为下限通配泛型，它表示T或T的一个父类型。<br>通过通配泛型，我们便可以在编译期发现3.1节出现的错误。</p><p>如下图所示：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wildcard</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Emplyee&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Manager&gt; list1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    list1.addAll(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法在编译期就会抛出异常.</p><p><strong>通配泛型符可以让我们在定义泛型类时限制泛型的使用场景，将错误的场景排除在外，避免在运行时出现事故。</strong></p><h1><span id="6消除泛型和对泛型的限制">6.消除泛型和对泛型的限制</span></h1><p>泛型是使用<strong>类型消除机制</strong>的方法来实现的。<br><strong>编译器使用泛型类型信息来编译代码，但是随后会消除它。</strong><br>因此泛型信息在运行时是不可用的，<strong>这种方法可以使泛型代码向后兼容使用原始类型的遗留代码。</strong></p><p>在这过程中 注意：</p><ul><li>如果一个泛型类型是受限的，那么编译器就用该受限类型替换它。</li><li>不管实际的具体类型是什么，泛型类是被它的所有实例所共享的。</li></ul><p>由于泛型类型在运行时被消除，因此对如何使用泛型类型有如下限制：</p><ul><li>不能使用 new E()；不能使用泛型类型参数创建实例。</li><li>不能使用new E[];不能使用泛型类型参数创建数组</li><li>在静态上下文中不允许类的参数是泛型类型。</li><li>异常类不能是泛型的。</li></ul><p>代码地址：<br><a href="https://gitee.com/yan-jiadou/study/tree/master/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/src/main/java/Progress/exa26">Java基础学习/src/main/java/Progress/exa26 · 严家豆/Study - 码云 - 开源中国 (gitee.com)</a></p><p>如果通过上面的学习，你了解了如何使用泛型，不妨学习一下下面的泛型编程Demo专栏巩固一下：<br><a href="https://blog.csdn.net/c1776167012/category_11511225.html?spm=1001.2014.3001.5482">Java动手做一做之泛型编程</a></p> ]]>
        </content>
           
        <summary type="html">&lt;h1&gt;&lt;span id=&quot;1什么是泛型&quot;&gt;1.什么是泛型？&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;在我看来，可以将泛型编程机制看作一个工具，通过这个工具我们可以在代码编译时检测出某些&lt;strong&gt;运行&lt;/strong&gt;错误，&lt;br&gt;
并写出更为通用（抽象）， 可复用的代码。&lt;br&gt;
</summary>
            
        <category term="Java进阶" scheme="https://1776167012.github.io/tags/Java%E8%BF%9B%E9%98%B6/" />
        
    </entry>
    
    <entry>
        <title>9.1 Java集合接口学习</title>
        <link href="https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-9-1-Java%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0/" />
        <id>https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-9-1-Java%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0/</id>
        <published>2023-05-20T03:51:00.000Z</published>
        <updated>2026-01-05T03:33:15.911Z
        </updated>
        
        <content type="html">
            <![CDATA[ <h1><span id="1集合即数据结构概述">1.集合(即数据结构)概述</span></h1><p>首先我们要知道，Java合集框架中定义的所有接口和类都在java.util包中。<br>其次我们需要知道Java提供了那些数据结构供我们使用？</p><p>Java中的算法结构可分为下面几大种类：</p><ul><li>Set 用于存储一组不重复的元素。（它的重要特性是<strong>不重复</strong>）</li><li>List 链表（它的重要特性是<strong>顺序存储</strong>）</li><li>Stack 栈（它的重要特性是：<strong>先进后出，后进先出</strong>）</li><li>Queue 队列（它的重要特性是：<strong>先进先出，后进后出</strong>）</li><li>Priority Queue 优先队列（特性的重要特性是<strong>优先级</strong>）</li><li>Map 映射（特性是<strong>键值对存储</strong>）</li></ul><p>集合框架部分结构图</p><p>图一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">AbstractCollection--impl--&gt;Collection</span><br><span class="line"></span><br><span class="line">Set--extend--&gt;Collection</span><br><span class="line"></span><br><span class="line">List--extend--&gt;Collection</span><br><span class="line"></span><br><span class="line">Queue--extend--&gt;Collection</span><br><span class="line"></span><br><span class="line">AbstractSet--impl--&gt;Set</span><br><span class="line"></span><br><span class="line">AbstractList--extend--&gt;AbstractCollection</span><br><span class="line"></span><br><span class="line">AbstractList--impl--&gt;List</span><br><span class="line"></span><br><span class="line">Deque--extend--&gt;Queue</span><br><span class="line"></span><br><span class="line">ListedList --impl--&gt;Deque</span><br><span class="line"></span><br><span class="line">AbstractSet--extend--&gt;AbstractCollection</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SortedSet--impl--&gt;Set</span><br><span class="line"></span><br><span class="line">HashSet--extend--&gt;AbstractSet</span><br><span class="line"></span><br><span class="line">Vector--extend--&gt;AbstractList</span><br><span class="line"></span><br><span class="line">ArrayList--extend--&gt;AbstractList</span><br><span class="line"></span><br><span class="line">AbstractSequentialList--extend--&gt;AbstractList</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>图二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">NavigableSet--extend--&gt;SortedSet</span><br><span class="line"></span><br><span class="line">LinkedHashSet--extend--&gt;HashSet</span><br><span class="line"></span><br><span class="line">Stack--extend--&gt;Vector</span><br><span class="line"></span><br><span class="line">TreeSet--extend--&gt;AbstractSet</span><br><span class="line"></span><br><span class="line">TreeSet--impl--&gt;NavigableSet</span><br><span class="line"></span><br><span class="line">LinkedList--extend--&gt;AbstractSequentialList</span><br><span class="line"></span><br><span class="line">PriorityQueue--extend--&gt;AbstractQueue</span><br><span class="line"></span><br><span class="line">AbstractQueue--impl--&gt;Deque</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们先关注Set,List,Queue都继承了一个共同的接口Collection.</p><p>在Java中基本的数据结构类都继承了Collection接口，所有在Collection接口中定义了一个基本数据结构应该有的操作。</p><h2><span id="11我们先看下collection接口定义了解即可">1.1.我们先看下Collection接口定义（了解即可）</span></h2><h3><span id="111-接口声明定义">1.1.1 接口声明定义</span></h3><p><strong>public interface Collection&lt; E &gt; extends Iterable&lt; E &gt;</strong></p><p>我们可以看到Collection接口的声明还继承了Iterable接口，这个我们后面再来介绍,先来学习下Collection中定义的方法。</p><h3><span id="112-collection接口方法定义">1.1.2  Collection接口方法定义</span></h3><table><thead><tr><th>方法定义</th><th>方法描述</th></tr></thead><tbody><tr><td>int size();</td><td>返回此集合中的元素个数。</td></tr><tr><td>boolean isEmpty();</td><td>如果集合为空，返回true</td></tr><tr><td>boolean contains(Object o);</td><td>如果此集合包含指定的元素，则返回true。</td></tr><tr><td>Iterator<e> iterator();</e></td><td>返回此集合中元素的迭代器。</td></tr><tr><td>Object[] toArray();</td><td>返回一个包含此集合中所有元素的数组。</td></tr><tr><td><t> T[] toArray(T[] a);</t></td><td>返回指定泛型的类型数组</td></tr><tr><td>boolean add(E e);</td><td>添加元素</td></tr><tr><td>boolean remove(Object o);</td><td>删除元素</td></tr><tr><td>boolean containsAll(Collection&lt;?&gt; c);</td><td>如果此集合包含指定集合的所有元素，则返回true。</td></tr><tr><td>boolean addAll(Collection&lt;? extends E&gt; c);</td><td>将指定集合中的所有元素添加到此集合</td></tr><tr><td>boolean removeAll(Collection&lt;?&gt; c);</td><td>将指定集合中的所有元素移出此集合</td></tr><tr><td>boolean retainAll(Collection&lt;?&gt; c);</td><td>仅保留此集合中包含在指定集合中的元素(可选操作)。</td></tr><tr><td>void clear();</td><td>删除集合所有元素</td></tr><tr><td>boolean equals(Object o);</td><td>将指定的对象与此集合进行相等性比较。</td></tr><tr><td>int hashCode();</td><td>返回此集合的哈希码值。</td></tr><tr><td>boolean removeIf(Predicate&lt;? super E&gt;  filter)</td><td>删除此集合中满足给定Predicate的所有元素。</td></tr></tbody></table><p>其中removeIf，Collection中给出了默认实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  在学习此方法之前我们应先了解什么是default关键字：</span></span><br><span class="line"><span class="comment">  https://blog.csdn.net/qq_35835624/article/details/80196932</span></span><br><span class="line"><span class="comment">  删除此集合中满足给定Predicate的所有元素。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">   <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeIf</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> E&gt; filter)</span> &#123;</span><br><span class="line">       Objects.requireNonNull(filter);</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">final</span> Iterator&lt;E&gt; each = iterator();</span><br><span class="line">       <span class="keyword">while</span> (each.hasNext()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (filter.test(each.next())) &#123;</span><br><span class="line">               each.remove();</span><br><span class="line">               removed = <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> removed;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>看完上面的Colletion的定义，我们大概知道了定义一个具体集合类需要赋予这个集合类的能力有哪些。</strong></p><h2><span id="12iterable接口">1.2.Iterable接口</span></h2><p>下面我们看一下Iterable接口的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   组合Iterator接口，返回类型为T的元素的迭代器。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为Iterable的每个元素执行给定的操作，直到处理完所有元素或者操作抛出异常。 </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(action);<span class="comment">//检查要遍历的对象是否为空</span></span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="built_in">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在这个Iterable描述的元素上创建一个Spliterator。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的主要作用在于提供快速遍历集合的一个方式，我们可以看到，这个接口组合了Iterator接口。</p><p>下面看一下Iterator接口的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断集合是否拥有下一个元素</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取下一个元素</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 删除当前元素</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;remove&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 遍历元素</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="13collection的子接口">1.3.Collection的子接口</span></h2><h3><span id="131-list接口">1.3.1 List接口</span></h3><p>Collection的子接口除了继承Collection定义的方法外，还能根据自己的特性自己定义出自己的方法。</p><p>比如说List接口中,新增了一些List结构的特性方法定义：<br>例如：</p><table><thead><tr><th>方法定义</th><th>描述</th></tr></thead><tbody><tr><td>E get(int index)</td><td>获取第index个位置上的元素</td></tr><tr><td>int indexOf(E object)</td><td>获取元素object再List中的位置</td></tr></tbody></table><p>等方法.</p><h3><span id="132-abstractlist实现list接口">1.3.2 AbstractList实现List接口</span></h3><p>AbstractList抽象类提供了List接口的部分实现,它的作用是代码复用，减少具体的List实现类的开发难度。</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">ArrayList--extend--&gt;AbstractList</span><br><span class="line"></span><br><span class="line">ArrayQueue--extend--&gt;AbstractList</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>等等,一些面向开发者的具体集合类都通过继承抽象实现类来减少开发工作量.</p><p><strong>通过上面的学习我们知道了Java中合集数据结构大概的实现流程，我们可以带着这个思路去学习其他的java合集。</strong></p><h2><span id="14-jdk定义一个具体集合的步骤">1.4 JDK定义一个具体集合的步骤</span></h2><ul><li>根据定义的集合特性新建一个接口并继承Collection接口</li><li>新建一个AbstractionCollection抽象类实现定义的接口提供一个基础实现</li><li>最后根据自己的需要继承AbstractionCollection抽象类得到最后的集合实现类</li></ul><h2><span id="15-java自己动手做一个集合类">1.5 Java自己动手做一个集合类</span></h2><p>通过上面的学习，下面我们来实现一个自己的集合SelfList</p><h3><span id="151-定义接口selflist">1.5.1 定义接口SelfList</span></h3><p>首先定义出SelfList的接口,规范它的能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Progress.exa27_1;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SelfList接口定义</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SelfList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将元素添加到链表头部</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addHead</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将元素添加到链表尾部</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addTail</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此方法删除元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    E <span class="title function_">delete</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取列表中位置i上的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    E <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取列表的第一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    E <span class="title function_">getHead</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取列表的最后一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    E <span class="title function_">getTail</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="152-定义抽象实现类abstractionselflist">1.5.2 定义抽象实现类AbstractionSelfList</span></h3><p>然后定义它的抽象实现类,将其中的可抽象的实现提供默认的实现.</p><p>例如, 给add方法提供一个默认实现,抛出一个异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Progress.exa27_1;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractionSelfList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">SelfList</span>&lt;E&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="152-定义具体实现类arrayselflist">1.5.2 定义具体实现类ArraySelfList</span></h3><p>下面展示部分实现部分，完整代码需要访问代码地址去看(文章末尾)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Progress.exa27_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraySelfList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractionSelfList</span>&lt;E&gt;&#123;</span><br><span class="line"></span><br><span class="line">     <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     Object[] elementData;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">         builder.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">         <span class="keyword">for</span>(Object e:elementData)&#123;</span><br><span class="line">             <span class="keyword">if</span>(e!=<span class="literal">null</span>)&#123;</span><br><span class="line">                 builder.append(e.toString()).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         builder.replace(builder.length()-<span class="number">1</span>,builder.length(),<span class="string">&quot;&quot;</span>);</span><br><span class="line">         builder.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> builder.toString();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">ArraySelfList</span><span class="params">()</span>&#123;</span><br><span class="line">         elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">16</span>];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">ArraySelfList</span><span class="params">(<span class="type">int</span> capacity)</span>&#123;</span><br><span class="line">         elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHead</span><span class="params">(E e)</span> &#123;</span><br><span class="line">         <span class="comment">//如果是第一次添加</span></span><br><span class="line">         <span class="keyword">if</span>(size==<span class="number">0</span>)&#123;</span><br><span class="line">             elementData[<span class="number">0</span>] = e;</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span>(size&lt;elementData.length)&#123;</span><br><span class="line">             Object[] temp = <span class="keyword">new</span> <span class="title class_">Object</span>[elementData.length];</span><br><span class="line">             System.arraycopy(elementData,<span class="number">0</span>,temp,<span class="number">1</span>,size);</span><br><span class="line">             temp[<span class="number">0</span>] = e;</span><br><span class="line">             elementData = temp;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             Object[] temp = <span class="keyword">new</span> <span class="title class_">Object</span>[elementData.length+<span class="number">5</span>];</span><br><span class="line">             System.arraycopy(elementData,<span class="number">0</span>,temp,<span class="number">1</span>,size);</span><br><span class="line">             temp[<span class="number">0</span>] = e;</span><br><span class="line">             elementData = temp;</span><br><span class="line">         &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTail</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(size&lt;elementData.length)&#123;</span><br><span class="line">            elementData[size++] = e;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Object[] temp = <span class="keyword">new</span> <span class="title class_">Object</span>[elementData.length+<span class="number">5</span>];</span><br><span class="line">            System.arraycopy(elementData,<span class="number">0</span>,temp,<span class="number">0</span>,size);</span><br><span class="line">            temp[size++] = e;</span><br><span class="line">            elementData = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">delete</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span>(i&lt;size)</span><br><span class="line">           <span class="keyword">return</span> (E)elementData[i];</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="154-测试使用">1.5.4 测试使用</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Progress.exa27_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraySelfListTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArraySelfList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArraySelfList</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">        list.addHead(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        list.addHead(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        list.addTail(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(list.get(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[first]</span><br><span class="line">[second,first]</span><br><span class="line">[second,first,three]</span><br><span class="line">three</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>代码地址：<br><a href="https://gitee.com/yan-jiadou/study/tree/master/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/src/main/java/Progress/exa27_1">Java基础学习/src/main/java/Progress/exa27_1 · 严家豆/Study - 码云 - 开源中国 (gitee.com)</a></p> ]]>
        </content>
           
        <summary type="html">&lt;h1&gt;&lt;span id=&quot;1集合即数据结构概述&quot;&gt;1.集合(即数据结构)概述&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;首先我们要知道，Java合集框架中定义的所有接口和类都在java.util包中。&lt;br&gt;
其次我们需要知道Java提供了那些数据结构供我们使用？&lt;/p&gt;
&lt;p&gt;Java中</summary>
            
        <category term="Java进阶" scheme="https://1776167012.github.io/tags/Java%E8%BF%9B%E9%98%B6/" />
        
    </entry>
    
    <entry>
        <title>9.2 Java集合基础学习(集合基本概念,基础接口)</title>
        <link href="https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-9-2-java%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E9%9B%86%E5%90%88%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E7%A1%80%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0%EF%BC%89/" />
        <id>https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-9-2-java%E9%9B%86%E5%90%88%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E9%9B%86%E5%90%88%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E7%A1%80%E6%8E%A5%E5%8F%A3%E5%AD%A6%E4%B9%A0%EF%BC%89/</id>
        <published>2023-05-20T03:50:00.000Z</published>
        <updated>2026-01-05T03:33:15.911Z
        </updated>
        
        <content type="html">
            <![CDATA[ <p>学习总结自《java核心技术卷Ⅰ》</p><h1><span id="1java集合框架">1.Java集合框架</span></h1><p>Java最初的版本只为最常用的数据结构提供了一组类：Vector(链表),Stack(栈),Hashtable(哈希表)，<br>BitSet(位集合)和Enumeration（枚举）接口。 其中的Enumeration接口提供了一种用于访问任意容器中各个元素的抽象机制，<br>这句话的意思实际上说的就是我们可以实现这个接口来访问任意容器的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Enumeration</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasMoreElements</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">nextElement</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过现在迭代器更为常用，现在Java中的集合框架经过发展已经支持很多数据结构了。</p><h2><span id="11java集合设计思想">1.1.Java集合设计思想</span></h2><p>Java集合框架的一个中心思想是接口和实现分离。这种机制较好的保持了一些集合的特性,又给开发者提供了灵活的实现方式和增加一些特性。</p><h3><span id="111-自定义队列">1.1.1 自定义队列</span></h3><p>下面我们通过自己构造队列的一种实现是如何被定义的来了解如何分离的</p><ul><li>首先我们要定义一个队列接口</li></ul><p>队列接口应指出可以在队列的尾部添加元素，在队列的头部删除元素，并且可以查询队列中元素的个数。<br>其最简单形式类似下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span>&lt;E&gt;&#123;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span>;<span class="comment">//尾部添加元素</span></span><br><span class="line"> E <span class="title function_">remove</span><span class="params">()</span>;<span class="comment">//头部删除元素</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;<span class="comment">//查询元素个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后我们要实现它:<br>上面的接口并没有说明队列是如何实现的，所以我们要实现它来实现队列，队列通常有两种实现方式：<strong>循环数组实现，链表实现</strong><br>下面分别大体实现下：</li></ul><p>i.循环数组实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularArrayQueue</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> head;<span class="comment">//定义队列头元素</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> tail;<span class="comment">//队列尾元素</span></span><br><span class="line">  CircularArrayQueue(<span class="type">int</span> capacity)&#123;......&#125;<span class="comment">//队列构造函数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span>&#123;......&#125;<span class="comment">//添加元素</span></span><br><span class="line">  <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span>&#123;......&#125;<span class="comment">//删除元素</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;......&#125;<span class="comment">//返回队列大小</span></span><br><span class="line">  <span class="keyword">private</span> E[] elements;<span class="comment">//存储元素的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ii.链表实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListQueue</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Queue</span>&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> Link head;</span><br><span class="line">  <span class="keyword">private</span> Link tail;</span><br><span class="line">  LinkedListQueue()&#123;...&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span>&#123;...&#125;</span><br><span class="line">  <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后我们就可以在应用中用它了<br>上面是我们自己写的，其实Java库的开发者已经把上面的工作全做了，而且很系统的开发了很多数据结构供我们使用,<br>实际上我们只需要学习如何使用就可以了。</li></ul><h1><span id="2java集合框架中有哪些接口">2.Java集合框架中有哪些接口？</span></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">Collection --extend--&gt; Iterable</span><br><span class="line"></span><br><span class="line">List--extend--&gt; Collection</span><br><span class="line"></span><br><span class="line">Set--extend--&gt; Collection</span><br><span class="line"></span><br><span class="line">Queue--extend--&gt; Collection</span><br><span class="line"></span><br><span class="line">SortedMap --extend--&gt; Map</span><br><span class="line"></span><br><span class="line">SortedSet--extend--&gt;Set</span><br><span class="line">Deque--extend--&gt;Queue</span><br><span class="line">NavigableMap --extend--&gt; SortedMap</span><br><span class="line">NavigbleSet --extend--&gt; SortedSet</span><br><span class="line">ListIterator--extend--&gt;Iterator</span><br><span class="line">RandomAccess</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>这张图为我们比较完整的描述就Java中集合框架的基本接口。下面我们先了解一些比较重要的接口</strong></p><h2><span id="21iterable接口">2.1.Iterable接口</span></h2><p>它是一个迭代器接口，实现它的类都是可被按顺序遍历的集合类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取迭代器</span></span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//default是在java8中引入的关键字，在接口内部包含了一些默认的方法实现，</span></span><br><span class="line">    <span class="comment">//从而使得接口在进行扩展的时候，不会破坏与接口相关的实现类代码。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 对Iterable的每个元素执行给定的操作，直到所有元素都被处理或动作引发异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="built_in">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *在Iterable描述的元素上创建一个Iterable</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title function_">spliterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="22-collection接口">2.2 Collection接口</span></h2><p>它继承了迭代器接口。它是集合接口，它里面定义了一些方法，这些方法都是操作集合的常用方法。<br>这个接口有两个基本方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt;&#123;</span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E element)</span>;<span class="comment">//添加元素方法</span></span><br><span class="line"> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;<span class="comment">//迭代器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>[对于Collection的具体学习请看上一节](/9.1 Java集合接口学习)。</strong></p><h2><span id="23-listsetqueue">2.3 List,Set,Queue</span></h2><p>List，Set ，Queue接口则是继承Collection定义具体的数据结构的接口</p><p>其中List定义了链表, 对应着链表数据结构, 线性顺序存储元素集</p><p>Set定义了不重复集数据结构, 一般是非线性无序存储不重复的元素集</p><p>Queue定义了队列数据结构, 其数据集遵守着先进先出的基本原则</p><h2><span id="24-map接口">2.4 Map接口</span></h2><p>它是一个独立的接口，它不继承Collection接口</p><p>它用来定义键值对数据结构的接口, 一般用的是Hash映射(时间复杂度为1)</p><p>它定义的接口常用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从该Map中删除所有的映射数据（可选操作）: 清空操作</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果此Map包含指定key，则返回 true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果此Map包含指定的value，则返回 true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回此Map中包含的Entry的Set集合,可以用来遍历Map</span></span><br><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</span><br><span class="line"></span><br><span class="line"><span class="comment">//将指定的对象与此Map对象相比较获得相等性。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回到指定键所对于的值，如果不包含指定的键，则返回null</span></span><br><span class="line">V<span class="title function_">get</span><span class="params">(Object key)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回到指定键所对于的值，如果不包含指定的键，则返回defaultValue</span></span><br><span class="line"><span class="keyword">default</span> V <span class="title function_">getOrDefault</span><span class="params">(Object key, V defaultValue)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回此对象的hashCode</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断此Map是否为空</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回此Map中包含的键的Set视图。</span></span><br><span class="line">Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向Map中添加键值对</span></span><br><span class="line">V<span class="title function_">put</span><span class="params">(K key, V value)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将另一个Map的所有键值对添加到此Map中</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K,? extends V&gt; m)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据键从Map中删除一个键值对</span></span><br><span class="line">V <span class="title function_">remove</span><span class="params">(Object key)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//只有给出的key,value和存储的对的上，才进行删除操作</span></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object key, Object value)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /只有给出的key,value和存储的对的上，才进行替换操作</span></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">replace</span><span class="params">(K key, V oldValue, V newValue)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回此Map中存储的键值对的数量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回此Map中包含的值的Collection对象。</span></span><br><span class="line">Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h2><span id="25-iterator接口">2.5 Iterator接口</span></h2><p>迭代器接口，里面的方法用于遍历集合元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对每个剩余元素执行给定的操作，直到所有元素都被处理或动作引发异常。</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果迭代具有更多元素，则返回 true 。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回迭代中的下一个元素。</span></span><br><span class="line">E <span class="title function_">next</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从底层集合中删除此迭代器返回的最后一个元素（可选操作）。</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p><strong>每个支持迭代器的集合都应该给出自己的实现。</strong></p><h2><span id="26randomaccess接口">2.6.RandomAccess接口</span></h2><p>此接口是一个标记接口，实现它的集合类具备支持随机访问的能力。<br>表明它们支持快速（通常为恒定时间）随机访问。</p><h2><span id="27-基础接口的具体实现">2.7 基础接口的具体实现</span></h2><p>其他的所有接口或具体的实现类都是由Collection,Map,Iterator,Iterable衍生而来。<br>抽象类分别实现了对应的接口</p><p>如下图：</p><p>Collection衍生集合派系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">AbstractCollection--impl--&gt;Collection</span><br><span class="line">AbstractList --extend--&gt;AbstractCollection</span><br><span class="line">AbstractSet --extend--&gt;AbstractCollection</span><br><span class="line">AbstractQueue--extend--&gt;AbstractCollection</span><br><span class="line">ArrayQueue--extend--&gt;AbstractCollection</span><br><span class="line">AbstractSequentialList--extend--&gt;AbstractList</span><br><span class="line">ArrayList --extend--&gt; AbstractList</span><br><span class="line">LinkedList--extend--&gt;AbstractSequentialList</span><br><span class="line">HashSet--extend--&gt;AbstractSet</span><br><span class="line">EnumSet--extend--&gt;AbstractSet</span><br><span class="line">TreeSet--extend--&gt;AbstractSet</span><br><span class="line">LinkedHashSet--extend--&gt;HashSet</span><br><span class="line">PriorityQueue--extend--&gt;AbstractQueue</span><br></pre></td></tr></table></figure><p>Map衍生集合派系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">AbstractMap--impl--&gt;Map</span><br><span class="line">HashMap--extend--&gt;AbstractMap</span><br><span class="line">TreeMap--extend--&gt;AbstractMap</span><br><span class="line">EnumMap--extend--&gt;AbstractMap</span><br><span class="line">WeakHashMap--extend--&gt;AbstractMap</span><br><span class="line">IdentityHashMap--extend--&gt;AbstractMap</span><br><span class="line">LinkedHashMap--extend--&gt;HashMap</span><br></pre></td></tr></table></figure><h2><span id="28-java类库中的具体集合有14个">2.8 java类库中的具体集合有14个</span></h2><table><thead><tr><th>集合类型</th><th>描述</th></tr></thead><tbody><tr><td>ArrayList</td><td>一种可以动态增长和缩减的索引序列</td></tr><tr><td>LinkedList</td><td>一种可以在任何位置进行高效地插入和删除操作的有序序列</td></tr><tr><td>ArrayDeque</td><td>一种用循环数组实现的双端队列</td></tr><tr><td>HashSet</td><td>一种没有重复元素的无序集合</td></tr><tr><td>TreeSet</td><td>一种没有重复元素的有序集合</td></tr><tr><td>EnumSet</td><td>一种包含枚举类型值的集</td></tr><tr><td>LinkedHashSet</td><td>一种可以记住元素插入次序的集</td></tr><tr><td>PriorityQueue</td><td>一种允许高效删除最小/大元素的集合</td></tr><tr><td>HashMap</td><td>存储key-value结构的数据结构</td></tr><tr><td>TreeMap</td><td>存储key有序的key-value的数据结构</td></tr><tr><td>EnumMap</td><td>一种键值属于枚举类型的映射表</td></tr><tr><td>LinkedHashMap</td><td>一种可以记录键值插入顺序的结构</td></tr><tr><td>WeakHashMap</td><td>一种其值没用后可以被垃圾回收器回收的结构</td></tr><tr><td>IdentityHashMap</td><td>一种用==而不是用equals比较键值的结构</td></tr></tbody></table><p><strong>在接下来的博客中我会具体的分析每个集合的特性和学习如何使用它们。</strong></p> ]]>
        </content>
           
        <summary type="html">&lt;p&gt;学习总结自《java核心技术卷Ⅰ》&lt;/p&gt;
&lt;h1&gt;&lt;span id=&quot;1java集合框架&quot;&gt;1.Java集合框架&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;Java最初的版本只为最常用的数据结构提供了一组类：Vector(链表),Stack(栈),Hashtable(哈希表)，&lt;br</summary>
            
        <category term="Java进阶" scheme="https://1776167012.github.io/tags/Java%E8%BF%9B%E9%98%B6/" />
        
    </entry>
    
    <entry>
        <title>9.3 Java集合之List(基本概念,API,存储原理)</title>
        <link href="https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-9-3-Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E4%B9%8BList%EF%BC%88%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%8CAPI%EF%BC%8C%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86%EF%BC%89/" />
        <id>https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-9-3-Java%E9%9B%86%E5%90%88%E5%AD%A6%E4%B9%A0%E4%B9%8BList%EF%BC%88%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%8CAPI%EF%BC%8C%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86%EF%BC%89/</id>
        <published>2023-05-20T03:49:00.000Z</published>
        <updated>2026-01-05T03:33:15.911Z
        </updated>
        
        <content type="html">
            <![CDATA[ <h1><span id="1-list接口">1. List接口</span></h1><p>在学习List接口之前我们还是得复习下这张图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">Collection --extend--&gt; Iterable</span><br><span class="line"></span><br><span class="line">List--extend--&gt; Collection</span><br><span class="line"></span><br><span class="line">Set--extend--&gt; Collection</span><br><span class="line"></span><br><span class="line">Queue--extend--&gt; Collection</span><br><span class="line"></span><br><span class="line">SortedMap --extend--&gt; Map</span><br><span class="line"></span><br><span class="line">SortedSet--extend--&gt;Set</span><br><span class="line">Deque--extend--&gt;Queue</span><br><span class="line">NavigableMap --extend--&gt; SortedMap</span><br><span class="line">NavigbleSet --extend--&gt; SortedSet</span><br><span class="line">ListIterator--extend--&gt;Iterator</span><br><span class="line">RandomAccess</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从图中我们知道了，<strong>List接口继承了Collection接口</strong>。</p><p>也就是说List接口是在Collection接口的基础上衍生出来的具体的链表数据结构的接口，在Java集合中，链表数据结构类都必须要实现List接口。<br>通过查看List接口的定义并和Collection接口进行比较，可以找到，专属于List接口的方法有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定开始位置将另一个集合的元素插入进List中</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将List中的元素通过传入的Operator进行替换处理</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(operator);</span><br><span class="line">    <span class="keyword">final</span> ListIterator&lt;E&gt; li = <span class="built_in">this</span>.listIterator();</span><br><span class="line">    <span class="keyword">while</span> (li.hasNext()) &#123;</span><br><span class="line">        li.set(operator.apply(li.next()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将List中的元素通过传入的Comparator进行排序处理</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = <span class="built_in">this</span>.toArray();</span><br><span class="line">    Arrays.sort(a, (Comparator) c);</span><br><span class="line">    ListIterator&lt;E&gt; i = <span class="built_in">this</span>.listIterator();</span><br><span class="line">    <span class="keyword">for</span> (Object e : a) &#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.set((E) e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据索引位置得到指定位置的元素</span></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重置指定索引位置的元素</span></span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向指定位置插入新的元素</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除指定位置的元素</span></span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到第一个和对象o相等的对象的位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到最后一个和对象o相等的对象的位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得链表迭代器</span></span><br><span class="line">ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得指定起始位置的链表迭代器</span></span><br><span class="line">ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得指定位置范围的链表</span></span><br><span class="line">List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span>;</span><br></pre></td></tr></table></figure><h1><span id="2-list的具体实现">2. List的具体实现</span></h1><table><thead><tr><th>集合类型</th><th>描述</th></tr></thead><tbody><tr><td>ArrayList</td><td>一种可以动态增长和缩减的索引序列</td></tr><tr><td>LinkedList</td><td>一种可以在任何位置进行高效地插入和删除操作的有序序列</td></tr><tr><td>ArrayDeque</td><td>一种用循环数组实现的双端队列</td></tr><tr><td>HashSet</td><td>一种没有重复元素的无序集合</td></tr><tr><td>TreeSet</td><td>一种没有重复元素的有序集合</td></tr><tr><td>EnumSet</td><td>一种包含枚举类型值的集</td></tr><tr><td>LinkedHashSet</td><td>一种可以记住元素插入次序的集</td></tr><tr><td>PriorityQueue</td><td>一种允许高效删除最小/大元素的集合</td></tr><tr><td>HashMap</td><td>存储key-value结构的数据结构</td></tr><tr><td>TreeMap</td><td>存储key有序的key-value的数据结构</td></tr><tr><td>EnumMap</td><td>一种键值属于枚举类型的映射表</td></tr><tr><td>LinkedHashMap</td><td>一种可以记录键值插入顺序的结构</td></tr><tr><td>WeakHashMap</td><td>一种其值没用后可以被垃圾回收器回收的结构</td></tr><tr><td>IdentityHashMap</td><td>一种用==而不是用equals比较键值的结构</td></tr></tbody></table><p>在具体的查看源码前，我们可以根据上面的表格先猜出那些具体的集合是通过实现List接口来定义的：<br>ArrayList,  LinkedList 这是两个比较明显的实现了。</p><h2><span id="21-arraylist">2.1 ArrayList</span></h2><p>简单介绍一下ArrayList的实现就是：</p><p>ArrayList是基于动态数组实现的一个链表数据结构的一个<strong>线程不安全</strong>的类。</p><p>它的使用特性是<strong>插入，删除慢。修改快，查询快，且支持随机查询（根据get(int index)能以常数时间获取元素）。</strong></p><h3><span id="211-存储原理">2.1.1 存储原理</span></h3><ul><li>开辟存储存储空间：<br>如果使用的是默认无参构造方法，size<em>1.5&lt;=size+1，则为elementData开辟10个对象空间。<br>如果使用的是指定数量的构造方法，size</em>1.5&lt;=size+1，则为elementData开辟size+1个对象空间。</li><li>扩容机制：<br>每次添加前会对size+1进行检查<br>如果在原数组的基础上增加了一半后大于size+1且小于MAX_ARRAY_SIZE,则将数组扩容至150%大小。</li></ul><p><em><strong>具体的实现可以查阅Jdk源码来进行学习。</strong></em></p><h3><span id="212-性能测试实例">2.1.2  性能测试实例</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完整代码地址在文章最后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = addTest(<span class="number">100000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改耗时：&quot;</span>+updateTest(list)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;查询耗时： &quot;</span>+queryTest(list)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;插入耗时： &quot;</span>+insertTest(list)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;删除耗时： &quot;</span>+deleteTest(list)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">添加耗时：5ms</span><br><span class="line">修改耗时：5ms</span><br><span class="line">查询耗时： 4ms</span><br><span class="line">插入耗时： 2760ms</span><br><span class="line">删除耗时： 2167ms</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>上面的测试结果实事求是的验证了ArrayList的 <strong>插入，删除慢。</strong></p><h2><span id="22-linkedlist">2.2 LinkedList</span></h2><p>简单概述一下LinkedList的实现就是：LinkedList是基于双向链表实现的一个链表数据结构实现的一个<strong>线程不安全</strong>的类。</p><h3><span id="221-存储原理">2.2.1 存储原理</span></h3><p>LinkedList 采用链表存储，如果是在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e) addLast(E e)、removeFirst()、 removeLast()），时间复杂度为 O(1)，效率非常好。<br>如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o)）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入。<strong>但是不需要进行原有数据的整体移动处理。</strong></p><p>需要注意的是： <strong>LinkedList不支持高效随机元素访问，ArrayList支持。 LinkedList则无需担心扩容问题，它的存储原理是需要的时候进行开辟空间，然后通过引用链接到一起，所以LinkedList的存储位置是碎片化，不连续的。</strong></p><p>具体的实现请查阅源码。</p><h3><span id="222-性能测试实例">2.2.2 性能测试实例</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码地址在文章最后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = addTest(<span class="number">100000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改耗时：&quot;</span>+updateTest(list)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;查询耗时： &quot;</span>+queryTest(list)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;插入耗时： &quot;</span>+insertTest(list)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;删除耗时： &quot;</span>+deleteTest(list)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">添加耗时：6ms</span><br><span class="line">修改耗时：5284ms</span><br><span class="line">查询耗时： 4917ms</span><br><span class="line">插入耗时： 8351ms</span><br><span class="line">删除耗时： 7564ms</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>可以看到，相比而言，其总体性能和ArrayList相比差距还是较大的,所以在实际的使用过程中, ArrayList是首选。</p><h2><span id="23-vector">2.3 Vector</span></h2><p>其实除了ArrayList, LinkedList两种有名的实现之外，JDK最开始提供的List的实现版本是Vector但是它的性能和功能都逐渐被淘汰了。</p><h3><span id="231-存储原理">2.3.1 存储原理</span></h3><p>Vector底层用的是数组实现。 它的关键操作方法都是同步的，这使得线程安全，但是性能不好。</p><ul><li>开辟内存空间<br>默认开辟10个内存空间</li><li>扩容机制<br>既然是使用数组实现，那么它也一定会有相应的扩容机制，每次添加前会对elementCount+1进行检查，<br>如果它大于了数组长度，则进行扩容，采用的基本逻辑是如果指定了扩容大小capIncre，则扩为 oldCap+capIncre,否则进行<strong>两倍扩容</strong>。扩完后如果还是小于elementCount+1,则newCap = elementCount+1<br>还进行了一些极限纠正。</li></ul><p>具体的实现请查阅源码。</p><h3><span id="232-性能测试实例">2.3.2 性能测试实例</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完整代码地址见下方链接</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = addTest(<span class="number">100000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改耗时：&quot;</span>+updateTest(list)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;查询耗时： &quot;</span>+queryTest(list)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;插入耗时： &quot;</span>+insertTest(list)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;删除耗时： &quot;</span>+deleteTest(list)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">添加耗时：15ms</span><br><span class="line">修改耗时：12ms</span><br><span class="line">查询耗时： 6ms</span><br><span class="line">插入耗时： 3288ms</span><br><span class="line">删除耗时： 2760ms</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>可以看到在这个测试实例下，Vector的性能和ArrayList相差不大。<br>但是，在多线程的情况下它的性能下降的还是很厉害的。</p><p>完整代码地址：<br><a href="https://gitee.com/yan-jiadou/study/tree/master/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/src/main/java/Progress/exa27_3">https://gitee.com/yan-jiadou/study/tree/master/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/src/main/java/Progress/exa27_3</a></p><blockquote><p>LinkedList部分参考了文章： <a href="https://javaguide.cn/java/collection/java-collection-questions-01.html#collection-%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B9%8B-list">https://javaguide.cn/java/collection/java-collection-questions-01.html#collection-%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B9%8B-list</a></p></blockquote> ]]>
        </content>
           
        <summary type="html">&lt;h1&gt;&lt;span id=&quot;1-list接口&quot;&gt;1. List接口&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;在学习List接口之前我们还是得复习下这张图&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter</summary>
            
        <category term="Java进阶" scheme="https://1776167012.github.io/tags/Java%E8%BF%9B%E9%98%B6/" />
        
    </entry>
    
    <entry>
        <title>9.4 Java集合之Map学习</title>
        <link href="https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-9-4-Java%E9%9B%86%E5%90%88%E4%B9%8BMap%E5%AD%A6%E4%B9%A0/" />
        <id>https://1776167012.github.io/article/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB-Java%E8%BF%9B%E9%98%B6-9-4-Java%E9%9B%86%E5%90%88%E4%B9%8BMap%E5%AD%A6%E4%B9%A0/</id>
        <published>2023-05-20T03:48:00.000Z</published>
        <updated>2026-01-05T03:33:15.911Z
        </updated>
        
        <content type="html">
            <![CDATA[ <h1><span id="1map接口">1.Map接口</span></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">SortedMap --extend--&gt; Map</span><br><span class="line">NavigableMap --extend--&gt; SortedMap</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上图中我们知道Map是个独立的接口,它和Collection是一个层次的,他们之间不存在继承关系，但可能存在组合关系。<br>Map是用来存储键值对的数据结构。</p><h2><span id="11-map接口定义">1.1 Map接口定义</span></h2><table><thead><tr><th>方法定义</th><th>方法描述</th></tr></thead><tbody><tr><td>int size()</td><td>获得Map中存储键值对个数</td></tr><tr><td>boolean isEmpty()</td><td>判断Map是否为空</td></tr><tr><td>boolean containsKey(Object key)</td><td>判断Map中是否包含指定键</td></tr><tr><td>boolean containsValue(Object value)</td><td>判断Map中是否包含指定值</td></tr><tr><td>V get(Object key)</td><td>根据键对象在Map中获取对应的值</td></tr><tr><td>V put(K key,V value)</td><td>向Map中添加键值对</td></tr><tr><td>V remove(Object key)</td><td>从Map中删除指定键对应的键值对</td></tr></tbody></table><p>等等.</p><p>从上面我们可以看到，如果我们想得到包含键值对的集合对Map进行遍历，我们可以对Map.Entry来进行操作。</p><p>下面我们就来学习一下Map中对于Entry的定义</p><h2><span id="12-entry接口">1.2 Entry接口</span></h2><table><thead><tr><th>方法定义</th><th>方法描述</th></tr></thead><tbody><tr><td>K getKey()</td><td>获取Key值</td></tr><tr><td>V getValue()</td><td>获取Value值</td></tr><tr><td>V setValue(V value)</td><td>设置value并返回旧值</td></tr></tbody></table><p>等等.</p><h1><span id="2-map具体实现">2. Map具体实现</span></h1><table><thead><tr><th>集合类型</th><th>描述</th></tr></thead><tbody><tr><td>ArrayList</td><td>一种可以动态增长和缩减的索引序列</td></tr><tr><td>LinkedList</td><td>一种可以在任何位置进行高效地插入和删除操作的有序序列</td></tr><tr><td>ArrayDeque</td><td>一种用循环数组实现的双端队列</td></tr><tr><td>HashSet</td><td>一种没有重复元素的无序集合</td></tr><tr><td>TreeSet</td><td>一种没有重复元素的有序集合</td></tr><tr><td>EnumSet</td><td>一种包含枚举类型值的集</td></tr><tr><td>LinkedHashSet</td><td>一种可以记住元素插入次序的集</td></tr><tr><td>PriorityQueue</td><td>一种允许高效删除最小/大元素的集合</td></tr><tr><td>HashMap</td><td>存储key-value结构的数据结构</td></tr><tr><td>TreeMap</td><td>存储key有序的key-value的数据结构</td></tr><tr><td>EnumMap</td><td>一种键值属于枚举类型的映射表</td></tr><tr><td>LinkedHashMap</td><td>一种可以记录键值插入顺序的结构</td></tr><tr><td>WeakHashMap</td><td>一种其值没用后可以被垃圾回收器回收的结构</td></tr><tr><td>IdentityHashMap</td><td>一种用==而不是用equals比较键值的结构</td></tr></tbody></table><p>从图中可以看到实现的Map的类有：<br>HashMap, TreeMap, EnumMap, LinkedHashMap, WeakHashMap, IdentityHashMap 6个，<br>如果算上AbstractMap，就是7个了。</p><h2><span id="21-abstractmap">2.1 AbstractMap</span></h2><p>在Jdk中，和Collection体系一样，也提供了抽象类AbstractMap，其中包含了一些可复用的代码，方便在编写具体实现类时不做重复的工作。<br>我们可以参考它的实现来学习如何去实现一个Map<br>我们可以看一下其中的一些实现方法</p><h3><span id="211-put方法实现">2.1.1 put方法实现</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  向Map中添加一个键值对</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从这里我们可以看到，AbstractMap中是不提供put方法的实现的，因为它是随着存储原理的不同而不同的。</strong></p><h3><span id="212-get方法实现">2.1.2 get方法实现</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据key在Map中获取它的value, 提供了基础实现，</span></span><br><span class="line"><span class="comment">* 实现类逻辑很简单，就是先获得Entry的集合的迭代器，然后进行遍历比较key</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    <span class="keyword">if</span> (key==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (e.getKey()==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> e.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (key.equals(e.getKey()))</span><br><span class="line">                <span class="keyword">return</span> e.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从这里我们可以看到，在Map中是允许key为null的数据存储。</strong></p><h3><span id="213-size方法实现">2.1.3 size()方法实现</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这里取得就是Entry的集合的大小</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> entrySet().size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Set&lt;Entry&lt;K,V&gt;&gt; <span class="title function_">entrySet</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h3><span id="214-isempty方法实现">2.1.4 isEmpty方法实现</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 通过判断size()得到的值是否为0</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="215-containskey方法实现">2.1.5 containsKey方法实现</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 实现类逻辑很简单，就是先获得Entry的集合的迭代器，然后进行遍历比较key</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    <span class="keyword">if</span> (key==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (e.getKey()==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (key.equals(e.getKey()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="216-containsvalue方法实现">2.1.6 containsValue方法实现</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 实现类逻辑很简单，就是先获得Entry的集合的迭代器，然后进行遍历比较value</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">    <span class="keyword">if</span> (value==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (e.getValue()==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            <span class="keyword">if</span> (value.equals(e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多实现大家可以自行查阅源码进行学习。</p><h2><span id="22-hashmap">2.2 HashMap</span></h2><p>学习HashMap，首先我们要学习的是数据的存储结构：<br>通过阅读源码我们知道了，HashMap的存储结构是数组+链表+红黑树存储，将数据存放到Node类型的数组中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以知道Node实现了Entry接口</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="221-扩容机制">2.2.1 扩容机制</span></h3><p>既然是数组存储结构，那么它的扩容机制是我们一定要了解的！！<br>HashMap的扩容逻辑放在方法resize()中，其逻辑如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如果是oldCap=<span class="number">0</span>且oldThr=<span class="number">0</span>，初始化容量为：<span class="number">16</span>，负载因子为：<span class="number">0.75</span>  初始扩容阈值为：<span class="number">16</span>*<span class="number">0.75</span>=<span class="number">12</span></span><br><span class="line">如果oldCap&gt;<span class="number">0</span>:</span><br><span class="line">    如果oldCap&gt;=(<span class="number">1</span>&lt;&lt;<span class="number">30</span>), 将阈值调为<span class="number">2</span>^<span class="number">31</span>-<span class="number">1.</span>,不进行扩容. </span><br><span class="line">    如果oldCap&lt;(<span class="number">1</span>&lt;&lt;<span class="number">30</span>), 则newCap = oldCap*<span class="number">2</span>, newThr = oldThr *<span class="number">2</span></span><br><span class="line">如果oldCap&lt;=<span class="number">0</span>&amp;&amp;oldThr&gt;<span class="number">0</span></span><br><span class="line">   newCap = oldThr</span><br><span class="line">如果oldThr = <span class="number">0</span>, 计算之： newThr = newCap*loadFactor || MAX_VALUE</span><br><span class="line">然后进行新数组创建，旧数组的数据迁移到新数组中,在这个迁移过程中可能会出现树转链表的操作。</span><br></pre></td></tr></table></figure><p>总而言之,一般情况下HashMap的默认初始容量为16,负载因子为0.75, 扩容机制为2倍扩容。</p><h3><span id="222-存储原理">2.2.2 存储原理</span></h3><p>对于HashMap的存储原理，我们可以分为两类：</p><ul><li><p>不存在hash冲突的存储原理：如果不存在hash冲突，其存储原理是通过Key的（hash值 &amp; 数组长度-1）取余计算出该Node在Node数组中存储的位置，然后通过newNode方法新建一个Node并存储到指定位置。</p></li><li><p>存在hash冲突的存储原理：首先我们要知道为啥存在冲突了呢？ 通过前面的存储原理我们知道元素存储的位置是通过(n - 1) &amp; hash计算出来的，那么 在n-1不变的情况下，不同的Key的hash值和n-1通过与运算可能得到相同的结果，相同的Key的hash值就更不用说了，所以hash冲突发生从情况有两种：</p><ul><li>使用相同的Key进行put: 对原有位置的value进行覆盖为最新的。</li><li>使用不同的Key进行put:<br>如果冲突的个数小于8个，采用链接法进行解决，就是将原有位置上最外层的元素的next指向它，如图：</li></ul></li></ul><p>![img.png](9.4 Java集合之Map学习/img.png)</p><p><strong>如果冲突的个数大于了8个，如果数组的长度大于或等于了最小树化容量（默认64）,则进行树化（链表转为红黑树），否则进行扩容操作。</strong></p><p><strong>何时转会链表？</strong><br>当树的大小小于7的时候，会将树转回链表结构。<br><strong>为何要转成树结构？</strong><br>因为长度过长的化链表的检索速度是比较慢的O(n)，而树结构则检索比较快O(logn)。</p><p><strong>为何树结构用的是红黑树，而不是平衡二叉查找树？</strong></p><ul><li><p>AVL 和RBT 都是二叉查找树的优化。其性能要远远好于二叉查找树。他们之间都有自己的优势，其应用上也有不同。</p></li><li><p>结构对比： AVL的结构高度平衡，RBT的结构基本平衡。平衡度AVL &gt; RBT.</p></li><li><p>查找对比： AVL 查找时间复杂度最好，最坏情况都是O(logN)。RBT 查找时间复杂度最好为O(logN)，最坏情况下比AVL略差。</p></li><li><p>插入删除对比：<br><strong>AVL的插入和删除结点很容易造成树结构的不平衡，而RBT的平衡度要求较低。因此在大量数据插入的情况下，RBT需要通过旋转变色操作来重新达到平衡的频度要小于AVL。<br>如果需要平衡处理时，RBT比AVL多一种变色操作，而且变色的时间复杂度在O(logN)数量级上。但是由于操作简单，所以在实践中这种变色仍然是非常快速的。<br>当插入一个结点都引起了树的不平衡，AVL和RBT都最多需要2次旋转操作。但删除一个结点引起不平衡后，AVL最多需要logN 次旋转操作，而RBT最多只需要3次。因此两者插入一个结点的代价差不多，但删除一个结点的代价RBT要低一些。</strong><br>AVL和RBT的插入删除代价主要还是消耗在查找待操作的结点上。因此时间复杂度基本上都是与O(logN) 成正比的。</p></li></ul><p><strong>总体评价：大量数据实践证明，RBT的总体统计性能要好于平衡二叉树。</strong></p><h3><span id="223-性能测试实例">2.2.3 性能测试实例</span></h3><p>HashMap的存取效率都很高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">   <span class="comment">//测试存储效率</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000000</span>;i++)&#123;</span><br><span class="line">        map.put(i+ (<span class="type">int</span>) (Math.random() * <span class="number">100</span>),i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">end1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;存储耗时： &quot;</span>+ (end1-start)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000000</span>;i++)&#123;</span><br><span class="line">        map.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;查询耗时：&quot;</span>+(System.currentTimeMillis()-end1)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">存储耗时： 4829ms</span><br><span class="line">查询耗时：154ms</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>使用HashMap存取1000万的数据耗时在10秒以内，可见其存取效率了。</p><h2><span id="23-treemap">2.3 TreeMap</span></h2><h3><span id="231-存储原理">2.3.1 存储原理</span></h3><p>TreeMap是Map的有序实现，它会根据键的顺序将元素组织为一个搜索树，使用的存储结构是红黑树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于红黑树，感兴趣的同学可以仔细阅读源码，看看它是如何实现增删改查操作的。<br><strong>TreeMap默认的存储是根据Key的大小顺序存储的，也就是说遍历的时候是Key有序的遍历。默认是按 key 的升序排序</strong></p><h3><span id="232-性能测试实例">2.3.2 性能测试实例</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    TreeMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//测试存储效率</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000000</span>;i++)&#123;</span><br><span class="line">        map.put(i+ (<span class="type">int</span>) (Math.random() * <span class="number">100</span>),i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">end1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;存储耗时： &quot;</span>+ (end1-start)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000000</span>;i++)&#123;</span><br><span class="line">        map.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;查询耗时：&quot;</span>+(System.currentTimeMillis()-end1)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">存储耗时： 5466ms</span><br><span class="line">查询耗时：1136ms</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>TreeMap在相同条件下的存储性能还要略好于HashMap, 但其查询性能略低于HashMap， 但是它有着HashMap难以实现的特性：它可以实现有序存储。</p><h2><span id="24-enummap">2.4 EnumMap</span></h2><h3><span id="241-存储原理">2.4.1 存储原理</span></h3><p>基于数组实现，但是其中不存在扩容机制。<br>这个Map实现比较特殊，它的Key只能是枚举类型的, 因为枚举类型的对象自带唯一属性，所以使用它无需考虑冲突问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 从这里可以看出,EnumMap在构造时已经将长度定义好了：</span></span><br><span class="line"><span class="comment">*  就是枚举类中枚举值的数量</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">EnumMap</span><span class="params">(Class&lt;K&gt; keyType)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.keyType = keyType;</span><br><span class="line">    keyUniverse = getKeyUniverse(keyType);</span><br><span class="line">    vals = <span class="keyword">new</span> <span class="title class_">Object</span>[keyUniverse.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    typeCheck(key);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> key.ordinal();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">oldValue</span> <span class="operator">=</span> vals[index];</span><br><span class="line">    vals[index] = maskNull(value);</span><br><span class="line">    <span class="keyword">if</span> (oldValue == <span class="literal">null</span>)</span><br><span class="line">        size++;</span><br><span class="line">    <span class="keyword">return</span> unmaskNull(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>EnumMap的特性是存取效率极高，但是使用范围有限。</strong></p><h3><span id="242-使用实例">2.4.2 使用实例</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumMapStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        EnumMap&lt;TestEnum, String&gt; enumMap = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(TestEnum.class);</span><br><span class="line">        enumMap.put(TestEnum.ONE, <span class="string">&quot;333&quot;</span>);</span><br><span class="line">        enumMap.put(TestEnum.ONE,<span class="string">&quot;999&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;TestEnum, String&gt; entry : enumMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey()+<span class="string">&quot;:&quot;</span>+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">TestEnum</span>&#123;</span><br><span class="line">    ONE,TWO, THREE,FOUR,FIVE,SIX,SEVEN,EIGHT,NINE,TEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ONE:999</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2><span id="25-linkedhashmap">2.5 LinkedHashMap</span></h2><h3><span id="251-存储原理">2.5.1 存储原理</span></h3><p>LinkedHashMap继承了HashMap实现，是对HashMap的一种增强：<br>它会记住插入元素的顺序，这样在使用迭代器进行遍历的时候，遍历元素则是有序的。<br>LinkedHashMap通过重写newNode方法，让其在新创建Node的时候<strong>将其插入顺序通过双向链表结构记录下来。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure><p>注意：它和TreeMap的差别。</p><h3><span id="252-性能测试实例">2.5.2 性能测试实例</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    LinkedHashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//测试存储效率</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000000</span>;i++)&#123;</span><br><span class="line">        map.put(i+ (<span class="type">int</span>) (Math.random() * <span class="number">100</span>),i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">end1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;存储耗时： &quot;</span>+ (end1-start)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000000</span>;i++)&#123;</span><br><span class="line">        map.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;查询耗时：&quot;</span>+(System.currentTimeMillis()-end1)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">存储耗时： 3030ms</span><br><span class="line">查询耗时：2076ms</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>由于它继承了HashMap，所以它在性能上和HashMap差不多，但是在能力上，它具有记忆键值对插入顺序的能力。</p><h2><span id="26-weakhashmap">2.6 WeakHashMap</span></h2><p>简单来说这个Map实现能有效的节省空间，当使用它存储键值对的时候，当值没有地方用它的时候可以被垃圾回收器回收从而提高空间利用率。</p><h3><span id="261-存储原理">2.6.1 存储原理</span></h3><p>通过阅读源码我们可以知道：<br>Entry&lt;K,V&gt;[] table;<br>WeakHashMap的存储方式是通过数组实现的，存储计算逻辑和HashMap类似，通过计算Key的hash,然后和数组最大索引值进行按位与运算，获得存储位置。</p><h3><span id="262-weakhashmap特性">2.6.2 WeakHashMap特性</span></h3><p>在WeakHashMap中，Key键是一个弱引用的键，如果Key键被回收，则在get该map中值后，会自动remove掉value<br>如果Key键始终被强引用，则是无法被回收的；<br>注意Value是被强引用的，所以不要让Value间接的引用了Key键，这将导致key始终被强引用<br>适合于受Key的生命周期控制的缓存</p><blockquote><p><a href="https://www.php.cn/java-article-368794.html">Java对象的强、软、弱和虚引用+ReferenceQueue-java教程-PHP中文网</a></p></blockquote><h3><span id="263-使用实例">2.6.3 使用实例</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    WeakHashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        map.put(i,i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(map.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="27-identityhashmap">2.7 IdentityHashMap</span></h2><p>此Map实现“允许” 相同的Key存入， 原因是进行重复性检查用的是== 而不是equals， 这就使得如果Key是复杂引用类型，那么会出现存储相同的键值对的情况。</p><h3><span id="271-存储原理">2.7.1 存储原理</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] table;</span><br></pre></td></tr></table></figure><p>通过查阅源码，发现的存储结构也是数组。<br>不过它的数据结构不用Entry了哦，而是直接时Object了哦，这和其他的Map实现不同了。<br>所以就去看了put方法的实现，果然，看出了不一样的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tab[i] = k;</span><br><span class="line">tab[i + <span class="number">1</span>] = value;</span><br></pre></td></tr></table></figure><p>从这里可以看到，IdentityHashMap虽然用的数组存储，但是它的key和value是挨在一起存储的。<br><strong>具体的实现还需查阅源码。</strong></p><h3><span id="272-使用实例">2.7.2 使用实例</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    IdentityHashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">IdentityHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Integer</span>(i),i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        map.put(i,i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;map 大小： &quot;</span>+map.size());</span><br><span class="line"></span><br><span class="line">    IdentityHashMap&lt;Integer,Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">IdentityHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        map1.put(i,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        map1.put(i,i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;map1 大小：&quot;</span>+map1.size());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map 大小： 20</span><br><span class="line">map1 大小：10</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>代码地址：<br><a href="https://gitee.com/yan-jiadou/study/tree/master/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/src/main/java/Progress/exa27_4">Java基础学习/src/main/java/Progress/exa27_4 · 严家豆/Study - 码云 - 开源中国 (gitee.com)</a></p> ]]>
        </content>
           
        <summary type="html">&lt;h1&gt;&lt;span id=&quot;1map接口&quot;&gt;1.Map接口&lt;/span&gt;&lt;/h1&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;</summary>
            
        <category term="Java进阶" scheme="https://1776167012.github.io/tags/Java%E8%BF%9B%E9%98%B6/" />
        
    </entry>
    
</feed>